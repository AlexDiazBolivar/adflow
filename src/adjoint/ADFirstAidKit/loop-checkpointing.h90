! Benjamin Dauvergne November 2005
!
! This file implements functions to efficiently checkpoint loops
! You must change your big loop in a recursive function as
! prototype at the end of this file and change the choose_median
! parameter to fit your needs

      subroutine beta__(s,t,res)
       integer s,t,res,i
       res = 1
       do i=1,s
        res = res * (t+i)
        res = res / i
       enddo
      end subroutine beta__

      subroutine max_t_as_beta_under(s,l,res)
       integer s,l,res,t

       res = 0
       t = 0
       do while (res.lt.l)
        t = t + 1
        call beta__(s,t,res)
       enddo
       if (t.eq.0) then
        call beta__(s,t,res)
       else
        call beta__(s,t-1,res)
       endif
      end subroutine max_t_as_beta_under
      
! Choose a good point to put a checkpoint
! ntype determine the algorithm used:
! nfrom = starting iteration (in)
! nto = ending iteration (in)
! median = where to checkpoint (out)
! ntype = see below (in)
! s = max number of checkpoints
! minl, maxl = min and max on the size of the iteration domain to revert on another
!              technic than treeverse
! ntype2 = the checkpointing technic to use when nto - nfrom "< minl" or "> maxl"
! 
! Type kind:
! 1 dichotomy    ckp = ( from + to ) / 2
! 2 dichohomy/ra ckp = ( from + to ) / 2 if to-from > maxl else ckp = to-1
! 3 RA ckp = to-1
! 4 SA ckp = from
! 5 Treeverse ckp = from+binomial(s+t-1,t-1) where t = min { t / binomial(s+t,t)  > to-from } - 1
! 6 2-level ckp = if to-from > maxl then to - maxl else from
      recursive SUBROUTINE choose_median(nfrom, nto, median, ntype, s, minl, maxl,ntype2)
      integer nfrom,nto,ntype,s,l
      integer maxl,minl,ntype2
      integer median

       if (ntype.eq.1) then
!---------Dichotomy
          median = (nfrom+nto)/2
       else if (ntype.eq.2) then
!---------Dichotomy over 20 steps, recompute all under
          if ((nto-nfrom).gt.maxl) then
            median = (nfrom+nto)/2
          else
            median = nto-1
          endif
!---------Recompute all
       else if (ntype.eq.3) then 
         median = nto-1
       else if (ntype.eq.4) then
!---------Save all
         median = nfrom
       else if (ntype.eq.5) then
!---------Treeverse over 20 steps, recompute all under
         if ((nto-nfrom.gt.minl).and.(nto-nfrom.lt.maxl)) then
           call max_t_as_beta_under(s, nto-nfrom, l)
           median = nfrom+l-1
         else
! Remove the limits to protect from infinite recursivity
           call choose_median(nfrom, nto, median, ntype2, s, 0, 2000000, ntype2)
         endif
       else if (ntype.eq.6) then
!---------2-level checkpoints
         if (nto-nfrom.gt.maxl) then
           median = nto-maxl
         else
           median = nfrom
         endif
       endif
      END subroutine choose_median

! Prototype for the recursive function
! Iterate OneBigLooptIter from nfrom to nto inclusive
!      subroutine RecursiveBigLoopIters(nfrom,nto)
!
!      if (nfrom.eq.nto) then
!! $AD NOCHECKPOINT
!      call oneBigLoopIter()
!      goto 1000
!      endif
!
!      call choose_median(nfrom, nto, median,4,5,0,10000000,0)
!                                            \- ntype
!                                              \= max number of checkpoints
!                                                \= minl
!                                                  \= maxl
!                                                           \= ntype2
!! $AD NOCHECKPOINT
!      call RecursiveBigLoopIters(nfrom,median)
!      call RecursiveBigLoopIters(median+1,nto) 
!1000  END
