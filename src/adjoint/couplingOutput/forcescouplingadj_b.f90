!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of forcescouplingadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: padj skadj sjadj
!                siadj
!   of linear combination of output variables: forceloc
!
!      ******************************************************************
!      *                                                                *
!      * File:          forcesCouplingAdj.f90                           *
!      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
!      * Starting date: 08-17-2008                                      *
!      * Last modified: 08-17-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE FORCESCOUPLINGADJ_B(yplusmax, refpoint, siadj, siadjb, sjadj&
&  , sjadjb, skadj, skadjb, normadj, xadj, padj, padjb, wadj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, level, mm, nn, &
&  machcoefadj, forceloc, forcelocb, nsurfnodesloc, ii)
  USE bctypes
  USE blockpointers
  USE communication
  USE flowvarrefstate
  USE inputphysics
  IMPLICIT NONE
  INTEGER(KIND=INTTYPE) :: ii
  INTEGER(KIND=INTTYPE) :: i2beg, i2end, j2beg, j2end
  INTEGER(KIND=INTTYPE) :: iibeg, iiend, jjbeg, jjend
  INTEGER(KIND=INTTYPE) :: level, mm, nn
  REAL(KIND=REALTYPE) :: machcoefadj
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 3)&
&  , INTENT(IN) :: normadj
  INTEGER(KIND=INTTYPE) :: nsurfnodesloc
  REAL(KIND=REALTYPE) :: forceloc(3, nsurfnodesloc), forcelocb(3, &
&  nsurfnodesloc)
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(0:ib, 0:jb, 0:kb)
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: refpoint
  REAL(KIND=REALTYPE), DIMENSION(2, iibeg:iiend, jjbeg:jjend, 3)&
&  , INTENT(IN) :: siadj
  REAL(KIND=REALTYPE) :: siadjb(2, iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, 2, jjbeg:jjend, 3)&
&  , INTENT(IN) :: sjadj
  REAL(KIND=REALTYPE) :: sjadjb(iibeg:iiend, 2, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 2, 3)&
&  , INTENT(IN) :: skadj
  REAL(KIND=REALTYPE) :: skadjb(iibeg:iiend, jjbeg:jjend, 2, 3)
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb, nw), INTENT(IN) :: &
&  wadj
  REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3), INTENT(IN) :: &
&  xadj
  REAL(KIND=REALTYPE), INTENT(IN) :: yplusmax
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: dwall, fact
  REAL(KIND=REALTYPE) :: fn, fx, fxb, fy, fyb, fz, fzb, pm1
  INTEGER(KIND=INTTYPE) :: i, j, jj, k
  REAL(KIND=REALTYPE) :: pp1(iibeg:iiend, jjbeg:jjend), pp1b(iibeg:iiend&
&  , jjbeg:jjend), pp2(iibeg:iiend, jjbeg:jjend), pp2b(iibeg:iiend, &
&  jjbeg:jjend)
  REAL(KIND=REALTYPE) :: rho1(iibeg:iiend, jjbeg:jjend), rho2(iibeg:&
&  iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: pp, ppb, scaledim
  REAL(KIND=REALTYPE) :: ss(iibeg:iiend, jjbeg:jjend, 3), ssb(iibeg:&
&  iiend, jjbeg:jjend, 3)
  LOGICAL :: viscoussubface
  REAL(KIND=REALTYPE) :: xx(iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: xc, yc, zc
!
!      ******************************************************************
!      *                                                                *
!      * forcesAndMoments computes the contribution of the block        *
!      * given by the pointers in blockPointers to the force and        *
!      * moment coefficients of the geometry. A distinction is made     *
!      * between the inviscid and viscous parts. In case the maximum    *
!      * yplus value must be monitored (only possible for RANS), this   *
!      * value is also computed.                                        *
!      *                                                                *
!      ******************************************************************
!
!ie,je,ke
! myID for debug
!
!      Subroutine arguments
!
!s       integer(kind=intType),intent(in) :: iiBeg,iiEnd,jjBeg,jjEnd
!s
!s       real(kind=realType), dimension(3), intent(inout) :: cFpAdj, cFvAdj
!s       real(kind=realType), dimension(3), intent(inout) :: cMpAdj, cMvAdj
!s
!s       !add to allow for scaling!
!s       real(kind=realType), dimension(3), intent(out) :: cFpAdjOut, cFvAdjOut
!s       real(kind=realType), dimension(3), intent(out) :: cMpAdjOut, cMvAdjOut
!s       real(kind=realType), dimension(3), intent(in) :: refPoint
!s       real(kind=realType), intent(out), intent(in) :: yplusMax
!s       integer(kind=intType), intent(in) :: mm, level, nn
!s       real(kind=realType), dimension(2,1:je,1:ke,3), intent(in) :: siAdj
!s       real(kind=realType), dimension(1:ie,2,1:ke,3), intent(in) :: sjAdj
!s       real(kind=realType), dimension(1:ie,1:je,2,3), intent(in) :: skAdj
!s       real(kind=realType), dimension(iiBeg:iiEnd,jjBeg:jjEnd,3), intent(in) :: normAdj
!s       ! Note that the range of xAdj should correspond to 0:ie,0:je,0:ke
!s       real(kind=realType), dimension(0:ie,0:je,0:ke,3), intent(in) :: xAdj
! Note that the range of xAdj should correspond to 0:ie,0:je,0:ke
!
!      Local variables.
!
!v       real(kind=realType) :: tauxx, tauyy, tauzz
!v       real(kind=realType) :: tauxy, tauxz, tauyz
!       real(kind=realType), dimension(iiBeg:iiEnd,jjBeg:jjEnd,3) :: xx
!v       real(kind=realType), dimension(:,:),   pointer :: rlv2, rlv1
!v       real(kind=realType), dimension(:,:),   pointer :: dd2Wall
!v       real(kind=realType), dimension(:,:,:), pointer :: ss, xx
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
!forceLoc = zero
! Compute the scaling factor to create the correct dimensional
! force in newton. As the coordinates are already in meters,
! this scaling factor is pRef.
  scaledim = pref
! Compute the local forces. Take the scaling factor into
! account to obtain the forces in SI-units, i.e. Newton.
! Loop over the boundary subfaces of this block.
!print *,'bctype',BCType(mm),mm
  IF (bctype(mm) .EQ. eulerwall .OR. bctype(mm) .EQ. nswalladiabatic &
&      .OR. bctype(mm) .EQ. nswallisothermal) THEN
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,:,kl)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,1:,kl); rlv1 => rlv(1:,1:,ke)
!v               endif
! Set a bunch of pointers depending on the face id to make
! a generic treatment possible. The routine setBcPointers
! is not used, because quite a few other ones are needed.
    SELECT CASE  (bcfaceid(mm)) 
    CASE (imin) 
!                print *,'imin'
      pp2(:, :) = padj(2, iibeg:iiend, jjbeg:jjend)
      pp1(:, :) = padj(1, iibeg:iiend, jjbeg:jjend)
      ss(:, :, :) = siadj(1, iibeg:iiend, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(1,iiBeg-1:iiEnd,jjBeg-1:jjEnd,:)
!               print *,'shape',shape(xx),shape(xAdj)
!               xx(:,:,:)   = xAdj(1,:,:,:)
      fact = -one
      CALL PUSHINTEGER4(1)
    CASE (imax) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(2,:,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(2,1:,1:); rlv1 => rlv(1,1:,1:)
!v               endif
!===========================================================
!                print *,'imax'
      pp2(:, :) = padj(il, iibeg:iiend, jjbeg:jjend)
      pp1(:, :) = padj(ie, iibeg:iiend, jjbeg:jjend)
      ss(:, :, :) = siadj(2, iibeg:iiend, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(il,iiBeg-1:iiEnd,jjBeg-1:jjEnd,:)
!               xx(:,:,:)   = xAdj(il,:,:,:)
      fact = one
      CALL PUSHINTEGER4(2)
    CASE (jmin) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(il,:,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(il,1:,1:); rlv1 => rlv(ie,1:,1:)
!v               endif
!===========================================================
!                print *,'jmin'
      pp2(:, :) = padj(iibeg:iiend, 2, jjbeg:jjend)
      pp1(:, :) = padj(iibeg:iiend, 1, jjbeg:jjend)
!!$               pp4  => p(1:,2,1:);      pp3  => p(1:,1,1:)
!!$               ss2   => sj(:,1,:,:); xx2   => x(:,1,:,:)
!!$         
!rho2 => w(1:,2,1:,irho); rho1 => w(1:,1,1:,irho)
!ss   => sj(:,1,:,:);     xx   => x(:,1,:,:)
!fact = -one
      ss(:, :, :) = sjadj(iibeg:iiend, 1, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,1,jjBeg-1:jjEnd,:)
!               print *,'indices',iibeg,i2beg,iiend,i2end
!               print *,'shape',shape(xx),shape(xAdj(iiBeg-1:iiEnd,1,jjBeg-1:jjEnd,:))
!xx(:,:,:)   = xAdj(:,1,:,:)
!               print *,'xxjmin',xx(1,1,1),xadj(1,1,1,1),xx(1,2,1),xadj(1,1,2,1)
!               print *,'shape2',shape(xx),shape(xAdj(iiBeg-1:iiEnd,1,jjBeg-1:jjEnd,:))
!               stop
!               print *,'xx',xx(1,1,1),xx2(1,1,1),xAdj(0,0,0,1),x(0,0,0,1),x(1,1,1,1)
!               stop
      fact = -one
      CALL PUSHINTEGER4(3)
    CASE (jmax) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,2,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,2,1:); rlv1 => rlv(1:,1,1:)
!v               endif
!===========================================================
!                print *,'jmax'
      pp2(:, :) = padj(iibeg:iiend, jl, jjbeg:jjend)
      pp1(:, :) = padj(iibeg:iiend, je, jjbeg:jjend)
!!$               pp4  => p(1:,jl,1:);      pp3  => p(1:,je,1:)
!!$               ss2   => sj(:,jl,:,:);     xx2   => x(:,jl,:,:)
      ss(:, :, :) = sjadj(iibeg:iiend, 2, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,jl,jjBeg-1:jjEnd,:)
!               xx(:,:,:)   = xAdj(:,jl,:,:)
      fact = one
      CALL PUSHINTEGER4(4)
    CASE (kmin) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,jl,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,jl,1:); rlv1 => rlv(1:,je,1:)
!v               endif
!===========================================================
!                print *,'kmin'
      pp2(:, :) = padj(iibeg:iiend, jjbeg:jjend, 2)
      pp1(:, :) = padj(iibeg:iiend, jjbeg:jjend, 1)
!!$               pp4  => p(1:,1:,2);      pp3  => p(1:,1:,1)
!!$               ss2   => sk(:,:,1,:);     xx2   => x(:,:,1,:)
      ss(:, :, :) = skadj(iibeg:iiend, jjbeg:jjend, 1, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,jjBeg-1:jjEnd,1,:)
!               xx(:,:,:)   = xAdj(:,:,1,:)
      fact = -one
      CALL PUSHINTEGER4(5)
    CASE (kmax) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,:,2)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,1:,2); rlv1 => rlv(1:,1:,1)
!v               endif
!===========================================================
!                print *,'kmax'
      pp2(:, :) = padj(iibeg:iiend, jjbeg:jjend, kl)
      pp1(:, :) = padj(iibeg:iiend, jjbeg:jjend, ke)
!!$               pp4  => p(1:,1:,kl);      pp3  => p(1:,1:,ke)
!!$               ss2   => sk(:,:,kl,:);     xx2   => x(:,:,kl,:)
      ss(:, :, :) = skadj(iibeg:iiend, jjbeg:jjend, 2, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,jjBeg-1:jjEnd,kl,:)
!               xx(:,:,:)   = xAdj(:,:,kl,:)
      fact = one
      CALL PUSHINTEGER4(6)
    CASE DEFAULT
      CALL PUSHINTEGER4(0)
    END SELECT
! Loop over the quadrilateral faces of the subface. 
! Note that +1 to Beg, and -1 to End to have ranges for the owned cell.
!print *,'indicies',i2beg,i2end,iiend,j2beg,j2end!,shape(xx)
    DO j=j2beg,j2end
      DO i=i2beg,i2end
        CALL PUSHREAL8(pp)
!print *,'indices',i,j,xx(i,j,1),xAdj(i-1,1,j-1,1),x(i-1,1,j-1,1)
! Compute the pressure in the center of the boundary
! face, which is an average between pp2 and pp1. The
! value of pp is multiplied by 1/4 (the factor to
! scatter to its 4 nodes, by scaleDim (to obtain the
! correct dimensional value) and by fact (which takes
! the possibility of inward or outward pointing normal
! into account).
        pp = half*(pp2(i, j)+pp1(i, j))
        pp = fourth*fact*scaledim*pp
        CALL PUSHINTEGER4(jj)
! Compute the corresponding force.
!print *,'forces',fx,fy,fz,pp
! Distribute the force to the 4 nodes of the quad.
! Note that the averaging factor 1/4 has already been
! taken into account in pp.
        jj = ii + (j-j2beg)*(i2end-i2beg+2) + i - i2beg + 1
        CALL PUSHINTEGER4(jj)
!print *,'jj1',jj
        jj = jj + 1
        CALL PUSHINTEGER4(jj)
!print *,'jj2',jj
        jj = jj + i2end - i2beg + 1
        CALL PUSHINTEGER4(jj)
!print *,'jj3',jj
        jj = jj + 1
!print *,'jj4',jj
      END DO
    END DO
    pp1b(iibeg:iiend, jjbeg:jjend) = 0.0
    pp2b(iibeg:iiend, jjbeg:jjend) = 0.0
    ssb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
    DO j=j2end,j2beg,-1
      DO i=i2end,i2beg,-1
        fzb = forcelocb(3, jj)
        fyb = forcelocb(2, jj)
        fxb = forcelocb(1, jj)
        CALL POPINTEGER4(jj)
        fzb = fzb + forcelocb(3, jj)
        fyb = fyb + forcelocb(2, jj)
        fxb = fxb + forcelocb(1, jj)
        CALL POPINTEGER4(jj)
        fzb = fzb + forcelocb(3, jj)
        fyb = fyb + forcelocb(2, jj)
        fxb = fxb + forcelocb(1, jj)
        CALL POPINTEGER4(jj)
        fzb = fzb + forcelocb(3, jj)
        fyb = fyb + forcelocb(2, jj)
        fxb = fxb + forcelocb(1, jj)
        CALL POPINTEGER4(jj)
        ppb = ss(i, j, 1)*fxb + ss(i, j, 2)*fyb + ss(i, j, 3)*fzb
        ssb(i, j, 3) = ssb(i, j, 3) + pp*fzb
        ssb(i, j, 2) = ssb(i, j, 2) + pp*fyb
        ssb(i, j, 1) = ssb(i, j, 1) + pp*fxb
        ppb = fourth*fact*scaledim*ppb
        CALL POPREAL8(pp)
        pp2b(i, j) = pp2b(i, j) + half*ppb
        pp1b(i, j) = pp1b(i, j) + half*ppb
      END DO
    END DO
    CALL POPINTEGER4(branch)
    IF (branch .LT. 4) THEN
      IF (branch .LT. 2) THEN
        IF (branch .LT. 1) THEN
          padjb(0:ib, 0:jb, 0:kb) = 0.0
          skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
          sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
          siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
        ELSE
          siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
          siadjb(1, iibeg:iiend, jjbeg:jjend, :) = ssb(:, :, :)
          padjb(0:ib, 0:jb, 0:kb) = 0.0
          padjb(1, iibeg:iiend, jjbeg:jjend) = pp1b(:, :)
          padjb(2, iibeg:iiend, jjbeg:jjend) = padjb(2, iibeg:iiend, &
&            jjbeg:jjend) + pp2b(:, :)
          skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
          sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        END IF
      ELSE IF (branch .LT. 3) THEN
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
        siadjb(2, iibeg:iiend, jjbeg:jjend, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(ie, iibeg:iiend, jjbeg:jjend) = pp1b(:, :)
        padjb(il, iibeg:iiend, jjbeg:jjend) = padjb(il, iibeg:iiend, &
&          jjbeg:jjend) + pp2b(:, :)
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
      ELSE
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        sjadjb(iibeg:iiend, 1, jjbeg:jjend, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(iibeg:iiend, 1, jjbeg:jjend) = pp1b(:, :)
        padjb(iibeg:iiend, 2, jjbeg:jjend) = padjb(iibeg:iiend, 2, jjbeg&
&          :jjend) + pp2b(:, :)
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      END IF
    ELSE IF (branch .LT. 6) THEN
      IF (branch .LT. 5) THEN
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        sjadjb(iibeg:iiend, 2, jjbeg:jjend, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(iibeg:iiend, je, jjbeg:jjend) = pp1b(:, :)
        padjb(iibeg:iiend, jl, jjbeg:jjend) = padjb(iibeg:iiend, jl, &
&          jjbeg:jjend) + pp2b(:, :)
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      ELSE
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        skadjb(iibeg:iiend, jjbeg:jjend, 1, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(iibeg:iiend, jjbeg:jjend, 1) = pp1b(:, :)
        padjb(iibeg:iiend, jjbeg:jjend, 2) = padjb(iibeg:iiend, jjbeg:&
&          jjend, 2) + pp2b(:, :)
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      END IF
    ELSE
      skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
      skadjb(iibeg:iiend, jjbeg:jjend, 2, :) = ssb(:, :, :)
      padjb(0:ib, 0:jb, 0:kb) = 0.0
      padjb(iibeg:iiend, jjbeg:jjend, ke) = pp1b(:, :)
      padjb(iibeg:iiend, jjbeg:jjend, kl) = padjb(iibeg:iiend, jjbeg:&
&        jjend, kl) + pp2b(:, :)
      sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
      siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
    END IF
  ELSE
    padjb(0:ib, 0:jb, 0:kb) = 0.0
    skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
    sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
    siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
  END IF
END SUBROUTINE FORCESCOUPLINGADJ_B
