!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of bceulerwallforcecouplingadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: padj wadj skadj
!                sjadj siadj normadj
!   of linear combination of output variables: padj skadj sjadj
!                siadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          bcEulerWallAdj.f90                              *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi,C.A.(Sandy) Mader                  *
!      * Starting date: 03-21-2006                                      *
!      * Last modified: 06-09-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE BCEULERWALLFORCECOUPLINGADJ_B(secondhalo, wadj, wadjb, padj, &
&  padjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, normadj, normadjb&
&  , mm, iibeg, iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end)
  USE bctypes
  USE blockpointers, ONLY : il, jl, kl, bcdata, bcfaceid, s, &
&  addgridvelocities, nbocos, bctype, ib, jb, kb
  USE constants
  USE flowvarrefstate
  USE inputdiscretization
  USE iteration
  IMPLICIT NONE
  INTEGER(KIND=INTTYPE), INTENT(IN) :: i2beg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: i2end
  INTEGER(KIND=INTTYPE), INTENT(IN) :: iibeg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: iiend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: j2beg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: j2end
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jjbeg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jjend
  INTEGER(KIND=INTTYPE) :: mm
  REAL(KIND=REALTYPE) :: normadj(iibeg:iiend, jjbeg:jjend, 3), normadjb(&
&  iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(0:ib, 0:jb, 0:kb)
  LOGICAL, INTENT(IN) :: secondhalo
  REAL(KIND=REALTYPE) :: siadj(0:2, iibeg:iiend, jjbeg:jjend, 3), siadjb&
&  (0:2, iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: sjadj(iibeg:iiend, 0:2, jjbeg:jjend, 3), sjadjb&
&  (iibeg:iiend, 0:2, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: skadj(iibeg:iiend, jjbeg:jjend, 0:2, 3), skadjb&
&  (iibeg:iiend, jjbeg:jjend, 0:2, 3)
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb, nw), INTENT(IN) :: &
&  wadj
  REAL(KIND=REALTYPE) :: wadjb(0:ib, 0:jb, 0:kb, nw)
  REAL(KIND=REALTYPE) :: dpj, dpjb, dpk, dpkb, qj, qjb, qk, qkb, ri, rib&
&  , rj, rjb, rk, rkb, vn
  INTEGER(KIND=INTTYPE) :: icbeg, icend, jcbeg, jcend
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, kk, l
  INTEGER(KIND=INTTYPE) :: jm1, jp1, km1, kp1
  INTEGER(KIND=INTTYPE) :: jjm1, jjp1, kkm1, kkp1
  INTEGER :: branch, max1, max2
  REAL(KIND=REALTYPE) :: padj2(iibeg:iiend, jjbeg:jjend), padj2b(iibeg:&
&  iiend, jjbeg:jjend), padj3(iibeg:iiend, jjbeg:jjend), padj3b(iibeg:&
&  iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: revadj1(iibeg:iiend, jjbeg:jjend), revadj2(&
&  iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: rface
  REAL(KIND=REALTYPE) :: revadj(0:ib, 0:jb, 0:kb), rlvadj(0:ib, 0:jb, 0:&
&  kb)
  REAL(KIND=REALTYPE) :: rlvadj1(iibeg:iiend, jjbeg:jjend), rlvadj2(&
&  iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: rxj, rxjb, rxk, rxkb, ryj, ryjb, ryk, rykb, rzj&
&  , rzjb, rzk, rzkb
  REAL(KIND=REALTYPE) :: sixa, sixab, siya, siyab, siza, sizab, sjxa, &
&  sjxab, sjya, sjyab, sjza, sjzab
  REAL(KIND=REALTYPE) :: a1, b1, skxa, skxab, skya, skyab, skza, skzab
  REAL(KIND=REALTYPE) :: ssi(iibeg:iiend, jjbeg:jjend, 3), ssib(iibeg:&
&  iiend, jjbeg:jjend, 3), ssj(iibeg:iiend, jjbeg:jjend, 3), ssjb(iibeg:&
&  iiend, jjbeg:jjend, 3), ssk(iibeg:iiend, jjbeg:jjend, 3), sskb(iibeg:&
&  iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: factk, gm53, ovgm1, temp0, temp0b, temp1, &
&  temp1b, ux, uxb, uy, uyb, uz, uzb
  REAL(KIND=REALTYPE) :: padj0(iibeg:iiend, jjbeg:jjend), padj0b(iibeg:&
&  iiend, jjbeg:jjend), padj1(iibeg:iiend, jjbeg:jjend), padj1b(iibeg:&
&  iiend, jjbeg:jjend), temp, temp2b, tempb
  REAL(KIND=REALTYPE) :: tmp, tmp0, wadj0(iibeg:iiend, jjbeg:jjend, nw)&
&  , wadj0b(iibeg:iiend, jjbeg:jjend, nw), wadj1(iibeg:iiend, jjbeg:&
&  jjend, nw), wadj1b(iibeg:iiend, jjbeg:jjend, nw)
  REAL(KIND=REALTYPE) :: wadj2(iibeg:iiend, jjbeg:jjend, nw), wadj2b(&
&  iibeg:iiend, jjbeg:jjend, nw), wadj3(iibeg:iiend, jjbeg:jjend, nw), &
&  wadj3b(iibeg:iiend, jjbeg:jjend, nw)
  INTEGER(KIND=INTTYPE) :: walltreatment
  INTRINSIC MAX, MIN
  icbeg = iibeg
  icend = iiend
  jcbeg = jjbeg
  jcend = jjend
! Check for Euler wall boundary condition.
  IF (bctype(mm) .EQ. eulerwall) THEN
! Set the pointers for the unit normal and the normal
! velocity to make the code more readable.
!!?norm  => BCData(nn)%norm
!!?rface => BCData(nn)%rface
!print *,'extracting states'
!Copy the states and other parameters to subfaces
    CALL EXTRACTBCSTATESFORCECOUPLINGADJ(mm, wadj, padj, wadj0, wadj1, &
&                                   wadj2, wadj3, padj0, padj1, padj2, &
&                                   padj3, rlvadj, revadj, rlvadj1, &
&                                   rlvadj2, revadj1, revadj2, iibeg, &
&                                   jjbeg, iiend, jjend, secondhalo)
!print *,'states extracted'
! Some initialization
    ssi = zero
    ssj = zero
    ssk = zero
! Easier storage of variables involving gamma.
    ovgm1 = one/(gammainf-one)
    gm53 = gammainf - five*third
    factk = -(ovgm1*gm53)
! Determine the boundary condition treatment and compute the
! undivided pressure gradient accordingly. This gradient is
! temporarily stored in the halo pressure.
!print *,'selecting case',wallBCTreatment
    SELECT CASE  (wallbctreatment) 
    CASE (constantpressure) 
!print *,'constant pressure'
! Constant pressure. Set the gradient to zero.
      DO j=jcbeg,jcend
        DO i=icbeg,icend
          CALL PUSHINTEGER4(ii)
          ii = i
          CALL PUSHINTEGER4(jj)
          jj = j
          padj1(ii, jj) = zero
        END DO
      END DO
      CALL PUSHINTEGER4(1)
    CASE (linextrapolpressure) 
!===============================================================
!print *,'linear extrapolation'
! Linear extrapolation. Compute the gradient.
      DO j=jcbeg,jcend
        DO i=icbeg,icend
          CALL PUSHINTEGER4(ii)
          ii = i
          CALL PUSHINTEGER4(jj)
          jj = j
          padj1(ii, jj) = padj3(ii, jj) - padj2(ii, jj)
        END DO
      END DO
      CALL PUSHINTEGER4(2)
    CASE (normalmomentum) 
!if( addGridVelocities ) ss => s(:,:,kl,:)
!!$
!!$
!!$              !===============================================================
!!$
!!$           case (quadExtrapolPressure)
!!$
!!$              ! Quadratic extrapolation. Does not fit within the
!!$              ! current data structures.
!!$              
!!$              !call terminate("bcEulerWallAdj", "Quadratic extrapolation does not fit within the current data structure for th
!e boundary stuff")
!!$              call terminate("bcEulerWallAdj", "Quadratic")
!!$              !print *, "bcEulerWallAdj: quadExtrapolPressure: STOP"
!!$
!===============================================================
!print *,' normal momentum'
!call terminate("bcEulerWallAdj", &
!               "No normal momentum in this version.")
!print *, "bcEulerWallAdj: STOP"
! Pressure gradient is computed using the normal momentum
! equation. First set a couple of additional variables for
! the normals, depending on the block face. Note that the
! construction 1: should not be used in these pointers,
! because element 0 is needed. Consequently there will be
! an offset of 1 for these normals. This is commented in
! the code. For moving faces also the grid velocity of
! the 1st cell center from the wall is needed.
      SELECT CASE  (bcfaceid(mm)) 
      CASE (imin) 
        IF (secondhalo) THEN
          ssi(:, :, :) = siadj(1, :, :, :)
          ssj(:, :, :) = sjadj(2, :, :, :)
          ssk(:, :, :) = skadj(2, :, :, :)
          CALL PUSHINTEGER4(1)
        ELSE
          ssi(:, :, :) = siadj(0, :, :, :)
          ssj(:, :, :) = sjadj(1, :, :, :)
          ssk(:, :, :) = skadj(1, :, :, :)
          CALL PUSHINTEGER4(2)
        END IF
      CASE (imax) 
!if( addGridVelocities ) ss => s(2,:,:,:)
!===========================================================
        IF (secondhalo) THEN
          ssi(:, :, :) = siadj(ib-2, :, :, :)
          ssj(:, :, :) = sjadj(ib-2, :, :, :)
          ssk(:, :, :) = skadj(ib-2, :, :, :)
          CALL PUSHINTEGER4(3)
        ELSE
          ssi(:, :, :) = siadj(ib-1, :, :, :)
          ssj(:, :, :) = sjadj(ib-1, :, :, :)
          ssk(:, :, :) = skadj(ib-1, :, :, :)
          CALL PUSHINTEGER4(4)
        END IF
      CASE (jmin) 
!if( addGridVelocities ) ss => s(il,:,:,:)
!===========================================================
        IF (secondhalo) THEN
          ssi(:, :, :) = sjadj(:, 1, :, :)
          ssj(:, :, :) = siadj(:, 2, :, :)
          ssk(:, :, :) = skadj(:, 2, :, :)
          CALL PUSHINTEGER4(5)
        ELSE
          ssi(:, :, :) = sjadj(:, 0, :, :)
          ssj(:, :, :) = siadj(:, 1, :, :)
          ssk(:, :, :) = skadj(:, 1, :, :)
          CALL PUSHINTEGER4(6)
        END IF
      CASE (jmax) 
!if( addGridVelocities ) ss => s(:,2,:,:)
!===========================================================
        IF (secondhalo) THEN
          ssi(:, :, :) = sjadj(:, jb-2, :, :)
          ssj(:, :, :) = siadj(:, jb-2, :, :)
          ssk(:, :, :) = skadj(:, jb-2, :, :)
          CALL PUSHINTEGER4(7)
        ELSE
          ssi(:, :, :) = sjadj(:, jb-1, :, :)
          ssj(:, :, :) = siadj(:, jb-1, :, :)
          ssk(:, :, :) = skadj(:, jb-1, :, :)
          CALL PUSHINTEGER4(8)
        END IF
      CASE (kmin) 
!if( addGridVelocities ) ss => s(:,jl,:,:)
!===========================================================
        IF (secondhalo) THEN
          ssi(:, :, :) = skadj(:, :, 1, :)
          ssj(:, :, :) = siadj(:, :, 2, :)
          ssk(:, :, :) = sjadj(:, :, 2, :)
          CALL PUSHINTEGER4(9)
        ELSE
          ssi(:, :, :) = skadj(:, :, 0, :)
          ssj(:, :, :) = siadj(:, :, 1, :)
          ssk(:, :, :) = sjadj(:, :, 1, :)
          CALL PUSHINTEGER4(10)
        END IF
      CASE (kmax) 
!if( addGridVelocities ) ss => s(:,:,2,:)
!===========================================================
        IF (secondhalo) THEN
          ssi(:, :, :) = skadj(:, :, kb-2, :)
          ssj(:, :, :) = siadj(:, :, kb-2, :)
          ssk(:, :, :) = sjadj(:, :, kb-2, :)
          CALL PUSHINTEGER4(11)
        ELSE
          ssi(:, :, :) = skadj(:, :, kb-1, :)
          ssj(:, :, :) = siadj(:, :, kb-1, :)
          ssk(:, :, :) = sjadj(:, :, kb-1, :)
          CALL PUSHINTEGER4(12)
        END IF
      CASE DEFAULT
        CALL PUSHINTEGER4(0)
      END SELECT
! Loop over the faces of the generic subface.
! Note that now the running indices are j and k. This is
! done, because the generic i-direction is assumed to
! be the normal direction.
      DO k=jcbeg,jcend
! Store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        IF (bcdata(mm)%jcbeg .LT. km1) THEN
          km1 = km1
          CALL PUSHINTEGER4(1)
        ELSE
          km1 = bcdata(mm)%jcbeg
          CALL PUSHINTEGER4(0)
        END IF
        kp1 = k + 1
        IF (bcdata(mm)%jcend .GT. kp1) THEN
          kp1 = kp1
          CALL PUSHINTEGER4(1)
        ELSE
          kp1 = bcdata(mm)%jcend
          CALL PUSHINTEGER4(0)
        END IF
        IF (1 .LT. kp1 - km1) THEN
          max1 = kp1 - km1
          CALL PUSHINTEGER4(1)
        ELSE
          max1 = 1
          CALL PUSHINTEGER4(0)
        END IF
        CALL PUSHREAL8(b1)
! Compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
        CALL PUSHINTEGER4(kk)
! Compute the offset indices.
        kk = k
        CALL PUSHINTEGER4(kkm1)
        kkm1 = km1
        CALL PUSHINTEGER4(kkp1)
        kkp1 = kp1
! The generic j-direction.
        DO j=icbeg,icend
! The indices j+1 and j-1. Make sure that they
! do not exceed the range of the arrays.
          jm1 = j - 1
          IF (bcdata(mm)%icbeg .LT. jm1) THEN
            jm1 = jm1
            CALL PUSHINTEGER4(1)
          ELSE
            jm1 = bcdata(mm)%icbeg
            CALL PUSHINTEGER4(0)
          END IF
          jp1 = j + 1
          IF (bcdata(mm)%icend .GT. jp1) THEN
            jp1 = jp1
            CALL PUSHINTEGER4(1)
          ELSE
            jp1 = bcdata(mm)%icend
            CALL PUSHINTEGER4(0)
          END IF
          IF (1 .LT. jp1 - jm1) THEN
            max2 = jp1 - jm1
            CALL PUSHINTEGER4(1)
          ELSE
            max2 = 1
            CALL PUSHINTEGER4(0)
          END IF
          CALL PUSHREAL8(a1)
! Compute the scaling factor for the central
! difference in the j-direction.
          a1 = one/max2
          CALL PUSHINTEGER4(jj)
          jj = j
          CALL PUSHINTEGER4(jjm1)
          jjm1 = jm1
          CALL PUSHINTEGER4(jjp1)
          jjp1 = jp1
          CALL PUSHREAL8(sixa)
! Compute (twice) the average normal in the generic i,
! j and k-direction. Note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). However due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
          sixa = two*ssi(jj, kk, 1)
          CALL PUSHREAL8(siya)
          siya = two*ssi(jj, kk, 2)
          CALL PUSHREAL8(siza)
          siza = two*ssi(jj, kk, 3)
          CALL PUSHREAL8(sjxa)
! it was ssj(j,k,1) + ssj(j+1,k,1)
          sjxa = ssj(jj-1, kk, 1) + ssj(jj, kk, 1)
          CALL PUSHREAL8(sjya)
! it was ssj(j,k,2) + ssj(j+1,k,2)
          sjya = ssj(jj-1, kk, 2) + ssj(jj, kk, 2)
          CALL PUSHREAL8(sjza)
! it was ssj(j,k,3) + ssj(j+1,k,3)
          sjza = ssj(jj-1, kk, 3) + ssj(jj, kk, 3)
          CALL PUSHREAL8(skxa)
! it was ssk(j,k,1) + ssk(j,k+1,1)
          skxa = ssk(jj, kk-1, 1) + ssk(jj, kk, 1)
          CALL PUSHREAL8(skya)
! it was ssk(j,k,2) + ssk(j,k+1,2)
          skya = ssk(jj, kk-1, 2) + ssk(jj, kk, 2)
          CALL PUSHREAL8(skza)
! it was ssk(j,k,3) + ssk(j,k+1,3)
          skza = ssk(jj, kk-1, 3) + ssk(jj, kk, 3)
          CALL PUSHREAL8(rxj)
! Compute the difference of the normal vector and
! pressure in j and k-direction. As the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
          rxj = a1*(normadj(jjp1, kk, 1)-normadj(jjm1, kk, 1))
          CALL PUSHREAL8(ryj)
          ryj = a1*(normadj(jjp1, kk, 2)-normadj(jjm1, kk, 2))
          CALL PUSHREAL8(rzj)
          rzj = a1*(normadj(jjp1, kk, 3)-normadj(jjm1, kk, 3))
          CALL PUSHREAL8(dpj)
!print *, "jjp1,jjm1, kk =", jjp1,jjm1, kk
          dpj = a1*(padj2(jjp1, kk)-padj2(jjm1, kk))
          CALL PUSHREAL8(rxk)
          rxk = b1*(normadj(jj, kkp1, 1)-normadj(jj, kkm1, 1))
          CALL PUSHREAL8(ryk)
          ryk = b1*(normadj(jj, kkp1, 2)-normadj(jj, kkm1, 2))
          CALL PUSHREAL8(rzk)
          rzk = b1*(normadj(jj, kkp1, 3)-normadj(jj, kkm1, 3))
          CALL PUSHREAL8(dpk)
!print *, "jj, kkp1, kkm1 =", jj, kkp1, kkm1
          dpk = b1*(padj2(jj, kkp1)-padj2(jj, kkm1))
          CALL PUSHREAL8(ri)
! Compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
          ri = normadj(jj, kk, 1)*sixa + normadj(jj, kk, 2)*siya + &
&            normadj(jj, kk, 3)*siza
          CALL PUSHREAL8(rj)
          rj = normadj(jj, kk, 1)*sjxa + normadj(jj, kk, 2)*sjya + &
&            normadj(jj, kk, 3)*sjza
          CALL PUSHREAL8(rk)
          rk = normadj(jj, kk, 1)*skxa + normadj(jj, kk, 2)*skya + &
&            normadj(jj, kk, 3)*skza
          CALL PUSHREAL8(ux)
! Store the velocity components in ux, uy and uz and
! subtract the mesh velocity if the face is moving.
          ux = wadj2(jj, kk, ivx)
          CALL PUSHREAL8(uy)
          uy = wadj2(jj, kk, ivy)
          CALL PUSHREAL8(uz)
          uz = wadj2(jj, kk, ivz)
          CALL PUSHREAL8(qj)
!if( addGridVelocities ) then
!   ux = ux - ss(j,k,1)
!   uy = uy - ss(j,k,2)
!   uz = uz - ss(j,k,3)
!endif
! Compute the velocity components in j and
! k-direction.
          qj = ux*sjxa + uy*sjya + uz*sjza
          CALL PUSHREAL8(qk)
          qk = ux*skxa + uy*skya + uz*skza
! Compute the pressure gradient, which is stored
! in pAdj1. I'm not entirely sure whether this
! formulation is correct for moving meshes. It could
! be that an additional term is needed there.
          padj1(jj, kk) = ((qj*(ux*rxj+uy*ryj+uz*rzj)+qk*(ux*rxk+uy*ryk+&
&            uz*rzk))*wadj2(jj, kk, irho)-rj*dpj-rk*dpk)/ri
        END DO
      END DO
      CALL PUSHINTEGER4(3)
    CASE DEFAULT
      CALL PUSHINTEGER4(0)
    END SELECT
! Determine the state in the halo cell. Again loop over
! the cell range for this subface.
!print *,' determining halo cells'
    DO j=jcbeg,jcend
      DO i=icbeg,icend
        CALL PUSHINTEGER4(ii)
        ii = i
        CALL PUSHINTEGER4(jj)
        jj = j
        rface = bcdata(mm)%rface(i, j)
        IF (zero .LT. padj2(ii, jj) - padj1(ii, jj)) THEN
          padj1(ii, jj) = padj2(ii, jj) - padj1(ii, jj)
          CALL PUSHINTEGER4(1)
        ELSE
          padj1(ii, jj) = zero
          CALL PUSHINTEGER4(0)
        END IF
!!$
!!$!                 vn = two*(BCData(nn)%rface(i,j)              &
!!$!                      - wAdj2(ii,jj,ivx)*normAdj(nn,ii,jj,1) &
!!$!                      - wAdj2(ii,jj,ivy)*normAdj(nn,ii,jj,2) &
!!$ !                     - wAdj2(ii,jj,ivz)*normAdj(nn,ii,jj,3))
!!$
        vn = two*(rface-wadj2(ii, jj, ivx)*normadj(ii, jj, 1)-wadj2(ii, &
&          jj, ivy)*normadj(ii, jj, 2)-wadj2(ii, jj, ivz)*normadj(ii, jj&
&          , 3))
        wadj1(ii, jj, irho) = wadj2(ii, jj, irho)
        wadj1(ii, jj, ivx) = wadj2(ii, jj, ivx) + vn*normadj(ii, jj, 1)
        wadj1(ii, jj, ivy) = wadj2(ii, jj, ivy) + vn*normadj(ii, jj, 2)
        wadj1(ii, jj, ivz) = wadj2(ii, jj, ivz) + vn*normadj(ii, jj, 3)
! Just copy the turbulent variables.
        DO l=nt1mg,nt2mg
          wadj1(ii, jj, l) = wadj2(ii, jj, l)
        END DO
!
!        Input the viscous effects - rlv1(), and rev1()
!
! Compute the total energy.
        tmp = ovgm1*padj1(ii, jj) + half*wadj1(ii, jj, irho)*(wadj1(ii, &
&          jj, ivx)**2+wadj1(ii, jj, ivy)**2+wadj1(ii, jj, ivz)**2)
        wadj1(ii, jj, irhoe) = tmp
        IF (kpresent) THEN
          tmp0 = wadj1(ii, jj, irhoe) - factk*wadj1(ii, jj, irho)*wadj1(&
&            ii, jj, itu1)
          wadj1(ii, jj, irhoe) = tmp0
          CALL PUSHINTEGER4(2)
        ELSE
          CALL PUSHINTEGER4(1)
        END IF
      END DO
    END DO
! Extrapolate the state vectors in case a second halo
! is needed.
    IF (secondhalo) THEN
      CALL PUSHREAL8ARRAY(padj0, (iiend-iibeg+1)*(jjend-jjbeg+1))
      CALL PUSHREAL8ARRAY(wadj0, (iiend-iibeg+1)*(jjend-jjbeg+1)*nw)
      CALL EXTRAPOLATE2NDHALOFORCECOUPLINGADJ(mm, iibeg, iiend, jjbeg, &
&                                        jjend, wadj0, wadj1, wadj2, &
&                                        padj0, padj1, padj2)
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    wadjb(:, :, :, :) = 0.0
    CALL REPLACEBCSTATESFORCECOUPLINGADJ_B(mm, wadj0, wadj0b, wadj1, &
&                                     wadj1b, wadj2, wadj3, padj0, &
&                                     padj0b, padj1, padj1b, padj2, &
&                                     padj3, rlvadj1, rlvadj2, revadj1, &
&                                     revadj2, wadj, wadjb, padj, padjb&
&                                     , rlvadj, revadj, iibeg, jjbeg, &
&                                     iiend, jjend, secondhalo)
    CALL POPINTEGER4(branch)
    IF (branch .LT. 1) THEN
      padj2b(iibeg:iiend, jjbeg:jjend) = 0.0
    ELSE
      CALL POPREAL8ARRAY(wadj0, (iiend-iibeg+1)*(jjend-jjbeg+1)*nw)
      CALL POPREAL8ARRAY(padj0, (iiend-iibeg+1)*(jjend-jjbeg+1))
      wadj1b(:, :, :) = 0.0
      wadj0b(:, :, :) = 0.0
      CALL EXTRAPOLATE2NDHALOFORCECOUPLINGADJ_B(mm, iibeg, iiend, jjbeg&
&                                          , jjend, wadj0, wadj0b, wadj1&
&                                          , wadj1b, wadj2, wadj2b, &
&                                          padj0, padj0b, padj1, padj1b&
&                                          , padj2, padj2b)
    END IF
    DO j=jcend,jcbeg,-1
      DO i=icend,icbeg,-1
        CALL POPINTEGER4(branch)
        l = nt1mg - 1
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(jj)
        CALL POPINTEGER4(ii)
      END DO
    END DO
    CALL POPINTEGER4(branch)
    IF (branch .LT. 2) THEN
      IF (branch .LT. 1) THEN
        normadjb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
        padj3b(iibeg:iiend, jjbeg:jjend) = 0.0
        wadj2b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
      ELSE
        DO j=jcend,jcbeg,-1
          DO i=icend,icbeg,-1
            padj1b(ii, jj) = 0.0
            CALL POPINTEGER4(jj)
            CALL POPINTEGER4(ii)
          END DO
        END DO
        normadjb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
        padj3b(iibeg:iiend, jjbeg:jjend) = 0.0
        wadj2b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
      END IF
    ELSE IF (branch .LT. 3) THEN
      padj3b(iibeg:iiend, jjbeg:jjend) = 0.0
      DO j=jcend,jcbeg,-1
        DO i=icend,icbeg,-1
          padj3b(ii, jj) = padj3b(ii, jj) + padj1b(ii, jj)
          padj2b(ii, jj) = padj2b(ii, jj) - padj1b(ii, jj)
          padj1b(ii, jj) = 0.0
          CALL POPINTEGER4(jj)
          CALL POPINTEGER4(ii)
        END DO
      END DO
      normadjb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      wadj2b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
    ELSE
      normadjb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      wadj2b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
      ssib(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      ssjb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      sskb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      DO k=jcend,jcbeg,-1
        DO j=icend,icbeg,-1
          temp2b = padj1b(jj, kk)/ri
          tempb = wadj2(jj, kk, irho)*temp2b
          temp1 = ux*rxj + uy*ryj + uz*rzj
          temp1b = qj*tempb
          temp0 = ux*rxk + uy*ryk + uz*rzk
          temp0b = qk*tempb
          temp = qj*temp1 + qk*temp0
          qjb = temp1*tempb
          qkb = temp0*tempb
          uxb = sjxa*qjb + skxa*qkb + rxk*temp0b + rxj*temp1b
          rxjb = ux*temp1b
          uyb = sjya*qjb + skya*qkb + ryk*temp0b + ryj*temp1b
          ryjb = uy*temp1b
          uzb = sjza*qjb + skza*qkb + rzk*temp0b + rzj*temp1b
          rzjb = uz*temp1b
          rxkb = ux*temp0b
          rykb = uy*temp0b
          rzkb = uz*temp0b
          wadj2b(jj, kk, irho) = wadj2b(jj, kk, irho) + temp*temp2b
          rjb = -(dpj*temp2b)
          dpjb = -(rj*temp2b)
          rkb = -(dpk*temp2b)
          dpkb = -(rk*temp2b)
          rib = -((temp*wadj2(jj, kk, irho)-rj*dpj-rk*dpk)*temp2b/ri)
          padj1b(jj, kk) = 0.0
          CALL POPREAL8(qk)
          skxab = normadj(jj, kk, 1)*rkb + ux*qkb
          skyab = normadj(jj, kk, 2)*rkb + uy*qkb
          skzab = normadj(jj, kk, 3)*rkb + uz*qkb
          CALL POPREAL8(qj)
          sjxab = normadj(jj, kk, 1)*rjb + ux*qjb
          sjyab = normadj(jj, kk, 2)*rjb + uy*qjb
          sjzab = normadj(jj, kk, 3)*rjb + uz*qjb
          CALL POPREAL8(uz)
          wadj2b(jj, kk, ivz) = wadj2b(jj, kk, ivz) + uzb
          CALL POPREAL8(uy)
          wadj2b(jj, kk, ivy) = wadj2b(jj, kk, ivy) + uyb
          CALL POPREAL8(ux)
          wadj2b(jj, kk, ivx) = wadj2b(jj, kk, ivx) + uxb
          CALL POPREAL8(rk)
          normadjb(jj, kk, 1) = normadjb(jj, kk, 1) + skxa*rkb
          normadjb(jj, kk, 2) = normadjb(jj, kk, 2) + skya*rkb
          normadjb(jj, kk, 3) = normadjb(jj, kk, 3) + skza*rkb
          CALL POPREAL8(rj)
          normadjb(jj, kk, 1) = normadjb(jj, kk, 1) + sjxa*rjb
          normadjb(jj, kk, 2) = normadjb(jj, kk, 2) + sjya*rjb
          normadjb(jj, kk, 3) = normadjb(jj, kk, 3) + sjza*rjb
          CALL POPREAL8(ri)
          normadjb(jj, kk, 1) = normadjb(jj, kk, 1) + sixa*rib
          sixab = normadj(jj, kk, 1)*rib
          normadjb(jj, kk, 2) = normadjb(jj, kk, 2) + siya*rib
          siyab = normadj(jj, kk, 2)*rib
          normadjb(jj, kk, 3) = normadjb(jj, kk, 3) + siza*rib
          sizab = normadj(jj, kk, 3)*rib
          CALL POPREAL8(dpk)
          padj2b(jj, kkp1) = padj2b(jj, kkp1) + b1*dpkb
          padj2b(jj, kkm1) = padj2b(jj, kkm1) - b1*dpkb
          CALL POPREAL8(rzk)
          normadjb(jj, kkp1, 3) = normadjb(jj, kkp1, 3) + b1*rzkb
          normadjb(jj, kkm1, 3) = normadjb(jj, kkm1, 3) - b1*rzkb
          CALL POPREAL8(ryk)
          normadjb(jj, kkp1, 2) = normadjb(jj, kkp1, 2) + b1*rykb
          normadjb(jj, kkm1, 2) = normadjb(jj, kkm1, 2) - b1*rykb
          CALL POPREAL8(rxk)
          normadjb(jj, kkp1, 1) = normadjb(jj, kkp1, 1) + b1*rxkb
          normadjb(jj, kkm1, 1) = normadjb(jj, kkm1, 1) - b1*rxkb
          CALL POPREAL8(dpj)
          padj2b(jjp1, kk) = padj2b(jjp1, kk) + a1*dpjb
          padj2b(jjm1, kk) = padj2b(jjm1, kk) - a1*dpjb
          CALL POPREAL8(rzj)
          normadjb(jjp1, kk, 3) = normadjb(jjp1, kk, 3) + a1*rzjb
          normadjb(jjm1, kk, 3) = normadjb(jjm1, kk, 3) - a1*rzjb
          CALL POPREAL8(ryj)
          normadjb(jjp1, kk, 2) = normadjb(jjp1, kk, 2) + a1*ryjb
          normadjb(jjm1, kk, 2) = normadjb(jjm1, kk, 2) - a1*ryjb
          CALL POPREAL8(rxj)
          normadjb(jjp1, kk, 1) = normadjb(jjp1, kk, 1) + a1*rxjb
          normadjb(jjm1, kk, 1) = normadjb(jjm1, kk, 1) - a1*rxjb
          CALL POPREAL8(skza)
          sskb(jj, kk-1, 3) = sskb(jj, kk-1, 3) + skzab
          sskb(jj, kk, 3) = sskb(jj, kk, 3) + skzab
          CALL POPREAL8(skya)
          sskb(jj, kk-1, 2) = sskb(jj, kk-1, 2) + skyab
          sskb(jj, kk, 2) = sskb(jj, kk, 2) + skyab
          CALL POPREAL8(skxa)
          sskb(jj, kk-1, 1) = sskb(jj, kk-1, 1) + skxab
          sskb(jj, kk, 1) = sskb(jj, kk, 1) + skxab
          CALL POPREAL8(sjza)
          ssjb(jj-1, kk, 3) = ssjb(jj-1, kk, 3) + sjzab
          ssjb(jj, kk, 3) = ssjb(jj, kk, 3) + sjzab
          CALL POPREAL8(sjya)
          ssjb(jj-1, kk, 2) = ssjb(jj-1, kk, 2) + sjyab
          ssjb(jj, kk, 2) = ssjb(jj, kk, 2) + sjyab
          CALL POPREAL8(sjxa)
          ssjb(jj-1, kk, 1) = ssjb(jj-1, kk, 1) + sjxab
          ssjb(jj, kk, 1) = ssjb(jj, kk, 1) + sjxab
          CALL POPREAL8(siza)
          ssib(jj, kk, 3) = ssib(jj, kk, 3) + two*sizab
          CALL POPREAL8(siya)
          ssib(jj, kk, 2) = ssib(jj, kk, 2) + two*siyab
          CALL POPREAL8(sixa)
          ssib(jj, kk, 1) = ssib(jj, kk, 1) + two*sixab
          CALL POPINTEGER4(jjp1)
          CALL POPINTEGER4(jjm1)
          CALL POPINTEGER4(jj)
          CALL POPREAL8(a1)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
        END DO
        CALL POPINTEGER4(kkp1)
        CALL POPINTEGER4(kkm1)
        CALL POPINTEGER4(kk)
        CALL POPREAL8(b1)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
      END DO
      CALL POPINTEGER4(branch)
      IF (branch .LT. 7) THEN
        IF (branch .LT. 4) THEN
          IF (branch .LT. 2) THEN
            IF (.NOT.branch .LT. 1) THEN
              skadjb(2, :, :, :) = skadjb(2, :, :, :) + sskb(:, :, :)
              sjadjb(2, :, :, :) = sjadjb(2, :, :, :) + ssjb(:, :, :)
              siadjb(1, :, :, :) = siadjb(1, :, :, :) + ssib(:, :, :)
            END IF
          ELSE IF (branch .LT. 3) THEN
            skadjb(1, :, :, :) = skadjb(1, :, :, :) + sskb(:, :, :)
            sjadjb(1, :, :, :) = sjadjb(1, :, :, :) + ssjb(:, :, :)
            siadjb(0, :, :, :) = siadjb(0, :, :, :) + ssib(:, :, :)
          ELSE
            skadjb(ib-2, :, :, :) = skadjb(ib-2, :, :, :) + sskb(:, :, :&
&              )
            sjadjb(ib-2, :, :, :) = sjadjb(ib-2, :, :, :) + ssjb(:, :, :&
&              )
            siadjb(ib-2, :, :, :) = siadjb(ib-2, :, :, :) + ssib(:, :, :&
&              )
          END IF
        ELSE IF (branch .LT. 6) THEN
          IF (branch .LT. 5) THEN
            skadjb(ib-1, :, :, :) = skadjb(ib-1, :, :, :) + sskb(:, :, :&
&              )
            sjadjb(ib-1, :, :, :) = sjadjb(ib-1, :, :, :) + ssjb(:, :, :&
&              )
            siadjb(ib-1, :, :, :) = siadjb(ib-1, :, :, :) + ssib(:, :, :&
&              )
          ELSE
            skadjb(:, 2, :, :) = skadjb(:, 2, :, :) + sskb(:, :, :)
            siadjb(:, 2, :, :) = siadjb(:, 2, :, :) + ssjb(:, :, :)
            sjadjb(:, 1, :, :) = sjadjb(:, 1, :, :) + ssib(:, :, :)
          END IF
        ELSE
          skadjb(:, 1, :, :) = skadjb(:, 1, :, :) + sskb(:, :, :)
          siadjb(:, 1, :, :) = siadjb(:, 1, :, :) + ssjb(:, :, :)
          sjadjb(:, 0, :, :) = sjadjb(:, 0, :, :) + ssib(:, :, :)
        END IF
      ELSE IF (branch .LT. 10) THEN
        IF (branch .LT. 9) THEN
          IF (branch .LT. 8) THEN
            skadjb(:, jb-2, :, :) = skadjb(:, jb-2, :, :) + sskb(:, :, :&
&              )
            siadjb(:, jb-2, :, :) = siadjb(:, jb-2, :, :) + ssjb(:, :, :&
&              )
            sjadjb(:, jb-2, :, :) = sjadjb(:, jb-2, :, :) + ssib(:, :, :&
&              )
          ELSE
            skadjb(:, jb-1, :, :) = skadjb(:, jb-1, :, :) + sskb(:, :, :&
&              )
            siadjb(:, jb-1, :, :) = siadjb(:, jb-1, :, :) + ssjb(:, :, :&
&              )
            sjadjb(:, jb-1, :, :) = sjadjb(:, jb-1, :, :) + ssib(:, :, :&
&              )
          END IF
        ELSE
          sjadjb(:, :, 2, :) = sjadjb(:, :, 2, :) + sskb(:, :, :)
          siadjb(:, :, 2, :) = siadjb(:, :, 2, :) + ssjb(:, :, :)
          skadjb(:, :, 1, :) = skadjb(:, :, 1, :) + ssib(:, :, :)
        END IF
      ELSE IF (branch .LT. 12) THEN
        IF (branch .LT. 11) THEN
          sjadjb(:, :, 1, :) = sjadjb(:, :, 1, :) + sskb(:, :, :)
          siadjb(:, :, 1, :) = siadjb(:, :, 1, :) + ssjb(:, :, :)
          skadjb(:, :, 0, :) = skadjb(:, :, 0, :) + ssib(:, :, :)
        ELSE
          sjadjb(:, :, kb-2, :) = sjadjb(:, :, kb-2, :) + sskb(:, :, :)
          siadjb(:, :, kb-2, :) = siadjb(:, :, kb-2, :) + ssjb(:, :, :)
          skadjb(:, :, kb-2, :) = skadjb(:, :, kb-2, :) + ssib(:, :, :)
        END IF
      ELSE
        sjadjb(:, :, kb-1, :) = sjadjb(:, :, kb-1, :) + sskb(:, :, :)
        siadjb(:, :, kb-1, :) = siadjb(:, :, kb-1, :) + ssjb(:, :, :)
        skadjb(:, :, kb-1, :) = skadjb(:, :, kb-1, :) + ssib(:, :, :)
      END IF
      padj3b(iibeg:iiend, jjbeg:jjend) = 0.0
    END IF
    wadj3b(:, :, :) = 0.0
    wadj1b(:, :, :) = 0.0
    wadj0b(:, :, :) = 0.0
    wadjb(:, :, :, :) = 0.0
    CALL EXTRACTBCSTATESFORCECOUPLINGADJ_B(mm, wadj, wadjb, padj, padjb&
&                                     , wadj0, wadj0b, wadj1, wadj1b, &
&                                     wadj2, wadj2b, wadj3, wadj3b, &
&                                     padj0, padj0b, padj1, padj1b, &
&                                     padj2, padj2b, padj3, padj3b, &
&                                     rlvadj, revadj, rlvadj1, rlvadj2, &
&                                     revadj1, revadj2, iibeg, jjbeg, &
&                                     iiend, jjend, secondhalo)
  ELSE
    wadjb(0:ib, 0:jb, 0:kb, 1:nw) = 0.0
    normadjb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
  END IF
END SUBROUTINE BCEULERWALLFORCECOUPLINGADJ_B
