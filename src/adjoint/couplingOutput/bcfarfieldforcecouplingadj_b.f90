!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of bcfarfieldforcecouplingadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: winfadj padj pinfcorradj
!                wadj normadj
!   of linear combination of output variables: padj wadj normadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          bcFarfieldForcesAdj.f90                         *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi,C.A.(Sandy) Mader                  *
!      * Starting date: 03-21-2006                                      *
!      * Last modified: 06-09-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE BCFARFIELDFORCECOUPLINGADJ_B(secondhalo, winfadj, winfadjb, &
&  pinfcorradj, pinfcorradjb, wadj, wadjb, padj, padjb, siadj, sjadj, &
&  skadj, normadj, normadjb, mm, iibeg, iiend, jjbeg, jjend, i2beg, &
&  i2end, j2beg, j2end)
  USE bctypes
  USE blockpointers, ONLY : bcdata, nbocos, bctype, bcfaceid, gamma, &
&  il, jl, kl, w, p, ib, jb, kb
  USE constants
  USE flowvarrefstate
  USE iteration
  IMPLICIT NONE
  INTEGER(KIND=INTTYPE), INTENT(IN) :: i2beg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: i2end
  INTEGER(KIND=INTTYPE), INTENT(IN) :: iibeg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: iiend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: j2beg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: j2end
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jjbeg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jjend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: mm
  REAL(KIND=REALTYPE) :: normadj(iibeg:iiend, jjbeg:jjend, 3), normadjb(&
&  iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(0:ib, 0:jb, 0:kb)
  REAL(KIND=REALTYPE) :: pinfcorradj, pinfcorradjb
  LOGICAL, INTENT(IN) :: secondhalo
  REAL(KIND=REALTYPE) :: siadj(2, iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: sjadj(iibeg:iiend, 2, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: skadj(iibeg:iiend, jjbeg:jjend, 2, 3)
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb, nw), INTENT(IN) :: &
&  wadj
  REAL(KIND=REALTYPE) :: wadjb(0:ib, 0:jb, 0:kb, nw)
  REAL(KIND=REALTYPE), DIMENSION(nw), INTENT(IN) :: winfadj
  REAL(KIND=REALTYPE) :: winfadjb(nw)
  INTEGER :: branch
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, l
  REAL(KIND=REALTYPE) :: nnx, nny, nnz
  REAL(KIND=REALTYPE) :: ac1, ac2, factk, gm1, gm53, ovgm1
  REAL(KIND=REALTYPE) :: padj0(iibeg:iiend, jjbeg:jjend), padj0b(iibeg:&
&  iiend, jjbeg:jjend), padj1(iibeg:iiend, jjbeg:jjend), padj1b(iibeg:&
&  iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: padj2(iibeg:iiend, jjbeg:jjend), padj2b(iibeg:&
&  iiend, jjbeg:jjend), padj3(iibeg:iiend, jjbeg:jjend), padj3b(iibeg:&
&  iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: revadj1(iibeg:iiend, jjbeg:jjend), revadj2(&
&  iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: rface
  REAL(KIND=REALTYPE) :: revadj(0:ib, 0:jb, 0:kb), rlvadj(0:ib, 0:jb, 0:&
&  kb)
  REAL(KIND=REALTYPE) :: rlvadj1(iibeg:iiend, jjbeg:jjend), rlvadj2(&
&  iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: c0, c0b, qn0, r0, r0b, s0, s0b, tempb, u0, u0b&
&  , v0, v0b, vn0, w0, w0b
  REAL(KIND=REALTYPE) :: tmp, tmp0, wadj0(iibeg:iiend, jjbeg:jjend, nw)&
&  , wadj0b(iibeg:iiend, jjbeg:jjend, nw), wadj1(iibeg:iiend, jjbeg:&
&  jjend, nw), wadj1b(iibeg:iiend, jjbeg:jjend, nw)
  REAL(KIND=REALTYPE) :: wadj2(iibeg:iiend, jjbeg:jjend, nw), wadj2b(&
&  iibeg:iiend, jjbeg:jjend, nw), wadj3(iibeg:iiend, jjbeg:jjend, nw), &
&  wadj3b(iibeg:iiend, jjbeg:jjend, nw)
  REAL(KIND=REALTYPE) :: ce, qne, re, ue, ve, we
  REAL(KIND=REALTYPE) :: cc, cf, qnf, qq, sf, uf, vf, wf
  INTRINSIC SQRT
!
!      ******************************************************************
!      *                                                                *
!      * bcFarfieldAdj applies the farfield boundary condition to       *
!      * subface nn of the block to which the pointers in blockPointers *
!      * currently point.                                               *
!      *                                                                *
!      ******************************************************************
!
! irho,ivx,ivy,ivz
! gammaInf, wInf, pInfCorr
!
!      Subroutine arguments.
!
!  integer(kind=intType) :: nn ! it's not needed anymore w/ normAdj
!       integer(kind=intType), intent(in) :: icBeg, icEnd, jcBeg, jcEnd
!       integer(kind=intType), intent(in) :: iOffset, jOffset
!       integer(kind=intType) :: iCell, jCell, kCell
! notice the range of y dim is set 1:2 which corresponds to 1/jl
! notice the range of z dim is set 1:2 which corresponds to 1/kl
!!$   integer(kind=intType) ::isbeg,jsbeg,ksbeg,isend,jsend,ksend
!!$  integer(kind=intType) ::ibbeg,jbbeg,kbbeg,ibend,jbend,kbend
!!$  integer(kind=intType) ::icbeg,jcbeg,kcbeg,icend,jcend,kcend
!!$  integer(kind=intType) :: iOffset, jOffset, kOffset
!real(kind=realType), dimension(-2:2,-2:2,-2:2)::rlvAdj, revAdj
!real(kind=realType), dimension(-2:2,-2:2)::rlvAdj1, rlvAdj2
!real(kind=realType), dimension(-2:2,-2:2)::revAdj1, revAdj2
!  real(kind=realType), dimension(-2:2,-2:2,-2:2,3), intent(in) :: &
!       siAdj, sjAdj, skAdj
!  real(kind=realType), dimension(nBocos,-2:2,-2:2,3), intent(in) :: normAdj
!  real(kind=realType), dimension(-2:2,-2:2,-2:2,nw), &
!       intent(in) :: wAdj
!  real(kind=realType), dimension(-2:2,-2:2,-2:2),intent(in) :: pAdj
!real(kind=realType), dimension(-2:2,-2:2,nw) :: wAdj0, wAdj1
!real(kind=realType), dimension(-2:2,-2:2,nw) :: wAdj2, wAdj3
!real(kind=realType), dimension(-2:2,-2:2)    :: pAdj0, pAdj1
!real(kind=realType), dimension(-2:2,-2:2)    :: pAdj2, pAdj3
!real(kind=realType), dimension(nBocos,-2:2,-2:2,3), intent(in) :: normAdj
!
!      Local variables.
!
!
!      Interfaces
!
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Some constants needed to compute the riemann invariants.
  gm1 = gammainf - one
  ovgm1 = one/gm1
  gm53 = gammainf - five*third
  factk = -(ovgm1*gm53)
! Compute the three velocity components, the speed of sound and
! the entropy of the free stream.
  r0 = one/winfadj(irho)
  u0 = winfadj(ivx)
  v0 = winfadj(ivy)
  w0 = winfadj(ivz)
  c0 = SQRT(gammainf*pinfcorradj*r0)
  s0 = winfadj(irho)**gammainf/pinfcorradj
! Check for farfield boundary conditions.
  IF (bctype(mm) .EQ. farfield) THEN
    CALL EXTRACTBCSTATESFORCECOUPLINGADJ(mm, wadj, padj, wadj0, wadj1, &
&                                   wadj2, wadj3, padj0, padj1, padj2, &
&                                   padj3, rlvadj, revadj, rlvadj1, &
&                                   rlvadj2, revadj1, revadj2, iibeg, &
&                                   jjbeg, iiend, jjend, secondhalo)
! Loop over the generic subface to set the state in the
! halo cells.
!     do j=jcBeg, jcEnd
!        do i=icBeg, icEnd
    DO j=jjbeg,jjend
      DO i=iibeg,iiend
        ii = i
        jj = j
        rface = bcdata(mm)%rface(i, j)
! Store the three components of the unit normal a
! bit easier.
        nnx = normadj(ii, jj, 1)
        nny = normadj(ii, jj, 2)
        nnz = normadj(ii, jj, 3)
! Compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
        qn0 = u0*nnx + v0*nny + w0*nnz
        vn0 = qn0 - rface
! Compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
        re = one/wadj2(ii, jj, irho)
        ue = wadj2(ii, jj, ivx)
        ve = wadj2(ii, jj, ivy)
        we = wadj2(ii, jj, ivz)
        qne = ue*nnx + ve*nny + we*nnz
        ce = SQRT(gammainf*padj2(ii, jj)*re)
! Compute the new values of the riemann invariants in
! the halo cell. Either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
        IF (vn0 .GT. -c0) THEN
! Outflow or subsonic inflow.
          ac1 = qne + two*ovgm1*ce
          CALL PUSHINTEGER4(0)
        ELSE
! Supersonic inflow.
          ac1 = qn0 + two*ovgm1*c0
          CALL PUSHINTEGER4(1)
        END IF
        IF (vn0 .GT. c0) THEN
! Supersonic outflow.
          ac2 = qne - two*ovgm1*ce
          CALL PUSHINTEGER4(0)
        ELSE
! Inflow or subsonic outflow.
          ac2 = qn0 - two*ovgm1*c0
          CALL PUSHINTEGER4(1)
        END IF
        qnf = half*(ac1+ac2)
        cf = fourth*(ac1-ac2)*gm1
        IF (vn0 .GT. zero) THEN
! Outflow.
          uf = ue + (qnf-qne)*nnx
          vf = ve + (qnf-qne)*nny
          wf = we + (qnf-qne)*nnz
          sf = wadj2(ii, jj, irho)**gammainf/padj2(ii, jj)
          DO l=nt1mg,nt2mg
            wadj1(ii, jj, l) = wadj2(ii, jj, l)
          END DO
          CALL PUSHINTEGER4(0)
        ELSE
! Inflow
          uf = u0 + (qnf-qn0)*nnx
          vf = v0 + (qnf-qn0)*nny
          wf = w0 + (qnf-qn0)*nnz
          sf = s0
          DO l=nt1mg,nt2mg
            wadj1(ii, jj, l) = winfadj(l)
          END DO
          CALL PUSHINTEGER4(1)
        END IF
! Compute the density, velocity and pressure in the
! halo cell.
        cc = cf*cf/gammainf
        wadj1(ii, jj, irho) = (sf*cc)**ovgm1
        wadj1(ii, jj, ivx) = uf
        wadj1(ii, jj, ivy) = vf
        wadj1(ii, jj, ivz) = wf
        padj1(ii, jj) = wadj1(ii, jj, irho)*cc
! Compute the total energy.
        tmp = ovgm1*padj1(ii, jj) + half*wadj1(ii, jj, irho)*(uf**2+vf**&
&          2+wf**2)
        wadj1(ii, jj, irhoe) = tmp
        IF (kpresent) THEN
          tmp0 = wadj1(ii, jj, irhoe) - factk*wadj1(ii, jj, irho)*wadj1(&
&            ii, jj, itu1)
          wadj1(ii, jj, irhoe) = tmp0
          CALL PUSHINTEGER4(2)
        ELSE
          CALL PUSHINTEGER4(1)
        END IF
      END DO
    END DO
!
!        Input the viscous effects - rlv1(), and rev1()
!
! Extrapolate the state vectors in case a second halo
! is needed.
    IF (secondhalo) THEN
      CALL PUSHREAL8ARRAY(padj0, (iiend-iibeg+1)*(jjend-jjbeg+1))
      CALL PUSHREAL8ARRAY(wadj0, (iiend-iibeg+1)*(jjend-jjbeg+1)*nw)
      CALL EXTRAPOLATE2NDHALOFORCECOUPLINGADJ(mm, iibeg, iiend, jjbeg, &
&                                        jjend, wadj0, wadj1, wadj2, &
&                                        padj0, padj1, padj2)
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    CALL REPLACEBCSTATESFORCECOUPLINGADJ_B(mm, wadj0, wadj0b, wadj1, &
&                                     wadj1b, wadj2, wadj3, padj0, &
&                                     padj0b, padj1, padj1b, padj2, &
&                                     padj3, rlvadj1, rlvadj2, revadj1, &
&                                     revadj2, wadj, wadjb, padj, padjb&
&                                     , rlvadj, revadj, iibeg, jjbeg, &
&                                     iiend, jjend, secondhalo)
    CALL POPINTEGER4(branch)
    IF (branch .LT. 1) THEN
      padj2b(iibeg:iiend, jjbeg:jjend) = 0.0
      wadj2b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
    ELSE
      CALL POPREAL8ARRAY(wadj0, (iiend-iibeg+1)*(jjend-jjbeg+1)*nw)
      CALL POPREAL8ARRAY(padj0, (iiend-iibeg+1)*(jjend-jjbeg+1))
      CALL EXTRAPOLATE2NDHALOFORCECOUPLINGADJ_B(mm, iibeg, iiend, jjbeg&
&                                          , jjend, wadj0, wadj0b, wadj1&
&                                          , wadj1b, wadj2, wadj2b, &
&                                          padj0, padj0b, padj1, padj1b&
&                                          , padj2, padj2b)
    END IF
    winfadjb(1:nw) = 0.0
    v0b = 0.0
    s0b = 0.0
    c0b = 0.0
    w0b = 0.0
    u0b = 0.0
    DO j=jjend,jjbeg,-1
      DO i=iiend,iibeg,-1
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          l = nt1mg - 1
        ELSE
          l = nt1mg - 1
        END IF
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        winfadjb(1:nw) = 0.0
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        wadjb(0:ib, 0:jb, 0:kb, 1:nw) = 0.0
        normadjb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
        padj0b(iibeg:iiend, jjbeg:jjend) = 0.0
        padj1b(iibeg:iiend, jjbeg:jjend) = 0.0
        padj2b(iibeg:iiend, jjbeg:jjend) = 0.0
        wadj0b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
        wadj1b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
        wadj2b(iibeg:iiend, jjbeg:jjend, 1:nw) = 0.0
      END DO
    END DO
    padj3b(:, :) = 0.0
    wadj3b(:, :, :) = 0.0
    CALL EXTRACTBCSTATESFORCECOUPLINGADJ_B(mm, wadj, wadjb, padj, padjb&
&                                     , wadj0, wadj0b, wadj1, wadj1b, &
&                                     wadj2, wadj2b, wadj3, wadj3b, &
&                                     padj0, padj0b, padj1, padj1b, &
&                                     padj2, padj2b, padj3, padj3b, &
&                                     rlvadj, revadj, rlvadj1, rlvadj2, &
&                                     revadj1, revadj2, iibeg, jjbeg, &
&                                     iiend, jjend, secondhalo)
  ELSE
    winfadjb(1:nw) = 0.0
    v0b = 0.0
    s0b = 0.0
    c0b = 0.0
    w0b = 0.0
    u0b = 0.0
  END IF
  IF (.NOT.(s0b .EQ. 0.0 .OR. winfadj(irho) .LE. 0.0 .AND. (gammainf &
&      .EQ. 0.0 .OR. gammainf .NE. INT(gammainf)))) winfadjb(irho) = &
&      winfadjb(irho) + gammainf*winfadj(irho)**(gammainf-1)*s0b/&
&      pinfcorradj
  tempb = gammainf*c0b/(2.0*SQRT(gammainf*(pinfcorradj*r0)))
  pinfcorradjb = r0*tempb - winfadj(irho)**gammainf*s0b/pinfcorradj**2
  r0b = pinfcorradj*tempb
  winfadjb(ivz) = winfadjb(ivz) + w0b
  winfadjb(ivy) = winfadjb(ivy) + v0b
  winfadjb(ivx) = winfadjb(ivx) + u0b
  winfadjb(irho) = winfadjb(irho) - one*r0b/winfadj(irho)**2
END SUBROUTINE BCFARFIELDFORCECOUPLINGADJ_B
