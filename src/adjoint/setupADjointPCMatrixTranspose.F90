!
!     ******************************************************************
!     *                                                                *
!     * File:          setupADjointPCMatrixTranspose.F90               *
!     * Author:        C.A.(Sandy) Mader                               *
!     * Starting date: 05-07-2010                                      *
!     * Last modified: 05-14-2010                                      *
!     *                                                                *
!     ******************************************************************
!
      subroutine setupADjointPCMatrixTranspose(level)
!
!     ******************************************************************
!     *                                                                *
!     * Compute the transpose of the matrix dRdWPre of the discrete    *
!     * ADjoint problem for                                            *
!     * subsequent use by the solveADjointPETSc subroutine. The entries*
!     * in dRdwPre are obtained using the automatically differentiated *
!     * routines generated by Tapenade, with a modification to the     *
!     * dissipation parameters to improve the conditioning of the      *
!     * matrix.                                                        *
!     *                                                                *
!     * The ordering of the unknowns in the ADjoint matrix used here   *
!     * is based on the global node numbering and is consistent with   *
!     * the ordering used in the vector for the ADjoint problem        *
!     * assembled in setupADjointRHS.                                  *
!     *                                                                *
!     ******************************************************************
!
      use ADjointPETSc
      use ADjointVars ! nCellsGlobal, nCellsLocal, nOffsetLocal
      use blockPointers       ! i/j/kl/b/e, i/j/k/Min/MaxBoundaryStencil
      use cgnsGrid            ! cgnsDoms
      use communication       ! procHalo(currentLevel)%nProcSend
      use inputDiscretization ! spaceDiscr
      USE inputTimeSpectral   ! nTimeIntervalsSpectral
      use iteration           ! overset, currentLevel
      use flowVarRefState     ! nw
      use inputTimeSpectral   ! spaceDiscr
      use inputADjoint        !sigma
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level
!
!     Local variables.
!
      integer(kind=intType) :: discr, nHalo
      integer(kind=intType) :: iCell, jCell, kCell
      integer(kind=intType) :: mm, nn, m, n,idxstate,idxres
      integer(kind=intType) :: ii, jj, kk, i, j, k,liftIndex,l

      logical :: fineGrid, correctForK, exchangeTurb,secondhalo

      real(kind=realType), dimension(-2:2,-2:2,-2:2,nw,nTimeIntervalsSpectral) :: wAdj, wAdjB
      real(kind=realType), dimension(-3:2,-3:2,-3:2,3,nTimeIntervalsSpectral)  :: xAdj, xAdjB

      real(kind=realType), dimension(nw,nTimeIntervalsSpectral) :: dwAdj, dwAdjB

      REAL(KIND=REALTYPE) :: machadj, machcoefadj, uinfadj, pinfcorradj
      REAL(KIND=REALTYPE) :: machadjb, machcoefadjb,machgridadj, machgridadjb
      REAL(KIND=REALTYPE) :: prefadj, rhorefadj
      REAL(KIND=REALTYPE) :: pinfdimadj, rhoinfdimadj
      REAL(KIND=REALTYPE) :: rhoinfadj, pinfadj
      REAL(KIND=REALTYPE) :: murefadj, timerefadj
      REAL(KIND=REALTYPE) :: alphaadj, betaadj
      REAL(KIND=REALTYPE) :: alphaadjb, betaadjb
      REAL(KIND=REALTYPE), DIMENSION(3) :: rotcenteradj
      REAL(KIND=REALTYPE), DIMENSION(3) :: rotrateadj 
      REAL(KIND=REALTYPE) :: rotcenteradjb(3), rotrateadjb(3)
      REAL(KIND=REALTYPE) :: pointrefadj(3), pointrefadjb(3), rotpointadj(3)&
           &  , rotpointadjb(3)
      REAL(KIND=REALTYPE) :: xblockcorneradj(2, 2, 2, 3,nTimeIntervalsSpectral), xblockcorneradjb(2&
           &  , 2, 2, 3,nTimeIntervalsSpectral)

      integer(kind=intType), dimension(0:nProc-1) :: offsetRecv

      real(kind=realType), dimension(2) :: time
      real(kind=realType)               :: timeAdjLocal, timeAdj

      ! dR/dw stencil

      real(kind=realType), dimension(nw,nw,nTimeIntervalsSpectral) :: Aad, Bad, BBad, &
                   Cad, CCad, Dad, DDad, Ead, EEad, Fad, FFad, Gad, GGad

      ! idxmgb - global block row index
      ! idxngb - global block column index

      integer(kind=intType) :: idxmgb, idxngb,ierr, sps,sps2

      ! idxmgb - array of global row indices
      ! idxngb - array of global column indices

      integer(kind=intType), dimension(nw) :: idxmg, idxng

      !Reference values of the dissipation coeff for the preconditioner
      real(kind=realType) :: vis2_ref, vis4_ref

!!$      integer :: unitdRdwpre = 8,ierror,nnn!,idxstate, idxres,nnn
!!$      character(len = 35)::outfile,testfile
!!$      write(testfile,100) myid!12
!!$100   format (i5)  
!!$      testfile=adjustl(testfile)
!!$      write(outfile,101) trim(testfile)!testfile
!!$101   format("/scratch/mader/AD1dRdWprefile2",a,".out")
!!$      unitdrdwpre = 8+myID
!!$
!!$      
!!$      open (UNIT=unitdRdwpre,File=outfile,status='replace',action='write',iostat=ierror)
!!$      if(ierror /= 0)                        &
!!$           call terminate("verifydRdwpreFile", &
!!$           "Something wrong when &
!!$           &calling open")
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
#ifndef USE_NO_PETSC

      ! Set the grid level of the current MG cycle, the value of the
      ! discretization and the logical correctForK.

      currentLevel = level
      !discr        = spaceDiscr
      fineGrid     = .true.

      ! Determine whether or not the total energy must be corrected
      ! for the presence of the turbulent kinetic energy and whether
      ! or not turbulence variables should be exchanged.

      if( kPresent ) then
         if((currentLevel <= groundLevel) .or. turbCoupled) then
            correctForK = .true.
         else
            correctForK = .false.
         endif
      else
         correctForK = .false.
      endif

      exchangeTurb = .false.

      ! Set the value of secondHalo, depending on the situation.
      ! In the full MG (currentLevel < groundLevel) the second halo is
      ! always set; otherwise only on the finest mesh in the current mg
      ! cycle.

      if(currentLevel <= groundLevel) then
         secondHalo = .true.
      else
         secondHalo = .false.
      endif

!
!     ******************************************************************
!     *                                                                *
!     * Exchange halo data to make sure it is up-to-date.              *
!     * (originally called inside "rungeKuttaSmoother" subroutine).    *
!     *                                                                *
!     ******************************************************************
!
      ! Exchange the pressure if the pressure must be exchanged early.
      ! Only the first halo's are needed, thus whalo1 is called.
      ! Only on the fine grid.
      
      if(exchangePressureEarly .and. currentLevel <= groundLevel) &
           call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
           .false., .false.)
      
      ! Apply all boundary conditions to all blocks on this level.
     
      call applyAllBC(secondHalo)
      
      ! Exchange the solution. Either whalo1 or whalo2
      ! must be called.
      
      if( secondHalo ) then
         call whalo2(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      else
         call whalo1(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      endif

      ! Reset the values of rkStage and currentLevel, such that
      ! they correspond to a new iteration.

      rkStage = 0
      currentLevel = groundLevel
 
!
!     ******************************************************************
!     *                                                                *
!     * Compute the ADjoint matrix dR/dW using Tapenade's reverse mode *
!     * of Automatic Differentiation.  NOTE: This is the reason I have *
!     * been writing the word "ADjoint" with A and D capitalized. A    *
!     * simple play with letter so that:                               *
!     *                                                                *
!     * ADjoint = Automatically Differentiated adjoint                 *
!     *                                                                *
!     ******************************************************************
!
      ! Send some feedback to screen.

      if( PETScRank==0 ) &
        write(*,10) "Assembling ADjoint PC Transpose matrix..."
 
      call mpi_barrier(SUmb_comm_world, ierr)
      !if( myID==0 ) call cpu_time(time(1))
      call cpu_time(time(1))

      !zero the matrix for dRdWPre Insert call
      call MatZeroEntries(dRdwPreT,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrixPC", "Error in MatZeroEntries drdwpre")

      !store the current values of vis2,vis4 and reset vis2 for preconditioner
      !method based on (Hicken and Zingg,2008) AIAA journal,vol46,no.11
      vis2_ref = vis2
      vis4_ref = vis4
      !sigma = 4 !setup as an input parameter....
      !vis2 = vis2_ref+sigma*vis4_ref
      !vis4 = 0.0
      lumpedDiss=.True.

      !print *,'Entering Domain loop'
      domainLoopAD: do nn=1,nDom
         
         ! Loop over the number of time instances for this block.

         spectralLoop: do sps=1,nTimeIntervalsSpectral
            !print *,'Setting Pointers',nn,level,sps
            call setPointersAdj(nn,level,sps)

            ! Loop over location of output (R) cell of residual
	
            do kCell = 2, kl
               do jCell = 2, jl
                  do iCell = 2, il
                     ! Copy the state w to the wAdj array in the stencil
                     call copyADjointStencil(wAdj, xAdj,xBlockCornerAdj,alphaAdj,&
           betaAdj,MachAdj,machCoefAdj,machGridAdj,iCell, jCell, kCell,&
           nn,level,sps,pointRefAdj,rotPointAdj,&
           prefAdj,rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
           rhoinfAdj, pinfAdj,rotRateAdj,rotCenterAdj,&
           murefAdj, timerefAdj,pInfCorrAdj,liftIndex)
                                          
                     Aad(:,:,:)  = zero
                     Bad(:,:,:)  = zero
  !                   BBad(:,:,:) = zero
                     Cad(:,:,:)  = zero
  !                   CCad(:,:,:) = zero
                     Dad(:,:,:)  = zero
  !                   DDad(:,:,:) = zero
                     Ead(:,:,:)  = zero
   !                  EEad(:,:,:) = zero
                     Fad(:,:,:)  = zero
  !                   FFad(:,:,:) = zero
                     Gad(:,:,:)  = zero
  !                   GGad(:,:,:) = zero
                     
                     mLoop: do m = 1, nw      ! Loop over output cell residuals (R)
                        !                   print *,'initializing variables'
                        ! Initialize the seed for the reverse mode
                        dwAdjb(:,:) = 0.
                        dwAdjb(m,sps) = 1.
                        dwAdj(:,:)  = 0.
                        wAdjb(:,:,:,:,:)  = 0.  !dR(m)/dw
                        xadjb = 0.
                        alphaadjb = 0.
                        betaadjb = 0.
                        machadjb = 0.
                        rotrateadjb(:)=0.
!                    print *,'dwadjb',dwadjb,'wadjb',wadjb(0,0,0,:)
!                    print *,'calling reverse mode'
!                   print *,'secondhalo',secondhalo

	        ! Call the reverse mode of residual computation.
                !
                !                          dR(iCell,jCell,kCell,l)
                ! wAdjb(ii,jj,kk,n) = --------------------------------
                !                     dW(iCell+ii,jCell+jj,kCell+kk,n)

                        ! Call reverse mode of residual computation
                        call COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, xblockcorneradj, &
&  xblockcorneradjb, dwadj, dwadjb, alphaadj, alphaadjb, betaadj, &
&  betaadjb, machadj, machadjb, machcoefadj, machgridadj, machgridadjb, &
&  icell, jcell, kcell, nn, level, sps, correctfork, secondhalo, prefadj&
&  , rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, rotrateadj&
&  , rotrateadjb, rotcenteradj, rotcenteradjb, pointrefadj, pointrefadjb&
&  , rotpointadj, rotpointadjb, murefadj, timerefadj, pinfcorradj, &
&  liftindex)


                        ! Store the block Jacobians (by rows).
                        
                        Aad(m,:,:)  = wAdjB( 0, 0, 0,:,:)
                        Bad(m,:,:)  = wAdjB(-1, 0, 0,:,:)
                        !BBad(m,:,:) = wAdjB(-2, 0, 0,:,:)
                        Cad(m,:,:)  = wAdjB( 1, 0, 0,:,:)
                        !CCad(m,:,:) = wAdjB( 2, 0, 0,:,:)
                        Dad(m,:,:)  = wAdjB( 0,-1, 0,:,:)
                        !DDad(m,:,:) = wAdjB( 0,-2, 0,:,:)
                        Ead(m,:,:)  = wAdjB( 0, 1, 0,:,:)
                        !EEad(m,:,:) = wAdjB( 0, 2, 0,:,:)
                        Fad(m,:,:)  = wAdjB( 0, 0,-1,:,:)
                        !FFad(m,:,:) = wAdjB( 0, 0,-2,:,:)
                        Gad(m,:,:)  = wAdjB( 0, 0, 1,:,:)
                        !GGad(m,:,:) = wAdjB( 0, 0, 2,:,:)
!!$                        
!!$                        do ii=-1,1!-2,2!-1,1!1,il-1
!!$                           do jj = -1,1!-2,2!-1,1!1,jl-1
!!$                              do kk = -1,1!-2,2!-1,1!1,kl-1
!!$                                 do l = 1,nw
!!$                                    i = iCell + ii
!!$                                    j = jCell + jj
!!$                                    k = kCell + kk
!!$                                    do sps2 = 1,nTimeIntervalsSpectral
!!$                                       if(i>=zero .and. j>=zero .and. k>=zero .and. i<=ib .and. j<=jb .and. k<=kb)then
!!$                                          !if(i>zero .and. j>zero .and. k>zero .and. i<=il .and. j<=jl .and. k<=kl)then
!!$                                          idxstate = globalCell(i,j,k)*nw+l
!!$                                          idxres   = globalCell(iCell,jCell,kCell)*nw+m
!!$                                          if( idxres-1>=0 .and. idxstate-1>=0) then
!!$                                             !if( idxres>=0 .and. idxstate>=0) then
!!$                                             if(wAdjb(ii,jj,kk,l,sps2).ne.0)then
!!$                                                call MatSetValues(drdwpret, 1, idxstate-1, 1, idxres-1,   &
!!$                                                     wAdjb(ii,jj,kk,l,sps2), ADD_VALUES, PETScIerr)
!!$                                                if( PETScIerr/=0 ) &
!!$                                                     print *,'matrix setting error'!call errAssemb("MatSetValues", "verifydrdw[re")
!!$                                             endif
!!$                                          endif
!!$                                       endif
!!$                                    enddo
!!$                                    
!!$                                 enddo !l
!!$                              enddo !kk
!!$                           enddo !jj
!!$                        enddo !ii
                        
                        
                     enddo mLoop
           !do sps2 = 1,nTimeIntervalsSpectral
              !*********************************************************
              !                                                        *
              ! Transfer the block Jacobians to the PETSc matrix.      *
              ! For the off-diagonal blocks, take into account halo    *
              ! nodes at the boundaries, if present.                   *
              !                                                        *
              ! This depends on the type of the PETsc matrix dRdWPre,  *
              ! whether is blocked or not.                             *
              !                                                        *
              !*********************************************************

              ! >>> block sparse matrix -> use MatSetValuesBlocked

              ! When using the block compressed sparse row matrix format
              ! (MATSEQBAIJ or MATMPIBAIJ), one can insert elements more
              ! efficiently using the block variant MatSetValuesBlocked.
              !
              ! MatSetValuesBlocked - Inserts or adds a block of values
              !                       into a matrix.
              ! Synopsis
              !
              ! #include "petscmat.h" 
              ! call MatSetValuesBlocked(Mat mat,                      &
              !                  PetscInt m,const PetscInt idxm[],     &
              !                  PetscInt n,const PetscInt idxn[],     &
              !                  const PetscScalar v[],InsertMode addv,&
              !                  PetscErrorCode ierr)
              !
              ! Not Collective
              !
              ! Input Parameters
              !   mat     - the matrix
              !   v       - a logically two-dimensional array of values
              !   m, idxm - the number of block rows and their global
              !             block indices
              !   n, idxn - the number of block columns and their global
              !             block indices
              !   addv    - either ADD_VALUES or INSERT_VALUES, where
              !             ADD_VALUES adds values to any existing
              !             entries, and INSERT_VALUES replaces existing
              !             entries with new values
              ! Notes
              ! The m and n count the NUMBER of blocks in the row
              !   direction and column direction, NOT the total number
              !   of rows/columns; for example, if the block size is 2
              !   and you are passing in values for rows 2,3,4,5 then m
              !   would be 2 (not 4).
              !
              ! By default the values, v, are row-oriented and unsorted.
              !   So the layout of v is the same as for MatSetValues().
              !   See MatSetOption() for other options.
              !
              ! Calls to MatSetValuesBlocked() with the INSERT_VALUES
              !   and ADD_VALUES options cannot be mixed without
              !   intervening calls to the assembly routines.
              !
              ! MatSetValuesBlocked() uses 0-based row and column
              !   numbers in Fortran as well as in C. 
              !
              ! see .../petsc/docs/manualpages/Mat/MatSetValuesBlocked.html

              if(PETScBlockMatrix) then

                ! Global matrix block row mgb function of node indices.
                !
                ! MatSetValuesBlocked() uses 0-based row and column 
                ! numbers but the global node numbering already accounts
                ! for that since it starts at node 0.

                idxmgb = globalCell(iCell,jCell,kCell)
		!print *,'globalcell',idxmgb,globalCell(iCell,jCell,kCell)
                do sps2 = 1,nTimeIntervalsSpectral
                ! >>> center block A < W(i,j,k)
                call setPointersAdj(nn,level,sps2)
                idxngb = globalCell(iCell,jCell,kCell)!idxmgb
                call setPointersAdj(nn,level,sps)
		!print *,'indicies0',idxmgb,idxngb
                call MatSetValuesBlocked(dRdWPret, 1, idxngb, 1, idxmgb, &
                                         transpose(Aad(:,:,sps2)), ADD_VALUES,PETScIerr)
                if( PETScIerr/=0 ) &
                  call errAssemb("MatSetValuesBlocked", "Aad")
                enddo
		sps2=sps
                ! >>> west block B < W(i-1,j,k)
	
                if( (iCell-1) >= 0 ) then
                  call setPointersAdj(nn,level,sps2)
                  idxngb = globalCell(iCell-1,jCell,kCell)!idxmgb
                  call setPointersAdj(nn,level,sps)
                  !idxngb = globalCell(iCell-1,jCell,kCell)
	          if (idxngb >=0 .and. idxngb.ne.-5) then
		     !print *,'indiciesi-1',idxmgb,idxngb
                     call MatSetValuesBlocked(dRdWPret, 1, idxngb, 1, idxmgb, &
                                           transpose(Bad(:,:,sps2)), ADD_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                        call errAssemb("MatSetValuesBlocked", "Bad")
		  endif
                endif

!!$

                ! >>> east block C < W(i+1,j,k)

                if( (iCell+1) <= ib ) then
                   call setPointersAdj(nn,level,sps2)
                   idxngb = globalCell(iCell+1,jCell,kCell)!idxmgb
                   call setPointersAdj(nn,level,sps)
                   !idxngb = globalCell(iCell+1,jCell,kCell)
		  !print *,'ncellsglobal',ncellsglobal,globalcell(13,5,5)
		  !stop
		  if (idxngb<nCellsGlobal*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                      call MatSetValuesBlocked(dRdWPret, 1, idxngb, 1, idxmgb, &
                                              transpose(Cad(:,:,sps2)), ADD_VALUES,PETScIerr)
                      if( PETScIerr/=0 ) &
                        call errAssemb("MatSetValuesBlocked", "Cad")
		  endif
                end if

                ! >>> far east block CC < W(i+2,j,k)

!!$

                ! >>> south block D < W(i,j-1,k)

                if( (jCell-1) >= 0 ) then
                   call setPointersAdj(nn,level,sps2)
                   idxngb = globalCell(iCell,jCell-1,kCell)!idxmgb
                   call setPointersAdj(nn,level,sps)
                   !idxngb = globalCell(iCell,jCell-1,kCell)
		  if (idxngb>=0 .and. idxngb.ne.-5) then
                      call MatSetValuesBlocked(dRdWPret, 1, idxngb, 1, idxmgb, &
                                               transpose(Dad(:,:,sps2)), ADD_VALUES,PETScIerr)
                      if( PETScIerr/=0 ) &
                         call errAssemb("MatSetValuesBlocked", "Dad")
	  	  endif
                endif

!!$

                ! >>> north block E < W(i,j+1,k)

                if( (jCell+1) <= jb ) then
                   call setPointersAdj(nn,level,sps2)
                   idxngb = globalCell(iCell,jCell+1,kCell)!idxmgb
                   call setPointersAdj(nn,level,sps)
                   !idxngb = globalCell(iCell,jCell+1,kCell)
                  if (idxngb<nCellsGlobal*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdWPret, 1, idxngb, 1, idxmgb, &
                                              transpose(Ead(:,:,sps2)), ADD_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "Ead")
		  endif
                end if

!!$

                ! >>> back block F < W(i,j,k-1)

                if( (kCell-1) >= 0 ) then
                   call setPointersAdj(nn,level,sps2)
                  idxngb = globalCell(iCell,jCell,kCell-1)!idxmgb
                  call setPointersAdj(nn,level,sps)
                  !idxngb = globalCell(iCell,jCell,kCell-1)
                  if (idxngb>=0 .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdWPret, 1, idxngb, 1, idxmgb, &
                                              transpose(Fad(:,:,sps2)), ADD_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "Fad")
		  endif
                endif

!!$

                ! >>> front block G < W(i,j,k+1)

                if( (kCell+1) <= kb ) then
                  call setPointersAdj(nn,level,sps2)
                  idxngb = globalCell(iCell,jCell,kCell+1)!idxmgb
                  call setPointersAdj(nn,level,sps)
                  !idxngb = globalCell(iCell,jCell,kCell+1)
 		  if (idxngb<nCellsGlobal*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdWPret, 1, idxngb, 1, idxmgb, &
                                              transpose(Gad(:,:,sps2)), ADD_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "Gad")
		  endif
                end if

!!$



              ! >>> sparse matrix -> use MatSetValues

              ! MatSetValues - Inserts or adds a block of values into a
              !                matrix. These values may be cached, so
              !                MatAssemblyBegin() and MatAssemblyEnd()
              !                MUST be called after all calls to 
              !                MatSetValues() have been completed.
              !
              ! Synopsis
              !
              ! #include "petscmat.h" 
              ! call MatSetValues(Mat mat,                             &
              !                PetscInt m,const PetscInt idxm[],       &
              !                PetscInt n,const PetscInt idxn[],       &
              !                const PetscScalar v[], InsertMode addv, &
              !                PetscErrorCodeierr)
              !
              ! Not Collective
              !
              ! Input Parameters
              !   mat     - the matrix
              !   v       - a logically two-dimensional array of values
              !   m, idxm - the number of rows and their global indices
              !   n, idxn - the number of columns and their global indices
              !   addv    - either ADD_VALUES or INSERT_VALUES, where
              !             ADD_VALUES adds values to any existing
              !             entries, and INSERT_VALUES replaces existing
              !             entries with new values
              !
              ! Notes
              ! By default the values, v, are row-oriented and unsorted.
              !   See MatSetOption() for other options.
              !
              ! Calls to MatSetValues() with the INSERT_VALUES
              !   and ADD_VALUES options cannot be mixed without
              !   intervening calls to the assembly routines.
              !
              ! MatSetValues() uses 0-based row and column
              !   numbers in Fortran as well as in C.
              !
              ! Efficiency Alert
              ! The routine MatSetValuesBlocked() may offer much better
              ! efficiency for users of block sparse formats
              ! (MATSEQBAIJ and MATMPIBAIJ).
              !
              ! see .../petsc/docs/manualpages/Mat/MatSetValues.html
              !
              !*********************************************************

              else ! PETScBlockMatrix
		stop
!!$                ! Global matrix block row mgb function of node indices.
!!$                !
!!$                ! MatSetValues() uses 0-based row and column 
!!$                ! numbers but the global node numbering already accounts
!!$                ! for that since it starts at node 0.
!!$
!!$                idxmgb = globalCell(iCell,jCell,kCell)
!!$                call blockIndices(idxmgb, idxmg)
!!$
!!$                ! >>> center block A < W(i,j,k)
!!$
!!$                idxngb = idxmgb
!!$                call blockIndices(idxngb, idxng)
!!$
!!$                call MatSetValues(dRdWPre, nw, idxmg, nw, idxng,  &
!!$                                  Aad, ADD_VALUES, PETScIerr)
!!$                if( PETScIerr/=0 ) &
!!$                  call errAssemb("MatSetValues", "Aad")
!!$
!!$                ! >>> west block B < W(i-1,j,k)
!!$
!!$                if( (iCell-1) >= ib ) then
!!$                  idxngb = globalCell(iCell-1,jCell,kCell)
!!$                  call blockIndices(idxngb, idxng)
!!$
!!$                  call MatSetValues(dRdWPre, nw, idxmg, nw, idxng,  &
!!$                                    Bad, ADD_VALUES, PETScIerr)
!!$                  if( PETScIerr/=0 ) &
!!$                    call errAssemb("MatSetValues", "Bad")
!!$                endif
!!$

!!$
!!$                ! >>> east block C < W(i+1,j,k)
!!$
!!$                if( (iCell+1) <= ie ) then
!!$                  idxngb = globalCell(iCell+1,jCell,kCell)
!!$                  call blockIndices(idxngb, idxng)
!!$
!!$                  call MatSetValues(dRdWPre, nw, idxmg, nw, idxng,  &
!!$                                    Cad, ADD_VALUES, PETScIerr)
!!$                  if( PETScIerr/=0 ) &
!!$                    call errAssemb("MatSetValues", "Cad")
!!$                end if
!!$

!!$
!!$                ! >>> south block D < W(i,j-1,k)
!!$
!!$                if( (jCell-1) >= jb ) then
!!$                  idxngb = globalCell(iCell,jCell-1,kCell)
!!$                  call blockIndices(idxngb, idxng)
!!$
!!$                  call MatSetValues(dRdWPre, nw, idxmg, nw, idxng,  &
!!$                                    Dad, ADD_VALUES, PETScIerr)
!!$                  if( PETScIerr/=0 ) &
!!$                    call errAssemb("MatSetValues", "Dad")
!!$                endif
!!$

!!$
!!$                ! >>> north block E < W(i,j+1,k)
!!$
!!$                if( (jCell+1) <= je ) then
!!$                  idxngb = globalCell(iCell,jCell+1,kCell)
!!$                  call blockIndices(idxngb, idxng)
!!$
!!$                  call MatSetValues(dRdWPre, nw, idxmg, nw, idxng,  &
!!$                                    Ead, ADD_VALUES, PETScIerr)
!!$                  if( PETScIerr/=0 ) &
!!$                    call errAssemb("MatSetValues", "Ead")
!!$                end if
!!$

!!$
!!$                ! >>> back block F < W(i,j,k-1)
!!$
!!$                if( (kCell-1) >= kb ) then
!!$                  idxngb = globalCell(iCell,jCell,kCell-1)
!!$                  call blockIndices(idxngb, idxng)
!!$
!!$                  call MatSetValues(dRdWPre, nw, idxmg, nw, idxng,  &
!!$                                    Fad, ADD_VALUES, PETScIerr)
!!$                  if( PETScIerr/=0 ) &
!!$                    call errAssemb("MatSetValues", "Fad")
!!$                endif
!!$
 

!!$
!!$                ! >>> front block G < W(i,j,k+1)
!!$
!!$                if( (kCell+1) <= ke ) then
!!$                  idxngb = globalCell(iCell,jCell,kCell+1)
!!$                  call blockIndices(idxngb, idxng)
!!$
!!$                  call MatSetValues(dRdWPre, nw, idxmg, nw, idxng,  &
!!$                                    Gad, ADD_VALUES, PETScIerr)
!!$                  if( PETScIerr/=0 ) &
!!$                    call errAssemb("MatSetValues", "Gad")
!!$                end if
!!$

!!$   

              endif ! PETScBlockMatrix
           !end do
	
        enddo
     enddo
  enddo
  
enddo spectralLoop
!===============================================================

enddo domainLoopad

!Return dissipation Parameters to normal
vis2 = vis2_ref
vis4 = vis4_ref
      
!
!     ******************************************************************
!     *                                                                *
!     * Complete the PETSc matrix assembly process.                    *
!     *                                                                *
!     ******************************************************************
!
      ! MatAssemblyBegin - Begins assembling the matrix. This routine
      !  should be called after completing all calls to MatSetValues().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyBegin(Mat mat, &
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      ! Notes
      ! MatSetValues() generally caches the values. The matrix is ready
      !  to use only after MatAssemblyBegin() and MatAssemblyEnd() have
      !  been called. Use MAT_FLUSH_ASSEMBLY when switching between
      !  ADD_VALUES and INSERT_VALUES in MatSetValues(); use
      !  MAT_FINAL_ASSEMBLY for the final assembly before using the
      !  matrix.
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyBegin.html

      call MatAssemblyBegin(dRdWPreT,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrixPC","Error in MatAssemblyBegin")

      ! MatAssemblyEnd - Completes assembling the matrix. This routine
      !                  should be called after MatAssemblyBegin().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyEnd(Mat mat,&
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyEnd.html

      call MatAssemblyEnd  (dRdWPreT,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrixPC","Error in MatAssemblyEnd")

      ! Let PETSc know that the dRdWPC matrix retains the same nonzero 
      ! pattern, in case the matrix is assembled again, as for a new
      ! point in the design space.

      ! MatSetOption - Sets a parameter option for a matrix.
      !   Some options may be specific to certain storage formats.
      !   Some options determine how values will be inserted (or added).
      !   Sorted,row-oriented input will generally assemble the fastest.
      !   The default is row-oriented, nonsorted input.
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! call MatSetOption(Mat mat,MatOption op,PetscErrorCode ierr)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat    - the matrix
      !   option - the option, one of those listed below (and possibly
      !     others), e.g., MAT_ROWS_SORTED, MAT_NEW_NONZERO_LOCATION_ERR
      !
      ! see .../petsc/docs/manualpages/Mat/MatSetOption.html
      ! or PETSc users manual, pp.52
#ifdef USE_PETSC_3
      call MatSetOption(dRdWPreT,MAT_NEW_NONZERO_LOCATIONS,PETSC_FALSE,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrixPCTranspose", "Error in MatSetOption")

#else
      call MatSetOption(dRdWPreT,MAT_NO_NEW_NONZERO_LOCATIONS,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrixPCTranspose", "Error in MatSetOption")
#endif
      ! Get new time and compute the elapsed time.

      call cpu_time(time(2))
      timeAdjLocal = time(2)-time(1)

      ! Determine maximum time using MPI reduce
      ! with operation mpi_max.

      call mpi_reduce(timeAdjLocal, timeAdj, 1, sumb_real, &
                      mpi_max, 0, SUMB_PETSC_COMM_WORLD, PETScIerr)

      if( PETScRank==0 ) &
        write(*,20) "Assembling ADjoint PCT matrix time (s) = ", timeAdj

!
!     ******************************************************************
!     *                                                                *
!     * Visualize the assembled matrix.                                *
!     *                                                                *
!     ******************************************************************
!
      ! MatView - Visualizes a matrix object.
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatView(Mat mat, &
      !                                              PetscViewer viewer)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat    - the matrix
      !   viewer - visualization context
      !
      ! Notes
      ! The available visualization contexts include
      !  PETSC_VIEWER_STDOUT_SELF  - standard output (default)
      !  PETSC_VIEWER_STDOUT_WORLD - synchronized standard output where
      !                         only the first processor opens the file.
      !                         All other processors send their data to
      !                         the first processor to print.
      !  PETSC_VIEWER_DRAW_WORLD- graphical display of nonzero structure
      !
      ! see .../petsc/docs/manualpages/Mat/MatView.html
      ! or PETSc users manual, pp.57,148

!!$      if( debug ) then
!      call PetscViewerBinaryOpen(SUMB_PETSC_COMM_WORLD,outfile,FILE_MODE_WRITE,Bin_Viewer,PETScIerr)
!      call MatView(dRdWpreT,Bin_Viewer,PETScIerr)
!      call PetscViewerDestroy(Bin_Viewer,PETScIerr)
!!$        !call MatView(dRdWPre,PETSC_VIEWER_DRAW_WORLD,PETScIerr)
!!$      print *,'viewing drdwPC'
!!$        call MatView(dRdWPre,PETSC_VIEWER_STDOUT_WORLD,PETScIerr)
!!$        if( PETScIerr/=0 ) &
!!$          call terminate("setupADjointMatrixPC", "Error in MatView")
!!$        !pause
!!$      !endif
!      !now extract and write to a file
!!$       sps = 1
!!$       do nn = 1,nDom
!!$          call setPointersAdj(nn,1,sps)
!!$          do kCell = 2, kl
!!$             do jCell = 2, jl
!!$                do iCell = 2, il
!!$                   do m = 1, nw
!!$                     idxstate   = globalCell(iCell,jCell,kCell)*nw+m 
!!$                     do nnn = 1,ndom
!!$                        call setPointersAdj(nnn,1,sps)
!!$                        DO I=2,Il
!!$                           DO J=2,Jl
!!$                              DO K=2,Kl
!!$                                 do n = 1,nw
!!$                                    idxres = globalCell(i,j,k)*nw+n
!!$                                    call MatGetValues(drdwpret,1,idxstate-1,1,idxres-1,value,PETScIerr)
!!$                                    !if(value.ne.0)then
!!$                                    if(abs(value)>1e-10)then
!!$                                       !write(unitWarp,12)ifaceptb,iedgeptb !'face',ifaceptb,'edge',iedgeptb
!!$!12                                     format(1x,'Face',6I2,'edge',12I2)
!!$                                       write(unitdrdwpre,13) idxstate,idxres,m,icell,jcell,kcell,nn,n,k,j,i,nnn,value
!!$                                       !write(unitWarp,13) xderiv,i,j,k,n,nnn,nn,mm,ll
!!$13                                     format(1x,'drdwpre',12I8,f18.10)
!!$                                    endif
!!$                                 enddo
!!$                              END DO
!!$                           END DO
!!$                        END DO
!!$                        call setPointersAdj(nn,1,sps)
!!$                     end do
!!$                  end do
!!$               enddo
!!$            end do
!!$         end do
!!$      enddo

!!$   endif
!Print *,'barriercall',myID
call mpi_barrier(SUmb_comm_world, ierr)

! close(unitdrdwpre)
      ! Flush the output buffer and synchronize the processors.

      call f77flush()
      call mpi_barrier(SUMB_PETSC_COMM_WORLD, PETScIerr)

      ! Output formats.

   10 format(a)
   20 format(a,1x,f8.2)

      !=================================================================

      contains

        !===============================================================

        subroutine blockIndices(indexBlock, indexArray)
!
!       ****************************************************************
!       *                                                              *
!       * blockIndices fill the array containing the block matrix      *
!       * indices used when assembling the Jacobian matrix with the    *
!       * PETSc function MatSetValues().                               *
!       *                                                              *
!       ****************************************************************
!
        implicit none
!
!       Subroutine arguments.
!
        integer(kind=intType), intent(in) :: indexBlock
        integer(kind=intType), dimension(nw), intent(out) :: indexArray
!
!       Local variables.
!
        integer(kind=intType) :: idx
!
!       ****************************************************************
!       *                                                              *
!       * Begin execution.                                             *
!       *                                                              *
!       ****************************************************************
!
        indexArray(1) = indexBlock * nw
        do idx = 2, nw
          indexArray(idx) = indexArray(idx-1) + 1
        enddo

        end subroutine blockIndices

        !===============================================================

        subroutine errAssemb(routineName, matrixName)
!
!       ****************************************************************
!       *                                                              *
!       * errAssemb handles the error message and program termination  *
!       * during the Jacobian matrix dRdWpre assembly.                    *
!       *                                                              *
!       ****************************************************************
!
        implicit none
!
!       Subroutine arguments.
!
        character(len=*), intent(in) :: routineName
        character(len=*), intent(in) :: matrixName
!
!       Local variables.
!
        character(len=2*maxStringLen) :: errorMessage
!
!       ****************************************************************
!       *                                                              *
!       * Begin execution.                                             *
!       *                                                              *
!       ****************************************************************
!
        ! Determine the number of halo nodes to be communicated and
        ! check if halo data should be copied to the buffer.

        write(errorMessage,99) "Error in",                          &
                               trim(routineName), trim(matrixName), &
                               "for global node", idxmgb
        call terminate("setupADjointMatrix", errorMessage)

        ! Output format.

   99   format(a,1x,a,1x,a,1x,a,1x,i6)

        end subroutine errAssemb

#endif

    end subroutine setupADjointPCMatrixTranspose
