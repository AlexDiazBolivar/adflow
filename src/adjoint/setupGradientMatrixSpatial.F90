!
!     ******************************************************************
!     *                                                                *
!     * File:          setupGradientMatrixSpatial.F90                  *
!     * Author:        C.A.(Sandy) Mader, Andre C. Marta               *
!     * Starting date: 02-15-2007                                      *
!     * Last modified: 05-14-2008                                      *
!     *                                                                *
!     ******************************************************************
!
      subroutine setupGradientMatrixSpatial(level)
!
!     ******************************************************************
!     *                                                                *
!     * Compute the residual partial sensitivity with respect to the   *
!     * grid coordinates x,y,z:                                        *
!     *                                                                *
!     *                                         dpartial R(i,j,k,nw)   *
!     *   dRdx(il,jl,kl,nw,3*nNodesGlobal) = --------------------------*
!     *                                      dpartial x(3*nNodesGlobal)*
!     *                                                                *
!     * Compute the matrix dRdx of the discrete ADjoint problem for    *
!     * subsequent use by the solveADjointPETSc subroutine. The entries*
!     * in dRdx are obtained using the automatically differentiated    *
!     * routines generated by Tapenade.                                *
!     *                                                                *
!     * The ordering of the unknowns in the gradient matrix used here  *
!     * is based on the global node numbering and is consistent with   *
!     * the ordering used in the vector for the gradient problem       *
!     * assembled in setupGradientRHSSpatial.                          *
!     *                                                                *
!     ******************************************************************
!
      use ADjointPETSc
      use ADjointVars
      use blockPointers       ! i/j/kl, globalNode
      use cgnsGrid            ! cgnsDoms
      use communication       ! nProc
      use flowVarRefState     ! nw
      use inputDiscretization ! spaceDiscr
      use inputTimeSpectral   ! nTimeIntervalsSpectral
      use iteration           ! overset, currentLevel
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level
!
!     Local variables.
!
      integer(kind=intType) :: discr, nHalo ,sps     
      integer(kind=intType) :: iNode, jNode, kNode
      integer(kind=intType) :: iCell, jCell, kCell
      integer(kind=intType) :: nn, m, n,mm,liftIndex
      integer(kind=intType) :: ii, jj, kk, i, j, k,xn,l,idxnode,idxres

      logical :: fineGrid, correctForK, exchangeTurb, secondHalo

      real(kind=realType), dimension(-2:2,-2:2,-2:2,nw) :: wAdj, wAdjB
      real(kind=realType), dimension(-3:2,-3:2,-3:2,3)  :: xAdj, xAdjB

      real(kind=realType), dimension(nw) :: dwAdj, dwAdjB

      REAL(KIND=REALTYPE) :: machadj, machcoefadj, uinfadj, pinfcorradj
      REAL(KIND=REALTYPE) :: machadjb, machcoefadjb,machgridadj, machgridadjb
      REAL(KIND=REALTYPE) :: prefadj, rhorefadj
      REAL(KIND=REALTYPE) :: pinfdimadj, rhoinfdimadj
      REAL(KIND=REALTYPE) :: rhoinfadj, pinfadj
      REAL(KIND=REALTYPE) :: murefadj, timerefadj
      REAL(KIND=REALTYPE) :: alphaadj, betaadj
      REAL(KIND=REALTYPE) :: alphaadjb, betaadjb
      REAL(KIND=REALTYPE), DIMENSION(3) :: rotcenteradj
      REAL(KIND=REALTYPE), DIMENSION(3) :: rotrateadj
      REAL(KIND=REALTYPE) :: rotrateadjb(3)

      integer(kind=intType), dimension(0:nProc-1) :: offsetRecv

      real(kind=realType), dimension(2) :: time
      real(kind=realType)               :: timeAdjLocal, timeAdj

      ! dR/dx stencil
      ! Local block matrix at node (iNode,jNode,kNode)

      real(kind=realType), dimension(nw) :: dRdxLocal

      real(kind=realType), dimension(nw,3) :: Aad, &
                                              Bad, BBad, Cad, CCad, &
                                              Dad, DDad, Ead, EEad, &
                                              Fad, FFad, Gad, GGad

      real(kind=realType), dimension(nw,3) :: DFad, DGad, EFad, EGad, &
                                              BFad, BGad, CFad, CGad, &
                                              BDad, BEad, CDad, CEad

      real(kind=realType), dimension(nw,3) :: BEFad, BEGad, CEFad, CEGad, &
                                              BDGad, BDFad, CDGad, CDFad
 
      real(kind=realType), dimension(nw,3) :: BEEFad, BEEGad, CEEFad, CEEGad, &
                                              BDDGad, BDDFad, CDDGad, CDDFad

      ! idxmgb - global block row index
      ! idxngb - global block column index

      integer(kind=intType) :: idxmgb, idxngb

      ! idxmgb - array of global row indices
      ! idxngb - array of global column indices

      integer(kind=intType) :: idxmg(nw), idxng(3)

      character(len=2*maxStringLen) :: errorMessage

      ! auxiliar variables to compute dR/dx using FD

      real(kind=realType) :: xBase, xPert
      real(kind=realType), dimension(nw) :: deltaRes
      real(kind=realType), parameter :: deltax = 1.e-6_realType
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
#ifndef USE_NO_PETSC

      ! Set the grid level of the current MG cycle, the value of the
      ! discretization and the logical correctForK.

      currentLevel = level
      discr        = spaceDiscr
      fineGrid     = .true.

      ! Determine whether or not the total energy must be corrected
      ! for the presence of the turbulent kinetic energy and whether
      ! or not turbulence variables should be exchanged.

      correctForK  = .false.
      exchangeTurb = .false.

     
      ! Set the value of secondHalo, depending on the situation.
      ! In the full MG (currentLevel < groundLevel) the second halo is
      ! always set; otherwise only on the finest mesh in the current mg
      ! cycle.

      if(currentLevel <= groundLevel) then
         secondHalo = .true.
      else
         secondHalo = .false.
      endif

      ! Get the initial time.

      call cpu_time(time(1))
!
!     ******************************************************************
!     *                                                                *
!     *   grid coordinates  in each domain nn                          *
!     *   x(i,j,k)- design variables                                   *
!     *                                                                *
!     ******************************************************************
!
!################## FD CODE - START ################################
      go to 111

      ! Compute the baseline residual values using the usual flow 
      ! solver routines
      !
      ! a) Mean flow equations.

      call residual(.false.)

      ! Store the baseline residual in a backup array.

      do nn=1,nDom

        il = flowDoms(nn,level,1)%il
        jl = flowDoms(nn,level,1)%jl
        kl = flowDoms(nn,level,1)%kl

        dw     => flowDoms(nn,1,sps)%dw
        psiAdj => flowDoms(nn,level,sps)%psiAdj

        do kNode=1,kl
          do jNode=1,jl
            do iNode=1,il
              psiAdj(iNode,jNode,kNode,:) = dw(iNode,jNode,kNode,:)
            enddo
          enddo
        enddo

      enddo

      ! Loop over computational block.

      domainResidualLoopFDorig: do nn=1,nDom   

        call setPointers(nn,level,sps)
         
        ! Loop over all points x.
         
        do i = 1,il
          write(*,*) ' dR/dx <- FD i=', i
          do j = 1,jl
            do k = 1,kl
              do n = 1,3

                ! Store the baseline x.

                xBase = x(i,j,k,n)

                ! Perturb x.

                if( abs(xBase).gt.adjEpsFd ) then
                  xPert = ( one + adjRelFd ) * xBase
                else
                  xPert = adjAbsFd * sign(one, xBase)
                endif

                x(i,j,k,n) = xPert

                ! Recompute the metric.

                call metric(level, .true.)

                ! Compute the perturbed residual value.

                call residual(.false.)

                ! Loop over neighboring residuals R.

                do ii = i-2,i+2
                  do jj = j-2,j+2
                    do kk = k-2,k+2

                      if ( ii>=ib .and. ii<=ie .and. &
                           jj>=jb .and. jj<=je .and. &
                           kk>=kb .and. kk<=ke ) then

                        do m = 1,nw

                          ! Compute dRdx with finite-differences.

                          deltaRes(m) = dw    (ii,jj,kk,m) &
                                      - psiAdj(ii,jj,kk,m)

                          if( abs(xBase).gt.adjEpsFd ) then
                            dRdxLocal(m) = deltaRes(m) &
                                         / ( adjRelFd * xBase )
                          else
                            dRdxLocal(m) = deltaRes(m) &
                                         / ( xPert - xBase )
                          endif

                          idxmg(m) = globalNode(ii,jj,kk)*nw+m-1
  
                        enddo ! m

                        if ( sum(dRdxLocal(:))/=zero ) then

!                          write(*,*) ii-i, jj-j, kk-k, sum(dRdxLocal(:))
!                          pause

                          idxngb = globalNode(i,j,k)

!###                          select case (n)
!###                            case(1)
                              !###call MatSetValues(dRdx, nw, idxmg, &
!###                                                      1 , idxngb,&
!###                                    dRdxLocal, INSERT_VALUES, PETScIerr)
!###                            case(2)
!###                              call MatSetValues(dRdy, nw, idxmg, &
!###                                                      1 , idxngb,&
!###                                    dRdxLocal, INSERT_VALUES, PETScIerr)
!###                            case(3)
!###                              call MatSetValues(dRdz, nw, idxmg, &
!###                                                      1 , idxngb,&
!###                                    dRdxLocal, INSERT_VALUES, PETScIerr)
!###                            case default
!###                              stop
!###                          end select

                        endif

                      endif

                    enddo ! ii
                  enddo ! jj
                enddo ! kk

                x(i,j,k,n) = xBase          
                     
              enddo ! n
            enddo ! i
          enddo ! j
        enddo ! k

      enddo domainResidualLoopFDorig

  111 continue
!################## FD CODE - END ################################


!################## AD CODE - START ################################
!      go to 999
!
!     ******************************************************************
!     *                                                                *
!     * Exchange halo data to make sure it is up-to-date.              *
!     * (originally called inside "rungeKuttaSmoother" subroutine).    *
!     *                                                                *
!     ******************************************************************
!
      ! Exchange the pressure if the pressure must be exchanged early.
      ! Only the first halo's are needed, thus whalo1 is called.
      ! Only on the fine grid.
      
      if(exchangePressureEarly .and. currentLevel <= groundLevel) &
           call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
           .false., .false.)
      
      ! Apply all boundary conditions to all blocks on this level.
      
      call applyAllBC(secondHalo)
      
      ! Exchange the solution. Either whalo1 or whalo2
      ! must be called.
      
      if( secondHalo ) then
         call whalo2(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      else
         call whalo1(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      endif


!
!     ******************************************************************
!     *                                                                *
!     * Compute the  matrix dR/dx using Tapenade's reverse mode        *
!     * of Automatic Differentiation.  NOTE: This is the reason I have *
!     * been writing the word "ADjoint" with A and D capitalized. A    *
!     * simple play with letter so that:                               *
!     *                                                                *
!     * ADjoint = Automatically Differentiated adjoint                 *
!     *                                                                *
!     ******************************************************************
!
      ! Send some feedback to screen.

      if( PETScRank==0 ) &
        write(*,10) "Assembling dR/dx matrix..."

      ! Get the initial time.

      call cpu_time(time(1))

      !zero the matrix for dRdx ADD call
      call MatZeroEntries(dRdx,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupGradientMatrixSpatial", "Error in MatZeroEntries drdx")

      ! Loop over the number of local blocks.

      domainLoop: do nn=1,nDom

         ! Loop over the number of time instances for this block.

         spectralLoop: do sps=1,nTimeIntervalsSpectral

            call setPointersAdj(nn,level,sps)

            ! Loop over location of output (R) cell of residual
            do kCell = 2, kl
		kNode = kCell!-1
               do jCell = 2, jl
		  jNode = jCell!-1
                  do iCell = 2, il
		     iNode = iCell!-1
                     ! Copy the state w to the wAdj array in the stencil
                     call copyADjointStencil(wAdj, xAdj,alphaAdj,betaAdj,MachAdj,&
           machCoefAdj,machGridAdj,iCell, jCell, kCell,prefAdj,&
           rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
           rhoinfAdj, pinfAdj,rotRateAdj,rotCenterAdj,&
           murefAdj, timerefAdj,pInfCorrAdj,liftIndex)

                     !copyADjointStencil(wAdj, xAdj, iCell, jCell, kCell)   


                     mLoop: do m = 1, nw       
                        ! Loop over output cell residuals (R)

                        ! Initialize the seed for the reverse mode
                        dwAdjb(:) = 0.; dwAdjb(m) = 1.
                        dwAdj(:)  = 0.
                        wAdjb(:,:,:,:)  = 0.  !dR(m)/dw
                        xAdjb(:,:,:,:)  = 0.  !dR(m)/dx
                                                
                        ! Call reverse mode of residual computation
                        call COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, dwadj, dwadjb, &
&  alphaadj, alphaadjb, betaadj, betaadjb, machadj, machadjb, &
&  machcoefadj, machgridadj, machgridadjb, icell, jcell, kcell, nn, sps&
&  , correctfork, secondhalo, prefadj, rhorefadj, pinfdimadj, &
&  rhoinfdimadj, rhoinfadj, pinfadj, rotrateadj, rotrateadjb, &
&  rotcenteradj, murefadj, timerefadj, pinfcorradj, liftindex)
!COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, dwadj, dwadjb, &
!&  alphaadj, alphaadjb, betaadj, betaadjb, machadj, machadjb, &
!&  machcoefadj, machgridadj, icell, jcell, kcell, nn, sps, correctfork, &
!&  secondhalo, prefadj, rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, &
!&  pinfadj, rotrateadj, rotrateadjb, rotcenteradj, murefadj, timerefadj&
!&  , pinfcorradj, liftindex)

                         do ii=-3,2!1,il-1
                           do jj = -3,2!1,jl-1
                              do kk = -3,2!1,kl-1
                                 do l = 1,3
                                    i = iCell + ii
                                    j = jCell + jj
                                    k = kCell + kk
                                    !print *,'secondaryindicies',i,j,k,ii,jj,kk
                                    if(i>zero .and. j>zero .and. k>zero .and. i<=ie .and. j<=je .and. k<=ke)then
                                       idxnode = globalNode(i,j,k)*3+l
                                       idxres   = globalCell(iCell,jCell,kCell)*nw+m
                                       if (xAdjb(ii,jj,kk,l).ne.0.0)then
                                          call MatSetValues(dRdx, 1, idxres-1, 1, idxnode-1,   &
                                               xAdjb(ii,jj,kk,l), ADD_VALUES, PETScIerr)
                                          if( PETScIerr/=0 ) &
                                               print *,'matrix setting error'!call errAssemb("MatSetValues", "verifydrdw")
                                       endif
                                    endif
                                 enddo
!!$                                    Aad(m,:)= xAdjB( ii, jj, kk,:)
!!$                                    if(i>zero .and. j>zero .and. k>zero .and. i<=ie .and. j<=je .and. k<=ke)then
!!$                                       idxmgb = globalCell(iCell,jCell,kCell)
!!$                                       call blockIndices(idxmgb, nw, idxmg)
!!$                                   !    !if( (jNode-2) >= 0 ) then
!!$                                       idxngb = globalNode(i,j,k)
!!$                                       if (idxngb>=0 .and. idxngb<nNodesGlobal)then
!!$                                          call blockIndices(idxngb, 3, idxng)
!!$                                          if (any(Aad .ne.0.0)) then
!!$                                             call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                                  Aad, INSERT_VALUES, PETScIerr)
!!$                                             if( PETScIerr/=0 ) &
!!$                                                  call errAssemb("MatSetValues", "DDad")
!!$                                          endif
!!$                                       endif
!!$                                    end if
                        
                                  
                               enddo
                            enddo
                         enddo
                            
                ! Store the block Jacobians (by rows).

                Aad(m,:)  = xAdjB( 0, 0, 0,:)

                BBad(m,:) = xAdjB(-2, 0, 0,:)
                Bad (m,:) = xAdjB(-1, 0, 0,:)
                Cad (m,:) = xAdjB( 1, 0, 0,:)
                CCad(m,:) = xAdjB( 2, 0, 0,:)

                DDad(m,:) = xAdjB( 0,-2, 0,:)
                Dad (m,:) = xAdjB( 0,-1, 0,:)
                Ead (m,:) = xAdjB( 0, 1, 0,:)
                EEad(m,:) = xAdjB( 0, 2, 0,:)

                FFad(m,:) = xAdjB( 0, 0,-2,:)
                Fad (m,:) = xAdjB( 0, 0,-1,:)
                Gad (m,:) = xAdjB( 0, 0, 1,:)
                GGad(m,:) = xAdjB( 0, 0, 2,:)

                DFad(m,:) = xAdjB( 0,-1,-1,:)
                DGad(m,:) = xAdjB( 0,-1, 1,:)
                EFad(m,:) = xAdjB( 0, 1,-1,:)
                EGad(m,:) = xAdjB( 0, 1, 1,:)

                BFad(m,:) = xAdjB(-1, 0,-1,:)
                BGad(m,:) = xAdjB(-1, 0, 1,:)
                CFad(m,:) = xAdjB( 1, 0,-1,:)
                CGad(m,:) = xAdjB( 1, 0, 1,:)

                BDad(m,:) = xAdjB(-1,-1, 0,:)
                BEad(m,:) = xAdjB(-1, 1, 0,:)
                CDad(m,:) = xAdjB( 1,-1, 0,:)
                CEad(m,:) = xAdjB( 1, 1, 0,:)

		BEFad(m,:) = xAdjB(-1, 1,-1,:)
                BEGad(m,:) = xAdjB(-1, 1, 1,:)
                CEFad(m,:) = xAdjB( 1, 1,-1,:)
                CEGad(m,:) = xAdjB( 1, 1, 1,:)

                BDGad(m,:) = xAdjB(-1,-1, 1,:)
                BDFad(m,:) = xAdjB(-1,-1,-1,:)
                CDGad(m,:) = xAdjB( 1,-1, 1,:)
                CDFad(m,:) = xAdjB( 1,-1,-1,:)

		BEEFad(m,:) = xAdjB(-1, 2,-1,:)
                BEEGad(m,:) = xAdjB(-1, 2, 1,:)
                CEEFad(m,:) = xAdjB( 1, 2,-1,:)
                CEEGad(m,:) = xAdjB( 1, 2, 1,:)

                BDDGad(m,:) = xAdjB(-1,-2, 1,:)
                BDDFad(m,:) = xAdjB(-1,-2,-1,:)
                CDDGad(m,:) = xAdjB( 1,-2, 1,:)
                CDDFad(m,:) = xAdjB( 1,-2,-1,:)

              enddo mLoop
	
              !*********************************************************
              !                                                        *
              ! Transfer the block Jacobians to the PETSc matrix.      *
              !                                                        *
              !*********************************************************

              ! MatSetValues - Inserts or adds a block of values into a
              !                matrix. These values may be cached, so
              !                MatAssemblyBegin() and MatAssemblyEnd()
              !                MUST be called after all calls to 
              !                MatSetValues() have been completed.
              !
              ! Synopsis
              !
              ! #include "petscmat.h" 
              ! call MatSetValues(Mat mat,                             &
              !                PetscInt m,const PetscInt idxm[],       &
              !                PetscInt n,const PetscInt idxn[],       &
              !                const PetscScalar v[], InsertMode addv, &
              !                PetscErrorCodeierr)
              !
              ! Not Collective
              !
              ! Input Parameters
              !   mat     - the matrix
              !   v       - a logically two-dimensional array of values
              !   m, idxm - the number of rows and their global indices
              !   n, idxn - the number of columns and their global indices
              !   addv    - either ADD_VALUES or INSERT_VALUES, where
              !             ADD_VALUES adds values to any existing
              !             entries, and INSERT_VALUES replaces existing
              !             entries with new values
              !
              ! Notes
              ! By default the values, v, are row-oriented and unsorted.
              !   See MatSetOption() for other options.
              !
              ! Calls to MatSetValues() with the INSERT_VALUES
              !   and ADD_VALUES options cannot be mixed without
              !   intervening calls to the assembly routines.
              !
              ! MatSetValues() uses 0-based row and column
              !   numbers in Fortran as well as in C.
              !
              ! Efficiency Alert
              ! The routine MatSetValuesBlocked() may offer much better
              ! efficiency for users of block sparse formats
              ! (MATSEQBAIJ and MATMPIBAIJ).
              !
              ! see .../petsc/docs/manualpages/Mat/MatSetValues.html
              !
              !*********************************************************

!!$              ! Global matrix block row mgb function of node indices.
!!$              !
!!$              ! MatSetValues() uses 0-based row and column 
!!$              ! numbers but the global node numbering already accounts
!!$              ! for that since it starts at node 0.
!!$
!!$              idxmgb = globalCell(iCell,jCell,kCell)
!!$              call blockIndices(idxmgb, nw, idxmg)
!!$
!!$              ! >>> center block A < x(i,j,k)
!!$
!!$              idxngb = idxmgb
!!$              call blockIndices(idxngb, 3, idxng)
!!$
!!$              if sum(Aad .ne.0.0) then
!!$
!!$                 call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                      Aad, INSERT_VALUES, PETScIerr)
!!$                 if( PETScIerr/=0 ) &
!!$                      call errAssemb("MatSetValues", "Aad")
!!$              endif
!!$              ! far west block BB < x(i-2,j,k)
!!$
!!$              if( (iNode-2) >= 0 ) then
!!$                idxngb = globalNode(iNode-2,jNode,kNode)
!!$		if (idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$                   if sum(BBad .ne.0.0) then
!!$                      call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                           BBad, INSERT_VALUES, PETScIerr)
!!$                      if( PETScIerr/=0 ) &
!!$                           call errAssemb("MatSetValues", "BBad")
!!$                   end if
!!$	        endif
!!$              end if
!!$
!!$              ! >>> west block B < x(i-1,j,k)
!!$
!!$              if( (iNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode-1,jNode,kNode)
!!$		if (idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$                   if sum(Bad .ne.0.0) then
!!$                      call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                           Bad, INSERT_VALUES, PETScIerr)
!!$                      if( PETScIerr/=0 ) &
!!$                           call errAssemb("MatSetValues", "Bad")
!!$                   endif
!!$		endif
!!$              endif
!!$
!!$              ! >>> east block C < x(i+1,j,k)
!!$
!!$              if( (iNode+1) <= ie ) then
!!$                idxngb = globalNode(iNode+1,jNode,kNode)
!!$		if (idxngb<nNodesGlobal)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$                   if sum(Cad .ne.0.0) then
!!$                      call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                           Cad, INSERT_VALUES, PETScIerr)
!!$                      if( PETScIerr/=0 ) &
!!$                           call errAssemb("MatSetValues", "Cad")
!!$                   endif
!!$		endif
!!$              end if
!!$
!!$              ! >>> far east block CC < x(i+2,j,k)
!!$
!!$              if( (iNode+2) <= ie ) then
!!$                idxngb = globalNode(iNode+2,jNode,kNode)
!!$		if (idxngb<nNodesGlobal)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$                   if sum(CCad .ne.0.0) then
!!$                      call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                           CCad, INSERT_VALUES, PETScIerr)
!!$                      if( PETScIerr/=0 ) &
!!$                           call errAssemb("MatSetValues", "CCad")
!!$                   end if
!!$		endif
!!$              end if
!!$
!!$              ! -----------------------------------
!!$
!!$              ! >>> far south block DD < x(i,j-2,k)
!!$
!!$              if( (jNode-2) >= 0 ) then
!!$                idxngb = globalNode(iNode,jNode-2,kNode)
!!$		if (idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$                   if sum(DDad .ne.0.0) then
!!$                      call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                           DDad, INSERT_VALUES, PETScIerr)
!!$                      if( PETScIerr/=0 ) &
!!$                           call errAssemb("MatSetValues", "DDad")
!!$                   endif
!!$		endif
!!$              end if
!!$
!!$              ! >>> south block D < x(i,j-1,k)
!!$
!!$              if( (jNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode,jNode-1,kNode)
!!$                if (idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                  Dad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "Dad")
!!$		endif
!!$              endif
!!$
!!$              ! >>> north block E < x(i,j+1,k)
!!$
!!$              if( (jNode+1) <= je ) then
!!$                idxngb = globalNode(iNode,jNode+1,kNode)
!!$		if (idxngb<nNodesGlobal)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     Ead, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "Ead")
!!$		endif
!!$              end if
!!$
!!$              ! >>> far north block EE < x(i,j+2,k)
!!$
!!$              if( (jNode+2) <= je ) then
!!$                idxngb = globalNode(iNode,jNode+2,kNode)
!!$		if (idxngb<nNodesGlobal)then
!!$	           call blockIndices(idxngb, 3, idxng)
!!$
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     EEad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "EEad")
!!$		endif
!!$              end if
!!$
!!$              ! -----------------------------------
!!$
!!$              ! >>> far back block FF < x(i,j,k-2)
!!$
!!$              if( (kNode-2) >= 0 ) then
!!$                idxngb = globalNode(iNode,jNode,kNode-2)
!!$		if (idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     FFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "FFad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> back block F < x(i,j,k-1)
!!$
!!$              if( (kNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode,jNode,kNode-1)
!!$		if (idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     Fad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                      call errAssemb("MatSetValues", "Fad")
!!$		endif
!!$              endif
!!$
!!$              ! >>> front block G < x(i,j,k+1)
!!$
!!$              if( (kNode+1) <= ke ) then
!!$                idxngb = globalNode(iNode,jNode,kNode+1)
!!$		if (idxngb<nNodesGlobal)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$    
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     Gad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "Gad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> far front block GG < x(i,j,k+2)
!!$
!!$              if( (kNode+2) <= ke ) then
!!$                idxngb = globalNode(iNode,jNode,kNode+2)
!!$		if (idxngb<nNodesGlobal)then
!!$		   
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   	           
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     GGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "GGad")
!!$		endif
!!$              end if
!!$
!!$              ! -----------------------------------
!!$
!!$              ! >>> block DF < X(i,j-1,k-1)
!!$
!!$              if( (jNode-1) >= 0 .and. (kNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode,jNode-1,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     DFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "DFad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block DG < X(i,j-1,k+1)
!!$
!!$              if( (jNode-1) >= 0 .and. (kNode+1) <= ke ) then
!!$                idxngb = globalNode(iNode,jNode-1,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     DGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "DGad")
!!$		endif
!!$              endif
!!$
!!$              ! >>> block EF < X(i,j+1,k-1)
!!$
!!$              if( (jNode+1) <= je .and. (kNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode,jNode+1,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     EFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "EFad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block EG < X(i,j+1,k+1)
!!$
!!$              if( (jNode+1) <= je .and. (kNode+1) <= ke ) then
!!$                idxngb = globalNode(iNode,jNode+1,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     EGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "EGad")
!!$		endif
!!$              end if
!!$
!!$              ! -----------------------------------
!!$
!!$              ! >>> block BF < X(i-1,j,k-1)
!!$
!!$              if( (iNode-1) >= 0 .and. (kNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode-1,jNode,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "BFad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block BG < X(i-1,j,k+1)
!!$
!!$              if( (iNode-1) >= 0 .and. (kNode+1) <= ke ) then
!!$                idxngb = globalNode(iNode-1,jNode,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$  
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     BGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "BGad")
!!$		endif
!!$              endif
!!$
!!$              ! >>> block CF < X(i+1,j,k-1)
!!$
!!$              if( (iNode+1) <= ie .and. (kNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode+1,jNode,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     CFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CFad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CG < X(i+1,j,k+1)
!!$
!!$              if( (iNode+1) <= ie .and. (kNode+1) <= ke ) then
!!$                idxngb = globalNode(iNode+1,jNode,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CGad")
!!$		endif
!!$              end if
!!$
!!$              ! -----------------------------------
!!$
!!$              ! >>> block BD < X(i-1,j-1,k)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode-1,jNode-1,kNode)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$    
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BDad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "BDad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block BE < X(i-1,j+1,k)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode+1) <= je ) then
!!$                idxngb = globalNode(iNode-1,jNode+1,kNode)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     BEad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "BEad")
!!$		endif
!!$              endif
!!$
!!$              ! >>> block CD < X(i+1,j-1,k)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode+1,jNode-1,kNode)
!!$  		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,  &
!!$                                     CDad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CDad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CE < X(i+1,j+1,k)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode+1) <= je ) then
!!$                idxngb = globalNode(iNode+1,jNode+1,kNode)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CEad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$
!!$
!!$              ! >>> block BEF < X(i-1,j+1,k-1)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode+1) <= je .and. (kNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode-1,jNode+1,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BEFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block BEG < X(i-1,j+1,k+1)!
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode+1) <= je .and. (kNode+1)<=ke ) then
!!$                idxngb = globalNode(iNode-1,jNode+1,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BEGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CEF < X(i+1,j+1,k-1)!
!!$
!!$              if( (iNode+1) <= ie .and. (jNode+1) <= je .and.ke>=0 ) then
!!$                idxngb = globalNode(iNode+1,jNode+1,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$  
!!$                  call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CEFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CEG < X(i+1,j+1,k+1)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode+1) <= je .and. (kNode+1)<=ke) then
!!$                idxngb = globalNode(iNode+1,jNode+1,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CEGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block BDG < X(i-1,j-1,k+1)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode-1) >= 0 .and. (kNode+1)<=ke) then
!!$                idxngb = globalNode(iNode-1,jNode-1,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BDGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$	      ! >>> block BDF < X(i-1,j-1,k-1)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode-1) >= 0 .and. (kNode-1)>=0) then
!!$                idxngb = globalNode(iNode-1,jNode-1,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BDFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CDG < X(i+1,j-1,k+1)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode-1) >= 0 .and. (kNode+1)<=ke) then
!!$                idxngb = globalNode(iNode+1,jNode-1,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CDGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CDF < X(i+1,j-1,k-1)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode-1) >= 0 .and. (kNode-1)>=0) then
!!$                idxngb = globalNode(iNode+1,jNode-1,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CDFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$
!!$             ! >>> block BEEF < X(i-1,j+2,k-1)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode+2) <= je .and. (kNode-1) >= 0 ) then
!!$                idxngb = globalNode(iNode-1,jNode+2,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BEEFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block BEEG < X(i-1,j+2,k+1)!
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode+2) <= je .and. (kNode+1)<=ke ) then
!!$                idxngb = globalNode(iNode-1,jNode+2,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BEEGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CEEF < X(i+1,j+2,k-1)!
!!$
!!$              if( (iNode+1) <= ie .and. (jNode+2) <= je .and.ke>=0 ) then
!!$                idxngb = globalNode(iNode+1,jNode+2,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$  
!!$                  call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CEEFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CEEG < X(i+1,j+2,k+1)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode+2) <= je .and. (kNode+1)<=ke) then
!!$                idxngb = globalNode(iNode+1,jNode+2,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CEEGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block BDDG < X(i-1,j-2,k+1)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode-2) >= 0 .and. (kNode+1)<=ke) then
!!$                idxngb = globalNode(iNode-1,jNode-2,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BDDGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$	      ! >>> block BDDF < X(i-1,j-2,k-1)
!!$
!!$              if( (iNode-1) >= 0 .and. (jNode-2) >= 0 .and. (kNode-1)>=0) then
!!$                idxngb = globalNode(iNode-1,jNode-2,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     BDDFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CDDG < X(i+1,j-2,k+1)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode-2) >= 0 .and. (kNode+1)<=ke) then
!!$                idxngb = globalNode(iNode+1,jNode-2,kNode+1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CDDGad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if
!!$
!!$              ! >>> block CDDF < X(i+1,j-2,k-1)
!!$
!!$              if( (iNode+1) <= ie .and. (jNode-2) >= 0 .and. (kNode-1)>=0) then
!!$                idxngb = globalNode(iNode+1,jNode-2,kNode-1)
!!$		if (idxngb<nNodesGlobal.and.idxngb>=0)then
!!$                   call blockIndices(idxngb, 3, idxng)
!!$   
!!$                   call MatSetValues(dRdx, nw, idxmg, 3, idxng,   &
!!$                                     CDDFad, INSERT_VALUES, PETScIerr)
!!$                   if( PETScIerr/=0 ) &
!!$                     call errAssemb("MatSetValues", "CEad")
!!$		endif
!!$              end if

            enddo 
          enddo 
        enddo 

       enddo spectralLoop
      enddo domainLoop


!################## AD CODE - END ################################
  999 continue

!
!     ******************************************************************
!     *                                                                *
!     * Complete the PETSc matrix assembly process.                    *
!     *                                                                *
!     ******************************************************************
!
      ! MatAssemblyBegin - Begins assembling the matrix. This routine
      !  should be called after completing all calls to MatSetValues().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyBegin(Mat mat, &
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      ! Notes
      ! MatSetValues() generally caches the values. The matrix is ready
      !  to use only after MatAssemblyBegin() and MatAssemblyEnd() have
      !  been called. Use MAT_FLUSH_ASSEMBLY when switching between
      !  ADD_VALUES and INSERT_VALUES in MatSetValues(); use
      !  MAT_FINAL_ASSEMBLY for the final assembly before using the
      !  matrix.
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyBegin.html

      call MatAssemblyBegin(dRdx,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupGradientMatrixSpatial", &
                       "Error in MatAssemblyBegin X")

      ! MatAssemblyEnd - Completes assembling the matrix. This routine
      !                  should be called after MatAssemblyBegin().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyEnd(Mat mat,&
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyEnd.html

      call MatAssemblyEnd  (dRdx,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupGradientMatrixSpatial", &
                       "Error in MatAssemblyEnd X")

      ! Let PETSc know that the dRda matrix retains the same nonzero 
      ! pattern, in case the matrix is assembled again, as for a new
      ! point in the design space.

      ! MatSetOption - Sets a parameter option for a matrix.
      !   Some options may be specific to certain storage formats.
      !   Some options determine how values will be inserted (or added).
      !   Sorted,row-oriented input will generally assemble the fastest.
      !   The default is row-oriented, nonsorted input.
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! call MatSetOption(Mat mat,MatOption op,PetscErrorCode ierr)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat    - the matrix
      !   option - the option, one of those listed below (and possibly
      !     others), e.g., MAT_ROWS_SORTED, MAT_NEW_NONZERO_LOCATION_ERR
      !
      ! see .../petsc/docs/manualpages/Mat/MatSetOption.html
      ! or PETSc users manual, pp.52

      call MatSetOption(dRdx,MAT_NO_NEW_NONZERO_LOCATIONS,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupGradientMatrixSpatial", &
                       "Error in MatSetOption X")

      ! Get new time and compute the elapsed time.

      call cpu_time(time(2))
      timeAdjLocal = time(2)-time(1)

      ! Determine the maximum time using MPI reduce
      ! with operation mpi_max.

      call mpi_reduce(timeAdjLocal, timeAdj, 1, sumb_real, &
                      mpi_max, 0, PETSC_COMM_WORLD, PETScIerr)

      if( PETScRank==0 ) &
        write(*,20) "Assembling dR/dx matrix time (s) =", timeAdj
!
!     ******************************************************************
!     *                                                                *
!     * Visualize the assembled matrix.                                *
!     *                                                                *
!     ******************************************************************
!
      ! MatView - Visualizes a matrix object.
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatView(Mat mat, &
      !                                              PetscViewer viewer)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat    - the matrix
      !   viewer - visualization context
      !
      ! Notes
      ! The available visualization contexts include
      !  PETSC_VIEWER_STDOUT_SELF  - standard output (default)
      !  PETSC_VIEWER_STDOUT_WORLD - synchronized standard output where
      !                         only the first processor opens the file.
      !                         All other processors send their data to
      !                         the first processor to print.
      !  PETSC_VIEWER_DRAW_WORLD- graphical display of nonzero structure
      !
      ! see .../petsc/docs/manualpages/Mat/MatView.html
      ! or PETSc users manual, pp.57,148

      if( debug ) then
        !call MatView(dRdx,PETSC_VIEWER_DRAW_WORLD,PETScIerr)
        call MatView(dRdx,PETSC_VIEWER_STDOUT_WORLD,PETScIerr)
        if( PETScIerr/=0 ) &
          call terminate("setupGradientMatrixSpatial", "Error in MatView")
        !pause
      endif

      ! Flush the output buffer and synchronize the processors.

      call f77flush()
      call mpi_barrier(PETSC_COMM_WORLD, PETScIerr)

      ! Output formats.

   10 format(a,1x,i3,1x,a,1x,i3)
   20 format(a,1x,f8.2)

      !=================================================================

      contains

        !===============================================================

        subroutine blockIndices(indexBlock, sizeBlock, indexArray)
!
!       ****************************************************************
!       *                                                              *
!       * blockIndices fill the array containing the block matrix      *
!       * indices used when assembling the Jacobian matrix with the    *
!       * PETSc function MatSetValues().                               *
!       *                                                              *
!       ****************************************************************
!
        implicit none
!
!       Subroutine arguments.
!
        integer(kind=intType), intent(in) :: indexBlock
        integer(kind=intType), intent(in) :: sizeBlock
        integer(kind=intType), dimension(sizeBlock), intent(out) :: &
                                                              indexArray
!
!       Local variables.
!
        integer(kind=intType) :: idx
!
!       ****************************************************************
!       *                                                              *
!       * Begin execution.                                             *
!       *                                                              *
!       ****************************************************************
!
        indexArray(1) = indexBlock * sizeBlock
        do idx = 2, sizeBlock
          indexArray(idx) = indexArray(idx-1) + 1
        enddo

        end subroutine blockIndices

        !===============================================================

        subroutine errAssemb(routineName, matrixName)
!
!       ****************************************************************
!       *                                                              *
!       * errAssemb handles the error message and program termination  *
!       * during the Jacobian matrix dRdW assembly.                    *
!       *                                                              *
!       ****************************************************************
!
        implicit none
!
!       Subroutine arguments.
!
        character(len=*), intent(in) :: routineName
        character(len=*), intent(in) :: matrixName
!
!       Local variables.
!
        character(len=2*maxStringLen) :: errorMessage
!
!       ****************************************************************
!       *                                                              *
!       * Begin execution.                                             *
!       *                                                              *
!       ****************************************************************
!
        ! Determine the number of halo nodes to be communicated and
        ! check if halo data should be copied to the buffer.

        write(errorMessage,99) "Error in",                          &
                               trim(routineName), trim(matrixName), &
                               "for global node", idxmgb
        call terminate("setupGradientMatrixSpatial", errorMessage)

        ! Output format.

   99   format(a,1x,a,1x,a,1x,a,1x,i6)

        end subroutine errAssemb

#endif

      end subroutine setupGradientMatrixSpatial
