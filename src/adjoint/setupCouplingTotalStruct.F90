!     ******************************************************************
!     *                                                                *
!     * File:          setupCouplingTotalStruct.f90                    *
!     * Author:        C.A.(Sandy) Mader                               *
!     * Starting date: 08-19-2008                                      *
!     * Last modified: 08-19-2008                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine setupCouplingTotalStruct(level)
!
!     ******************************************************************
!     *                                                                *
!     * Compute all entries in dSdx (partial) using the automatically  *
!     * differentiated routines generated by Tapenade and store        *
!     * them in PETSc                                                  *
!     *                                                                *
!     ******************************************************************
!
      use adjointpetsc        !djdw
      use adjointVars         !nCellsGlobal
      use blockPointers
      use cgnsGrid            ! cgnsDoms
      use communication       ! procHalo(currentLevel)%nProcSend, myID
      use inputPhysics        ! equations
      use flowVarRefState     ! nw
      use inputDiscretization ! spaceDiscr, useCompactDiss
      use iteration           ! overset, currentLevel
      use inputTimeSpectral   ! nTimeIntervalsSpectral
      use section
      use monitor             ! monLoc, MonGlob, nMonSum
      use bcTypes             !imin,imax,jmin,jmax,kmin,kmax
      use mdDataLocal
      use mdData              !mdNSurfNodes
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level
!
!     Local variables.
!
      integer(kind=intType) :: discr, nHalo, sps
      integer(kind=intType) :: modFamID,ii,famID=0,startind,endind
      integer(kind=intType) :: icell, jcell, kcell, mm, nn, m, n
      !integer(kind=intType) :: ii, jj, kk, i1, j1, k1, i2, j2, k2

      integer(kind=intType) ::  i2Beg,  i2End,  j2Beg,  j2End
      integer(kind=intType) :: iiBeg, iiEnd, jjBeg, jjEnd
      integer(kind=intType) :: i,j,k,l

      logical :: fineGrid,correctForK, exchangeTurb
      integer(kind=intType)::liftIndex

      real(kind=realType), dimension(:,:,:,:), allocatable :: xAdj,xAdjB
      real(kind=realType), dimension(:,:,:,:), allocatable :: wAdj,wAdjB
      real(kind=realType), dimension(:,:,:), allocatable :: pAdj

      real(kind=realType), dimension(:,:),allocatable :: forceLoc,forcelocb,forcelocp,forcelocm

      real(kind=realType) :: alphaAdj, betaAdj,MachAdj,machCoefAdj
      real(kind=realType) :: alphaAdjb, betaAdjb,MachAdjb,machCoefAdjb
      REAL(KIND=REALTYPE) :: prefAdj, rhorefAdj,pInfCorrAdj
      REAL(KIND=REALTYPE) :: pinfdimAdj, rhoinfdimAdj
      REAL(KIND=REALTYPE) :: rhoinfAdj, pinfAdj
      REAL(KIND=REALTYPE) :: murefAdj, timerefAdj


      real(kind=realType) :: factI, factJ, factK, tmp

      integer(kind=intType), dimension(0:nProc-1) :: offsetRecv

      real(kind=realType), dimension(4) :: time
      real(kind=realType)               :: timeAdj, timeFD

      real(kind=realType), dimension(:,:,:), pointer :: norm
      real(kind=realType), dimension(:,:,:),allocatable:: normAdj
      real(kind=realType), dimension(3) :: refPoint
      real(kind=realType) :: yplusMax

      logical :: contributeToForce, viscousSubface,secondHalo,righthanded

      integer :: ierr,nmonsum1,nmonsum2,idxmgb,idxres,idxsurf

      character(len=2*maxStringLen) :: errorMessage

      ! dJ/dw row block
      
      !real(kind=realType), dimension(nw) :: dJdWlocal
	
#ifndef USE_NO_PETSC
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
      !print *,'in verifydSdw...'
      if( myID==0 ) write(*,*) "Running setupCouplingTotalStruct..."

      ! Set the grid level of the current MG cycle, the value of the
      ! discretization and the logical correctForK.

      currentLevel = level
      discr        = spaceDiscr
      correctForK  = .false.
      fineGrid     = .true.

      ! Determine whether or not the total energy must be corrected
      ! for the presence of the turbulent kinetic energy and whether
      ! or not turbulence variables should be exchanged.

      correctForK  = .false.
      exchangeTurb = .false.
      secondhalo = .true.


!      !determine the number of surface nodes for coupling matrix
!      call mdCreateNSurfNodesLocal
      modFamID = max(0, 1_intType)
!      nSurfNodesLocal = mdNSurfNodesLocal(modFamID)

      allocate(forceLoc(3,nSurfNodesLocal), stat=ierr)
      if(ierr /= 0)                             &
           call terminate("verifyForceCoupling", &
           "Memory allocation failure for forceLoc")

      allocate(forceLocb(3,nSurfNodesLocal), stat=ierr)
      if(ierr /= 0)                             &
           call terminate("verifyForceCoupling", &
           "Memory allocation failure for forceLocb")

       
      forceLoc = zero

      ! Exchange the pressure if the pressure must be exchanged early.
      ! Only the first halo's are needed, thus whalo1 is called.
      ! Only on the fine grid.
      
      if(exchangePressureEarly .and. currentLevel <= groundLevel) &
           call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
           .false., .false.)
      
      ! Apply all boundary conditions to all blocks on this level.
      
      call applyAllBC(secondHalo)
      
      ! Exchange the solution. Either whalo1 or whalo2
      ! must be called.
      
      if( secondHalo ) then
         call whalo2(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      else
         call whalo1(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      endif

      call mpi_barrier(SUmb_comm_world, ierr)      


      print *,"halo's updated"
!
!     ******************************************************************
!     *                                                                *
!     * Compute the d(forces)/dw (partial) using the tapenade routines.*
!     *                                                                *
!     ******************************************************************
         
!*********************
      ! Determine the reference point for the moment computation in
      ! meters.
      print *,'setting refpoint'
      refPoint(1) = LRef*pointRef(1)
      refPoint(2) = LRef*pointRef(2)
      refPoint(3) = LRef*pointRef(3)

       ! Initialize the force and moment coefficients to 0 as well as
       ! yplusMax.

       yplusMax = zero

   !    print *,'Adjoint forces initialized'
!
!***********************************
       print *,' computing adjoint derivatives'
       
   spectralLoopAdj: do sps=1,nTimeIntervalsSpectral
      ! Loop over the number of local blocks.
      print *,'starting domain loop'
      ii=0.0
      domainLoopAD: do nn=1,nDom

         ! Set some pointers to make the code more readable.
         print *,'setting pointers'
         call setPointersAdj(nn,level,sps)
         print *,'allocating memory'
         allocate(xAdj(0:ie,0:je,0:ke,3), stat=ierr)
         if(ierr /= 0)                              &
              call terminate("Memory allocation failure for xAdj.")
         
         allocate(xAdjB(0:ie,0:je,0:ke,3), stat=ierr)
         if(ierr /= 0)                              &
              call terminate("Memory allocation failure for xAdjB.")
         
         allocate(wAdj(0:ib,0:jb,0:kb,nw), stat=ierr)
         if(ierr /= 0)                              &
              call terminate("Memory allocation failure for wAdj.")
         
         allocate(wAdjB(0:ib,0:jb,0:kb,nw), stat=ierr)
         if(ierr /= 0)                              &
              call terminate("Memory allocation failure for wAdjB.")
        
         allocate(pAdj(0:ib,0:jb,0:kb), stat=ierr)
         if(ierr /= 0)                              &
              call terminate("Memory allocation failure for pAdj.")
         
         print *,'finished allocating',nn,level,sps
         righthanded = flowDoms(nn,level,sps)%righthanded
        
                  
        ! Copy the coordinates into xAdj and
        ! Compute the face normals on the subfaces
          call copyADjointForcesStencil(wAdj,xAdj,alphaAdj,betaAdj,&
           MachAdj,machCoefAdj,prefAdj,rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
           rhoinfAdj, pinfAdj,murefAdj, timerefAdj,pInfCorrAdj,nn,level,sps,&
           liftIndex)
  
        !call copyADjointForcesStencil(wAdj,xAdj,nn,level,sps)
        
        bocoLoop: do mm=1,nBocos

           ! Determine the range of cell indices of the owned cells
           ! Notice these are not the node indices
           iiBeg = BCData(mm)%icBeg
           iiEnd = BCData(mm)%icEnd
           jjBeg = BCData(mm)%jcBeg
           jjEnd = BCData(mm)%jcEnd
           
           i2Beg= BCData(mm)%inBeg+1; i2End = BCData(mm)%inEnd
           j2Beg= BCData(mm)%jnBeg+1; j2End = BCData(mm)%jnEnd
           
           ! Initialize the seed for reverse mode. Cl is the first one
           do m=1,nSurfNodesLocal
              do n=1,3
                 forcelocb(:,:) = zero
                 forcelocb(n,m) = 1
                 
                 xAdjB(:,:,:,:) = zero ! > return dS/dx
                 wAdjB(:,:,:,:) = zero ! > return dS/dW
                 !print *,'calling adjoint forces_b'
                 !===========================================================
                 !           
                 !print *,'Initial Parameters Calculated,Computing Lift Partials...'
                 !=========================================================
                 ! Compute the force derivatives
           call COMPUTEFORCECOUPLINGADJ_B(xadj, xadjb, wadj, wadjb, padj, &
&  iibeg, iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, yplusmax&
&  , refpoint, nsurfnodeslocal, forceloc, forcelocb, nn, level, sps, &
&  righthanded, secondhalo, alphaadj, alphaadjb, betaadj, betaadjb, &
&  machadj, machadjb, machcoefadj, prefadj, rhorefadj, pinfdimadj, &
&  rhoinfdimadj, rhoinfadj, pinfadj, murefadj, timerefadj, pinfcorradj, &
&  liftindex, ii)
 
           do k = 0,kb
              do j = 0,jb
                 do i = 0,ib
                    do l = 1,3
               
                       idxSurf = (m-1)*3+n +( mdNsurfNodes(myID,modFamID)*3)
                       idxres   = globalnode(i,j,k)*3+l
                       if (xAdjb(i,j,k,l).ne.0.0)then
                          !print *,'wadjb',wadjb(i,j,k,l),i,j,k,l
                          call MatSetValues(dSdx, 1, idxSurf-1, 1, idxres-1,   &
                               xAdjb(i,j,k,l), INSERT_VALUES, PETScIerr)
                          if( PETScIerr/=0 ) &
                               print *,'matrix setting error'!call errAssemb("MatSetValues", "verifydrdw")
                          
                       endif

                    enddo
                 enddo
              enddo
           enddo
           
        enddo
     enddo
     !from forceCouplingadj.f90
     ! Update the counter ii.
     if(BCType(mm) == EulerWall       .or. &
                BCType(mm) == NSWallAdiabatic .or. &
                BCType(mm) == NSWallIsothermal) then
        ii = ii + (j2End-j2Beg+2)*(i2End-i2Beg+2)
     endif
  enddo bocoLoop
          !===============================================================
        
        !print *,' deallocating'
        ! Deallocate the xAdj.
        deallocate(pAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.")
             
        ! Deallocate the xAdj.
        deallocate(wAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(wAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        ! Deallocate the xAdj.
        deallocate(xAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(xAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        !print *,'finishhed deallocating'
       
      enddo domainLoopAD

   enddo spectralLoopAdj

!
!     ******************************************************************
!     *                                                                *
!     * Complete the PETSc matrix assembly process.                    *
!     *                                                                *
!     ******************************************************************
!
      ! MatAssemblyBegin - Begins assembling the matrix. This routine
      !  should be called after completing all calls to MatSetValues().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyBegin(Mat mat, &
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      ! Notes
      ! MatSetValues() generally caches the values. The matrix is ready
      !  to use only after MatAssemblyBegin() and MatAssemblyEnd() have
      !  been called. Use MAT_FLUSH_ASSEMBLY when switching between
      !  ADD_VALUES and INSERT_VALUES in MatSetValues(); use
      !  MAT_FINAL_ASSEMBLY for the final assembly before using the
      !  matrix.
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyBegin.html

      call MatAssemblyBegin(dSdx,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("verifydSdx", &
                       "Error in MatAssemblyBegin X")

      ! MatAssemblyEnd - Completes assembling the matrix. This routine
      !                  should be called after MatAssemblyBegin().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyEnd(Mat mat,&
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyEnd.html

      call MatAssemblyEnd  (dSdx,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("verifydSdx", &
                       "Error in MatAssemblyEnd S")

      ! Let PETSc know that the dRda matrix retains the same nonzero 
      ! pattern, in case the matrix is assembled again, as for a new
      ! point in the design space.

      ! MatSetOption - Sets a parameter option for a matrix.
      !   Some options may be specific to certain storage formats.
      !   Some options determine how values will be inserted (or added).
      !   Sorted,row-oriented input will generally assemble the fastest.
      !   The default is row-oriented, nonsorted input.
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! call MatSetOption(Mat mat,MatOption op,PetscErrorCode ierr)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat    - the matrix
      !   option - the option, one of those listed below (and possibly
      !     others), e.g., MAT_ROWS_SORTED, MAT_NEW_NONZERO_LOCATION_ERR
      !
      ! see .../petsc/docs/manualpages/Mat/MatSetOption.html
      ! or PETSc users manual, pp.52
#ifndef USE_PETSC_3
      call MatSetOption(dSdx,MAT_NO_NEW_NONZERO_LOCATIONS,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("verifydSdx", &
                       "Error in MatSetOption X")
#endif
      ! Get new time and compute the elapsed time.

!!$      call cpu_time(time(2))
!!$      timeAdjLocal = time(2)-time(1)
!!$
!!$      ! Determine the maximum time using MPI reduce
!!$      ! with operation mpi_max.
!!$
!!$      call mpi_reduce(timeAdjLocal, timeAdj, 1, sumb_real, &
!!$                      mpi_max, 0, PETSC_COMM_WORLD, PETScIerr)
!!$
!!$      if( PETScRank==0 ) &
!!$        write(*,20) "Assembling dS/dw matrix time (s) =", timeAdj
#endif      
    end subroutine setupCouplingTotalStruct
