!
!     ******************************************************************
!     *                                                                *
!     * File:          verifydCfdx.f90                                 *
!     * Author:        Andre C. Marta, C.A.(Sandy) Mader               *
!     * Starting date: 01-15-2007                                      *
!     * Last modified: 05-13-2008                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine verifydCfdw(level)
!
!     ******************************************************************
!     *                                                                *
!     * Compute all entries in dIdx (partial) using the automatically  *
!     * differentiated routines generated by Tapenade and compare      *
!     * them to the finite-difference results using the modified       *
!     * force routine. This is only executed in debug mode.            *
!     *                                                                *
!     ******************************************************************
!
      use adjointpetsc        !djdw
      use adjointVars         !nCellsGlobal
      use blockPointers
      use cgnsGrid            ! cgnsDoms
      use communication       ! procHalo(currentLevel)%nProcSend, myID
      use inputPhysics        ! equations
      use flowVarRefState     ! nw
      use inputDiscretization ! spaceDiscr, useCompactDiss
      use iteration           ! overset, currentLevel
      use inputTimeSpectral   ! nTimeIntervalsSpectral
      use section
      use monitor             ! monLoc, MonGlob, nMonSum
      use bcTypes             !imin,imax,jmin,jmax,kmin,kmax
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level
!
!     Local variables.
!
      integer(kind=intType) :: discr, nHalo, sps,domain
      integer(kind=intType) :: icell, jcell, kcell, mm, nn, m, n
      integer(kind=intType) :: ii, jj, kk, i1, j1, k1, i2, j2, k2

      integer(kind=intType) ::  i2Beg,  i2End,  j2Beg,  j2End
      integer(kind=intType) :: iiBeg, iiEnd, jjBeg, jjEnd
      integer(kind=intType) :: i,j,k,l

      logical :: fineGrid,correctForK, exchangeTurb

      real(kind=realType) :: Cl,Cd,Cfx,Cfy,Cfz,Cmx,Cmy,Cmz
      real(kind=realType) :: ClAdj,CdAdj,CfxAdj,CfyAdj,CfzAdj,&
                             &CmxAdj,CmyAdj,CmzAdj  
      real(kind=realType) :: CLAdjP,CLAdjM,CDAdjP,CDAdjM,dCLdwFD,dCDdwFD,&
                             &dCmxdwFD,CmxAdjP,CmxAdjM
      real(kind=realType) :: ClAdjB,CdAdjB,CfxAdjB,CfyAdjB,CfzAdjB,&
                             &CmxAdjB,CmyAdjB,CmzAdjB 

      real(kind=realType) :: CLP,CLM,CDP,CDM,CmxP,CmxM,CmyP,CmyM,CmzP,CmzM,&
                             &CfxP,CfxM,CfyP,CfyM,CfzP,CfzM

      real(kind=realType), dimension(:,:,:,:), allocatable :: xAdj,xAdjB
      real(kind=realType), dimension(:,:,:,:), allocatable :: wAdj,wAdjB
      real(kind=realType), dimension(:,:,:), allocatable :: pAdj

      real(kind=realType), dimension(3) :: cFpAdj, cFvAdj
      real(kind=realType), dimension(3) :: cMpAdj, cMvAdj

      real(kind=realType), dimension(3) :: cFp, cFv
      real(kind=realType), dimension(3) :: cMp, cMv



      real(kind=realType) :: alphaAdj, betaAdj,MachAdj,machCoefAdj,MachGridAdj
      real(kind=realType) :: alphaAdjb, betaAdjb,MachAdjb,machCoefAdjb,MachGridAdjb
      REAL(KIND=REALTYPE) :: prefAdj, rhorefAdj,pInfCorrAdj
      REAL(KIND=REALTYPE) :: pinfdimAdj, rhoinfdimAdj
      REAL(KIND=REALTYPE) :: rhoinfAdj, pinfAdj
      REAL(KIND=REALTYPE) :: murefAdj, timerefAdj
      integer(kind=intType)::liftIndex
      real(kind=realType), dimension(3) ::rotRateAdj,rotCenterAdj,rotrateadjb
      
      real(kind=realType) :: factI, factJ, factK, tmp

      integer(kind=intType), dimension(0:nProc-1) :: offsetRecv

      real(kind=realType), dimension(4) :: time
      real(kind=realType)               :: timeAdj, timeFD

      ! > derivative output

      real(kind=realType), dimension(:,:,:,:,:), allocatable ::dCL, &
           dCD,dCmx
      real(kind=realType), dimension(:,:,:,:,:), allocatable :: dCLfd, &
           dCDfd,dCmxfd
      real(kind=realType), dimension(:,:,:,:,:), allocatable :: dCLer, &
           dCDer,dCmxer

      real(kind=realType), parameter :: deltaw = 1.e-8_realType

      real(kind=realType) :: wAdjRef, wref,test

      real(kind=realType), dimension(:,:,:), pointer :: norm
      real(kind=realType), dimension(:,:,:),allocatable:: normAdj
      real(kind=realType), dimension(3) :: refPoint
      real(kind=realType) :: yplusMax

      real(kind=realType),  dimension(:), allocatable :: monLoc1, monGlob1
      real(kind=realType),  dimension(:), allocatable :: monLoc2, monGlob2

      logical :: contributeToForce, viscousSubface,secondHalo

      integer :: ierr,nmonsum1,nmonsum2,idxmgb

      character(len=2*maxStringLen) :: errorMessage

      ! dJ/dw row block
      
      real(kind=realType), dimension(nw) :: dJdWlocal
	

!File Parameters
      integer :: unit = 8,ierror
      character(len = 10)::outfile
      
      outfile = "dcfdw.txt"
      
      open (UNIT=unit,File=outfile,status='replace',action='write',iostat=ierror)
      if(ierror /= 0)                        &
           call terminate("verifydCfdw", &
           "Something wrong when &
           &calling open")
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
#ifndef USE_NO_PETSC
      print *,'in verifydcfdw'
 !     if( myID==0 ) write(*,*) "Running verifydCfdx...",sps

      ! Set the grid level of the current MG cycle, the value of the
      ! discretization and the logical correctForK.

      currentLevel = level
      discr        = spaceDiscr
      correctForK  = .false.
      fineGrid     = .true.

      ! Determine whether or not the total energy must be corrected
      ! for the presence of the turbulent kinetic energy and whether
      ! or not turbulence variables should be exchanged.

      correctForK  = .false.
      exchangeTurb = .false.
      secondhalo = .true.

      ! Allocate memory for the temporary arrays.

      ib = maxval(flowDoms(:,currentLevel,1)%ib)
      jb = maxval(flowDoms(:,currentLevel,1)%jb)
      kb = maxval(flowDoms(:,currentLevel,1)%kb)

      allocate(dCL(nDom,0:ib,0:jb,0:kb,nw), dCLfd(nDom,0:ib,0:jb,0:kb,nw))
      allocate(dCD(nDom,0:ib,0:jb,0:kb,nw), dCDfd(nDom,0:ib,0:jb,0:kb,nw))
      allocate(dCmx(nDom,0:ib,0:jb,0:kb,nw), dCmxfd(nDom,0:ib,0:jb,0:kb,nw))
       
      allocate(dCLer(nDom,0:ib,0:jb,0:kb,nw))
      allocate(dCDer(nDom,0:ib,0:jb,0:kb,nw))
      allocate(dCmxer(nDom,0:ib,0:jb,0:kb,nw))

      
      nmonsum1 = 8
      nmonsum2 = 8

      allocate(monLoc1(nmonsum1), monGlob1(nmonsum1))
      allocate(monLoc2(nmonsum2), monGlob2(nmonsum2))

      ! Initialize the temporary arrays.

      dCL   = zero; dCLfd   = zero; dCLer   = zero;
      dCD   = zero; dCDfd   = zero; dCDer   = zero;
      dCmx  = zero; dCmxfd  = zero; dCmxer  = zero;

     ! Exchange the pressure if the pressure must be exchanged early.
      ! Only the first halo's are needed, thus whalo1 is called.
      ! Only on the fine grid.
      
      if(exchangePressureEarly .and. currentLevel <= groundLevel) &
           call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
           .false., .false.)
      
      ! Apply all boundary conditions to all blocks on this level.
      
      call applyAllBC(secondHalo)
      
      ! Exchange the solution. Either whalo1 or whalo2
      ! must be called.
      
      if( secondHalo ) then
         call whalo2(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      else
         call whalo1(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      endif

      call mpi_barrier(SUmb_comm_world, ierr)      


      print *,"halo's updated"
!
!     ******************************************************************
!     *                                                                *
!     * Compute the d(forces)/dx (partial) using the tapenade routines.*
!     *                                                                *
!     ******************************************************************
         
!*********************
      !from ForcesAndMoments.f90
!!$       ! Determine the reference point for the moment computation in
!!$       ! meters.
!!$      print *,'setting refpoint'
!!$       refPoint(1) = LRef*pointRef(1)
!!$       refPoint(2) = LRef*pointRef(2)
!!$       refPoint(3) = LRef*pointRef(3)

       ! Initialize the force and moment coefficients to 0 as well as
       ! yplusMax.

!!$       cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$       cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$       cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$       cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
       print *,'zeroing output'
       ClAdj = zero
       CDAdj = zero
       CmxAdj = zero 
       CmyAdj = zero
       CmzAdj = zero
       CfxAdj = zero
       CfyAdj = zero
       CfzAdj = zero

       yplusMax = zero

   !    print *,'Adjoint forces initialized'
!
!***********************************
       print *,' computing adjoint derivatives'
       
   spectralLoopAdj: do sps=1,nTimeIntervalsSpectral
      
      print *,'zeroing force output'
      !zero the force components
      cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
      cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
      cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
      cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
      ! Loop over the number of local blocks.
      print *,'starting domain loop'
      domainLoopAD: do nn=1,nDom

        ! Set some pointers to make the code more readable.
         print *,'setting pointers'
        call setPointersAdj(nn,level,sps)
        print *,'allocating memory'
        allocate(xAdj(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdj.")

        allocate(xAdjB(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdjB.")
        
        allocate(wAdj(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdj.")

        allocate(wAdjB(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdjB.")
        
        allocate(pAdj(0:ib,0:jb,0:kb), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for pAdj.")
        
        print *,'finished allocating',nn,level,sps
        righthanded = flowDoms(nn,level,sps)%righthanded
        

        
!!$        nViscBocos = flowDoms(nn,groundLevel,sps)%nViscBocos
!!$        nInvBocos  = flowDoms(nn,groundLevel,sps)%nInvBocos
!!$        
!!$        BCFaceID => flowDoms(nn,groundLevel,  1)%BCFaceID
!!$        groupNum => flowDoms(nn,groundLevel,  1)%groupNum
!!$
!!$        d2Wall   => flowDoms(nn,groundLevel,sps)%d2Wall
!!$        muLam    => flowDoms(nn,groundLevel,sps)%muLam
           
!!$        ! Determine the number of time instances for this block and
!!$        ! store the block dimensions a bit easier.
!!$        
!!$        sectionID = flowDoms(nn,level,1)%sectionID
!!$        nTime     = sections(sectionID)%nTimeInstances
!!$
!!$        print *,'Pointers set',sectionID,nTime
!!$        stop
!!$        
!!$        il = flowDoms(nn,level,1)%il
!!$        jl = flowDoms(nn,level,1)%jl
!!$        kl = flowDoms(nn,level,1)%kl
!!$
!!$        
!!$        !Allocate the full grid stencil for the x
!!$        allocate(xAdj(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("verifydCfdx", &
!!$             "Memory allocation failure for xAdj.")
!!$
!!$        allocate(xAdjB(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("verifydCfdx", &
!!$             "Memory allocation failure for xAdjB.")  
!!$
!!$        !Copy the values of x to the Stencil
!!$        call copyADjointForcesStencil(xAdj,level,nn,sps)
 
        print *,'copying stencil'
        ! Copy the coordinates into xAdj and
        ! Compute the face normals on the subfaces
        call copyADjointForcesStencil(wAdj,xAdj,alphaAdj,betaAdj,&
           MachAdj,machCoefAdj,machGridAdj,prefAdj,rhorefAdj, pinfdimAdj,&
           rhoinfdimAdj,rhoinfAdj, pinfAdj,rotRateAdj,rotCenterAdj,murefAdj,&
           timerefAdj,pInfCorrAdj,nn,level,sps,liftIndex)
        
        bocoLoop: do mm=1,nBocos

           ! Determine the range of cell indices of the owned cells
           ! Notice these are not the node indices
           iiBeg = BCData(mm)%icBeg
           iiEnd = BCData(mm)%icEnd
           jjBeg = BCData(mm)%jcBeg
           jjEnd = BCData(mm)%jcEnd
           
           i2Beg= BCData(mm)%inBeg+1; i2End = BCData(mm)%inEnd
           j2Beg= BCData(mm)%jnBeg+1; j2End = BCData(mm)%jnEnd
!!$
!!$        !zero the inviscid and viscous force terms 
!!$
!!$        cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$        cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$        cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$        cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$
!!$        ! Count the number of wall boundary conditions
!!$
!!$        nBocos         = nViscBocos + nInvBocos
!!$        viscousSubface = .true. 
!!$
!!$        ! Loop over the number of boundary conditions for this block.
!!$
!!$
!!$        bocoLoop: do mm=1,nBocos
!!$           
!!$           !set some face dimensions
!!$           i2Beg = flowDoms(nn,level,1)%BCData(mm)%iBeg
!!$           j2Beg = flowDoms(nn,level,1)%BCData(mm)%jBeg
!!$           i2End = flowDoms(nn,level,1)%BCData(mm)%iEnd
!!$           j2End = flowDoms(nn,level,1)%BCData(mm)%jEnd
!!$           
!!$           
!!$           select case (flowDoms(nn,level,1)%BCFaceID(mm))
!!$           case (iMin, iMax)
!!$              if(i2End == jl) i2End = min(jl+1,je)
!!$              if(j2End == kl) j2End = min(kl+1,ke)
!!$              
!!$           case (jMin, jMax)
!!$              if(i2End == il) i2End = min(il+1,ie)
!!$              if(j2End == kl) j2End = min(kl+1,ke)
!!$
!!$           case (kMin, kMax)
!!$              if(i2End == il) i2End = min(il+1,ie)
!!$              if(j2End == jl) j2End = min(jl+1,je)
!!$           end select
!!$           
!!$           ! Determine the nodal range of the owned nodes. Due to block
!!$           ! splitting iBeg and jBeg may correspond to a halo.
!!$           iiBeg = max(i2Beg, 1_intType)
!!$           jjBeg = max(j2Beg, 1_intType)
!!$           iiEnd = i2End
!!$           jjEnd = j2End
!!$
!!$           iiBeg = max(i2Beg, 1_intType)
!!$           jjBeg = max(j2Beg, 1_intType)
!!$           iiEnd = min(i2End, flowDoms(nn,level,1)%BCData(mm)%iEnd)
!!$           jjEnd = min(j2End, flowDoms(nn,level,1)%BCData(mm)%jEnd)
!!$
!!$           
!!$           !Allocate the vector of node normals in the full grid stencil
!!$           allocate(normAdj(iiBeg:iiEnd,jjBeg:jjEnd,3), stat=ierr)
!!$           if(ierr /= 0)                              &
!!$                call terminate("verifydCfdx", &
!!$                "Memory allocation failure for normAdj.")
           
           ! Initialize the seed for reverse mode. Cl is the first one
           ClAdjB = 1
           CDAdjB = 0
           CmxAdjB = 0
           CmyAdjB = 0
           CmzAdjB = 0
           CfxAdjB = 0
           CfyAdjB = 0
           CfzAdjB = 0
           
           xAdjB(:,:,:,:) = zero ! > return dCf/dx
           wAdjB(:,:,:,:) = zero ! > return dCf/dW
           !print *,'calling adjoint forces_b'
           !===============================================================
           !           
           print *,'Initial Parameters Calculated,Computing Lift Partials...'
           
           !===============================================================
           ! Compute the force derivatives
           call  COMPUTEFORCESADJ_B(xadj, xadjb, wadj, wadjb, padj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, cfxadj, cfxadjb&
&  , cfyadj, cfyadjb, cfzadj, cfzadjb, cmxadj, cmxadjb, cmyadj, cmyadjb&
&  , cmzadj, cmzadjb, yplusmax, refpoint, cladj, cladjb, cdadj, cdadjb, &
&  nn, level, sps, cfpadj, cmpadj, righthanded, secondhalo, alphaadj, &
&  alphaadjb, betaadj, betaadjb, machadj, machadjb, machcoefadj, &
&  machcoefadjb, machgridadj, machgridadjb, prefadj, rhorefadj, &
&  pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, murefadj, timerefadj, &
&  pinfcorradj, rotcenteradj, rotrateadj, rotrateadjb, liftindex)


          
           
           do k = 0,kb
              do j = 0,jb
                 do i = 0,ib
                    !do l = 1,nw
                       idxmgb = globalCell(i,j,k)
                       
                       !test = wadjb(i,j,k,l)
                       test = sum(wadjb(i,j,k,:))
                       dJdWlocal(:) = wAdjB(i,j,k,:)
                       !print *,'test',wAdjB(i,j,k,:)!test
                       if ( test.ne.0 .and. idxmgb.ne.-5 .and. idxmgb>=0 .and. idxmgb<nCellsGlobal) then
                          
                          !idxmgb = globalCell(i,j,k)*nw+l-1  !L minus 1 not 1 minus 1
                          !call VecSetValues(dJdW, 1, idxmgb, test, &
                          !  ADD_VALUES, PETScIerr)
                          call VecSetValuesBlocked(dJdW, 1, idxmgb, dJdWlocal, &
                               ADD_VALUES, PETScIerr)
                          
                          if( PETScIerr/=0 ) then
                             write(errorMessage,99) &
                                  "Error in VecSetValuesBlocked for global node", &
                                  idxmgb
                             call terminate("setupADjointRHSAeroCoeff", &
                                  errorMessage)
                          endif
                       endif
                    !enddo
                 enddo
              enddo
           enddo
           
           !loop over cells to store the jacobian
           do k = 0,kb
              do j = 0,jb
                 do i = 0,ib
                    
                    ! Store the dervatives for comparison.
                   
                    dCL(nn,i,j,k,:)=dCL(nn,i,j,k,:)+& 
                         & wAdjB( i,j,k,:)


                 enddo
              enddo
           enddo
        enddo bocoLoop
        bocoLoop2: do mm=1,nBocos

           ! Determine the range of cell indices of the owned cells
           ! Notice these are not the node indices
           iiBeg = BCData(mm)%icBeg
           iiEnd = BCData(mm)%icEnd
           jjBeg = BCData(mm)%jcBeg
           jjEnd = BCData(mm)%jcEnd
           
           i2Beg= BCData(mm)%inBeg+1; i2End = BCData(mm)%inEnd
           j2Beg= BCData(mm)%jnBeg+1; j2End = BCData(mm)%jnEnd
           ! Initialize the seed for reverse mode. Cd second
           ClAdjB = 0
           CDAdjB = 1
           CmxAdjB = 0
           CmyAdjB = 0
           CmzAdjB = 0
!!$        CfxAdjB = 0
!!$        CfyAdjB = 0
!!$        CfzAdjB = 0
       
           xAdjB(:,:,:,:) = zero ! > return dCf/dx
           wAdjB(:,:,:,:) = zero ! > return dCf/dW

           !===============================================================
           !           
!           print *,'Calculating Drag Partials...'
           
           !===============================================================
           ! Compute the force derivatives
            
           call  COMPUTEFORCESADJ_B(xadj, xadjb, wadj, wadjb, padj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, cfxadj, cfxadjb&
&  , cfyadj, cfyadjb, cfzadj, cfzadjb, cmxadj, cmxadjb, cmyadj, cmyadjb&
&  , cmzadj, cmzadjb, yplusmax, refpoint, cladj, cladjb, cdadj, cdadjb, &
&  nn, level, sps, cfpadj, cmpadj, righthanded, secondhalo, alphaadj, &
&  alphaadjb, betaadj, betaadjb, machadj, machadjb, machcoefadj, &
&  machcoefadjb, machgridadj, machgridadjb, prefadj, rhorefadj, &
&  pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, murefadj, timerefadj, &
&  pinfcorradj, rotcenteradj, rotrateadj, rotrateadjb, liftindex)


           
           !loop over cells to store the jacobian
           do k = 0,kb
              do j = 0,jb
                 do i = 0,ib
                    
                    ! Store the derivatives for comparison.
                    
                    dCD(nn,i,j,k,:)=dCD(nn,i,j,k,:)+& 
                         & wAdjB( i,j,k,:)

                 enddo
              enddo
           enddo
        enddo bocoLoop2
        
        bocoLoop3: do mm=1,nBocos

           ! Determine the range of cell indices of the owned cells
           ! Notice these are not the node indices
           iiBeg = BCData(mm)%icBeg
           iiEnd = BCData(mm)%icEnd
           jjBeg = BCData(mm)%jcBeg
           jjEnd = BCData(mm)%jcEnd
           
           i2Beg= BCData(mm)%inBeg+1; i2End = BCData(mm)%inEnd
           j2Beg= BCData(mm)%jnBeg+1; j2End = BCData(mm)%jnEnd
           ! Initialize the seed for reverse mode. Cmx third
           ClAdjB = 0
           CDAdjB = 0
           CmxAdjB = 1
           CmyAdjB = 0
           CmzAdjB = 0
 !       CfxAdjB = 0
 !       CfyAdjB = 0
 !       CfzAdjB = 0
       
           xAdjB(:,:,:,:) = zero ! > return dCf/dx
           wAdjB(:,:,:,:) = zero ! > return dCf/dW


           !===============================================================
           !           
!           print *,'Calculating MomX Partials...'
           
           !===============================================================
           ! Compute the force derivatives
           call COMPUTEFORCESADJ_B(xadj, xadjb, wadj, wadjb, padj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, cfxadj, cfxadjb&
&  , cfyadj, cfyadjb, cfzadj, cfzadjb, cmxadj, cmxadjb, cmyadj, cmyadjb&
&  , cmzadj, cmzadjb, yplusmax, refpoint, cladj, cladjb, cdadj, cdadjb, &
&  nn, level, sps, cfpadj, cmpadj, righthanded, secondhalo, alphaadj, &
&  alphaadjb, betaadj, betaadjb, machadj, machadjb, machcoefadj, &
&  machcoefadjb, machgridadj, machgridadjb, prefadj, rhorefadj, &
&  pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, murefadj, timerefadj, &
&  pinfcorradj, rotcenteradj, rotrateadj, rotrateadjb, liftindex)


           !loop over cells to store the jacobian
           do k = 0,kb
              do j = 0,jb
                 do i = 0,ib
                    
                    ! Store the derivatives for comparison.
                   

                    dCMx(nn,i,j,k,:)=dCMx(nn,i,j,k,:)+& 
                         & wAdjB( i,j,k,:)
                    
                 enddo
              enddo
           enddo
!!$                     
!!$           deallocate(normAdj, stat=ierr)
!!$           if(ierr /= 0)                              &
!!$                call terminate("verifydCfdx", &
!!$                "Deallocation failure for normAdj.") 
           
        enddo bocoLoop3
        
        !===============================================================
        
        !print *,' deallocating'
        ! Deallocate the xAdj.
        deallocate(pAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.")
             
        ! Deallocate the xAdj.
        deallocate(wAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(wAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        ! Deallocate the xAdj.
        deallocate(xAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(xAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        !print *,'finishhed deallocating'
       
      enddo domainLoopAD

   enddo spectralLoopAdj
      
   print *,'AD loop finished'
   !stop
      ! Get new time and compute the elapsed AD time.

      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) then
        call cpu_time(time(2))
        timeAdj = time(2)-time(1)
      endif
!
!     ******************************************************************
!     *                                                                *
!     * Compute d(Cf)/d(x) using central finite-differences.           *
!     *                                                                *
!     ******************************************************************
!
      ! Get the initial FD time.
      
      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) call cpu_time(time(3))

!version using original routines!
      ! Loop over the number of local blocks.
      
      sps=1
      print *,'starting FD loop',sps
      domainForcesLoopFDorig: do nn=1,nDom   
         print *,'Domain: ',nn,nDom
         domain = nn
         call setPointersadj(domain,level,sps)

         !loop over all points
         do k = 0,kb
            print *,'k',k,kb,jb,ib
            do j = 0,jb
              do i = 0,ib
                 !print *,'i=',i,ib
                  do l = 1,nw
                     call setPointersadj(domain,level,sps)
                     wref = w(i,j,k,l)

                     w(i,j,k,l) = wref+deltaw

                     !*************************************************************
                     !Original force and metric calculation....
                     !     ******************************************************************
                     !     *                                                                *
                     !     * Update the force coefficients using the usual flow solver      *
                     !     * routine.                                                       *
                     !     *                                                                *
                     !     ******************************************************************
                     !
 
                     call metric(level)
                     call setPointersadj(domain,level,sps)
                     call computeForcesPressureAdj(w, p)
                     call applyAllBC(secondHalo)
                     call setPointersadj(domain,level,sps)
                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
                     
                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
                          + (cfp(2) + cfv(2))*liftDirection(2) &
                          + (cfp(3) + cfv(3))*liftDirection(3)
                     
                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
                          + (cfp(2) + cfv(2))*dragDirection(2) &
                          + (cfp(3) + cfv(3))*dragDirection(3)
                     
                     Cfx = cfp(1) + cfv(1)
                     Cfy = cfp(2) + cfv(2)
                     Cfz = cfp(3) + cfv(3)
                     
                     Cmx = cmp(1) + cmv(1)
                     Cmy = cmp(2) + cmv(2)
                     Cmz = cmp(3) + cmv(3)
                     
                     nmonsum = 8
                     
                     monLoc1(1) = Cl
                     monLoc1(2) = Cd
                     monLoc1(3) = cfx
                     monLoc1(4) = cfy
                     monLoc1(5) = cfz
                     monLoc1(6) = cmx
                     monLoc1(7) = cmy
                     monLoc1(8) = cmz
                     
!!$                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax, sps)
!!$                     
!!$                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$                          + (cfp(2) + cfv(2))*liftDirection(2) &
!!$                          + (cfp(3) + cfv(3))*liftDirection(3)
!!$                     
!!$                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$                          + (cfp(2) + cfv(2))*dragDirection(2) &
!!$                          + (cfp(3) + cfv(3))*dragDirection(3)
!!$                     
!!$                     Cfx = cfp(1) + cfv(1)
!!$                     Cfy = cfp(2) + cfv(2)
!!$                     Cfz = cfp(3) + cfv(3)
!!$                     
!!$                     Cmx = cmp(1) + cmv(1)
!!$                     Cmy = cmp(2) + cmv(2)
!!$                     Cmz = cmp(3) + cmv(3)
!!$                     
!!$                     nmonsum = 8
!!$                     
!!$                     monLoc(1) = Cl
!!$                     monLoc(2) = Cd
!!$                     monLoc(3) = cfx
!!$                     monLoc(4) = cfy
!!$                     monLoc(5) = cfz
!!$                     monLoc(6) = cmx
!!$                     monLoc(7) = cmy
!!$                     monLoc(8) = cmz
!!$                     
                     
                     ! Determine the global sum of the summation monitoring
                     ! variables. The sum is made known to all processors.
                     
                     call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
                          mpi_sum, SUmb_comm_world, ierr)
                     
                     ! Transfer the cost function values to output arguments.
                     
                     CLp  = monGlob1(1)
                     CDp  = monGlob1(2)
                     Cfxp = monGlob1(3)
                     Cfyp = monGlob1(4)
                     Cfzp = monGlob1(5) 
                     CMxp = monGlob1(6)
                     CMyp = monGlob1(7)
                     CMzp = monGlob1(8)
                     
                     
                     !*********************
                     !Now calculate other perturbation
                     call setPointersadj(domain,level,sps)
                     w(i,j,k,l) = wref-deltaw
                     
                     !*************************************************************
                     !Original force and metric calculation....
                     !     ******************************************************************
                     !     *                                                                *
                     !     * Update the force coefficients using the usual flow solver      *
                     !     * routine.                                                       *
                     !     *                                                                *
                     !     ******************************************************************
                     !
  
                     call metric(level)
                     call setPointersadj(domain,level,sps)
                     call computeForcesPressureAdj(w, p)
                     call applyAllBC(secondHalo)
                     call setPointersadj(domain,level,sps)
                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
                     
                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
                          + (cfp(2) + cfv(2))*liftDirection(2) &
                          + (cfp(3) + cfv(3))*liftDirection(3)
                     
                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
                          + (cfp(2) + cfv(2))*dragDirection(2) &
                          + (cfp(3) + cfv(3))*dragDirection(3)
                     
                     Cfx = cfp(1) + cfv(1)
                     Cfy = cfp(2) + cfv(2)
                     Cfz = cfp(3) + cfv(3)
                     
                     Cmx = cmp(1) + cmv(1)
                     Cmy = cmp(2) + cmv(2)
                     Cmz = cmp(3) + cmv(3)
                     
                     nmonsum = 8
                     
                     monLoc2(1) = Cl
                     monLoc2(2) = Cd
                     monLoc2(3) = cfx
                     monLoc2(4) = cfy
                     monLoc2(5) = cfz
                     monLoc2(6) = cmx
                     monLoc2(7) = cmy
                     monLoc2(8) = cmz
                  
!!$                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax, sps)
!!$                     
!!$                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$                          + (cfp(2) + cfv(2))*liftDirection(2) &
!!$                          + (cfp(3) + cfv(3))*liftDirection(3)
!!$                     
!!$                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$                          + (cfp(2) + cfv(2))*dragDirection(2) &
!!$                          + (cfp(3) + cfv(3))*dragDirection(3)
!!$                     
!!$                     Cfx = cfp(1) + cfv(1)
!!$                     Cfy = cfp(2) + cfv(2)
!!$                     Cfz = cfp(3) + cfv(3)
!!$                     
!!$                     Cmx = cmp(1) + cmv(1)
!!$                     Cmy = cmp(2) + cmv(2)
!!$                     Cmz = cmp(3) + cmv(3)
!!$                     
!!$                     nmonsum = 8
!!$                     
!!$                     monLoc(1) = Cl
!!$                     monLoc(2) = Cd
!!$                     monLoc(3) = cfx
!!$                     monLoc(4) = cfy
!!$                     monLoc(5) = cfz
!!$                     monLoc(6) = cmx
!!$                     monLoc(7) = cmy
!!$                     monLoc(8) = cmz
                     
                     
                     ! Determine the global sum of the summation monitoring
                     ! variables. The sum is made known to all processors.
                     
                     call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
                          mpi_sum, SUmb_comm_world, ierr)
                     
                     ! Transfer the cost function values to output arguments.
                     
                     CLm  = monGlob2(1)
                     CDm  = monGlob2(2)
                     Cfxm = monGlob2(3)
                     Cfym = monGlob2(4)
                     Cfzm = monGlob2(5) 
                     CMxm = monGlob2(6)
                     CMym = monGlob2(7)
                     CMzm = monGlob2(8)
                     
                     call setPointersadj(domain,level,sps)
                     w(i,j,k,l) = wref
                  

                     dCLdwFD = (CLP-CLM)/(two*deltaw)  
                    dCDdwFD = (CDP-CDM)/(two*deltaw) 
                    dCmxdwFD = (CmxP-CmxM)/(two*deltaw) 

                    dCLFD(nn,i,j,k,l)=dCLdwFD

                    dCDFD(nn,i,j,k,l)=dCDdwFD
                    
                    dCmxFD(nn,i,j,k,l)=dCmxdwFD
                    idxmgb   = globalCell(i,j,k)*nw+l
                    if( idxmgb>=0) then
                       write (unit,11) dCLdwFD,nn,i,j,k,l,idxmgb
11                     format(1x,'wcl ',f18.10,6I8)
                    endif
                    dJdWlocal(l) = dCLdwFD
                    
!!$                    idxmgb = globalCell(i,j,k)
!!$                    
!!$                    test = dCLdwFD
!!$                    !print *,'test',test
!!$                    if ( test.ne.0 .and. idxmgb.ne.-5 .and. idxmgb>=0 .and. idxmgb<nCellsGlobal) then
!!$                      
!!$                       idxmgb = globalCell(i,j,k)*nw+l-1  !L minus 1 not 1 minus 1
!!$                       call VecSetValues(dJdW, 1, idxmgb, dCLdwFD, &
!!$                                                ADD_VALUES, PETScIerr)
!!$       !                 call VecSetValuesBlocked(dJdW, 1, idxmgb, dJdWlocal, &
!!$       !                      ADD_VALUES, PETScIerr)
!!$            
!!$                        if( PETScIerr/=0 ) then
!!$                           write(errorMessage,99) &
!!$                                "Error in VecSetValuesBlocked for global node", &
!!$                                idxmgb
!!$                           call terminate("setupADjointRHSAeroCoeff", &
!!$                                errorMessage)
!!$                        endif
!!$                     endif

                    enddo
                    
!!$                    idxmgb = globalCell(i,j,k)
!!$                    
!!$                    test = sum(dJdWlocal(:))
!!$                    if ( test.ne.0 .and. idxmgb.ne.-5 .and. idxmgb>=0 .and. idxmgb<nCellsGlobal) then
!!$                      
!!$                       call VecSetValuesBlocked(dJdW, 1, idxmgb, dJdWlocal, &
!!$                            ADD_VALUES, PETScIerr)
!!$            
!!$                        if( PETScIerr/=0 ) then
!!$                           write(errorMessage,99) &
!!$                                "Error in VecSetValuesBlocked for global node", &
!!$                                idxmgb
!!$                           call terminate("setupADjointRHSAeroCoeff", &
!!$                                errorMessage)
!!$                        endif
!!$                     endif
                 enddo
              enddo
           enddo
        enddo domainForcesLoopFDorig
        print *,'finished fd'
!
!     ******************************************************************
!     *                                                                *
!     * Complete the PETSc vector assembly process.                    *
!     *                                                                *
!     ******************************************************************
!
      call VecAssemblyBegin(dJdW,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupASjointRHS", "Error in VecAssemblyBegin")

      call VecAssemblyEnd  (dJdW,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointRHS", "Error in VecAssemblyEnd")

!!$      ! Get new time and compute the elapsed time.
!!$
!!$      call cpu_time(time(2))
!!$      time(3) = time(2)-time(1)
!!$
!!$      ! Determine the maximum time using MPI reduce
!!$      ! with operation mpi_max.
!!$
!!$      call mpi_reduce(time(3), timeAdj, 1, sumb_real, &
!!$                      mpi_max, 0, SUMB_PETSC_COMM_WORLD, PETScIerr)
      print *,'n'
      if( PETScRank==0 ) &
        write(*,25) "Assembling ADjoint RHS vector..."
      if( PETScRank==0 ) &
        write(*,25) "Assembling ADjoint RHS vector time (s) = ", timeAdj
25    format(a,1x,f8.2)
      !if( debug ) then
	!call VecView(dJdW,PETSC_VIEWER_DRAW_WORLD,PETScIerr)
	call VecView(dJdW,PETSC_VIEWER_STDOUT_WORLD,PETScIerr)
        if( PETScIerr/=0 ) &
          call terminate("setupADjointRHS", "Error in VecView")
        !pause
      !endif
!!$      !from ForcesAndMoments.f90
!!$       ! Determine the reference point for the moment computation in
!!$       ! meters.
!!$
!!$       refPoint(1) = LRef*pointRef(1)
!!$       refPoint(2) = LRef*pointRef(2)
!!$       refPoint(3) = LRef*pointRef(3)
!!$
!!$       ! Initialize the force and moment coefficients to 0 as well as
!!$       ! yplusMax.
!!$
!!$!!!$       cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$!!!$       cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$!!!$       cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$!!!$       cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$!
!!$!***********************************
!!$
!!$      ! Loop over the number of local blocks.
!!$
!!$      domainForcesLoopFD: do nn=1,nDom   
!!$
!!$        ! Set some pointers to make the code more readable.
!!$
!!$        call setPointersAdj(nn,level,sps)
!!$
!!$        nViscBocos = flowDoms(nn,groundLevel,sps)%nViscBocos
!!$        nInvBocos  = flowDoms(nn,groundLevel,sps)%nInvBocos
!!$        BCFaceID => flowDoms(nn,groundLevel,  1)%BCFaceID
!!$        groupNum => flowDoms(nn,groundLevel,  1)%groupNum
!!$
!!$        d2Wall   => flowDoms(nn,groundLevel,sps)%d2Wall
!!$        muLam    => flowDoms(nn,groundLevel,sps)%muLam
!!$           
!!$!!!$        ! Determine the number of time instances for this block and
!!$!!!$        ! store the block dimensions a bit easier.
!!$!!!$        
!!$!!!$        sectionID = flowDoms(nn,level,1)%sectionID
!!$!!!$        nTime     = sections(sectionID)%nTimeInstances
!!$!!!$
!!$        
!!$        il = flowDoms(nn,level,1)%il
!!$        jl = flowDoms(nn,level,1)%jl
!!$        kl = flowDoms(nn,level,1)%kl
!!$
!!$        allocate(xAdj(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$           if(ierr /= 0)                              &
!!$                call terminate("boundarySurfaceNormals", &
!!$                            "Memory allocation failure for xAdj.")
!!$
!!$        call copyADjointForcesStencil(xAdj,level,nn,sps)
!!$        
!!$     
!!$        nBocos         = nViscBocos + nInvBocos
!!$        viscousSubface = .true.
!!$        
!!$        !loop over cells to store the jacobian
!!$        do l = 1,3
!!$           do k = kb,ke
!!$              do j = jb,je
!!$                 do i = ib,ie
!!$                    !zero the forces
!!$                    cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$                    cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$                    cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$                    cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$                    
!!$                    
!!$                    ClAdjP = 0
!!$                    CDAdjP = 0
!!$                    CmxAdjP = 0
!!$                    CmyAdj = 0
!!$                    CmzAdj = 0
!!$                    CfxAdj = 0
!!$                    CfyAdj = 0
!!$                    CfzAdj = 0
!!$                    
!!$                    yplusMax = zero
!!$                    
!!$                    ! Store baseline x.
!!$                    
!!$                    xAdjRef = xAdj(i,j,k,l)
!!$                    
!!$                    ! Perturb x (forward) and compute dx.
!!$                    
!!$                    xAdj(i,j,k,l) = xAdjRef + deltax
!!$                    
!!$                    bocoLoop1: do mm=1,nBocos!flowDoms(nn,level,1)%nBocos
!!$                    
!!$                       
!!$                       i2Beg = flowDoms(nn,level,1)%BCData(mm)%iBeg
!!$                       j2Beg = flowDoms(nn,level,1)%BCData(mm)%jBeg
!!$                       i2End = flowDoms(nn,level,1)%BCData(mm)%iEnd
!!$                       j2End = flowDoms(nn,level,1)%BCData(mm)%jEnd
!!$                       
!!$
!!$                       select case (flowDoms(nn,level,1)%BCFaceID(mm))
!!$                       case (iMin, iMax)
!!$                          if(i2End == jl) i2End = min(jl+1,je)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (jMin, jMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (kMin, kMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == jl) j2End = min(jl+1,je)
!!$                       end select
!!$                       
!!$
!!$                       ! Determine the nodal range of the owned cells. Due to block
!!$                       ! splitting iBeg and jBeg may correspond to a halo.
!!$!!!$                       iiBeg = max(i2Beg, 1_intType)
!!$!!!$                       jjBeg = max(j2Beg, 1_intType)
!!$!!!$                       iiEnd = i2End
!!$!!!$                       jjEnd = j2End   
!!$                       iiBeg = max(i2Beg, 1_intType)
!!$                       jjBeg = max(j2Beg, 1_intType)
!!$                       iiEnd = min(i2End, flowDoms(nn,level,1)%BCData(mm)%iEnd)
!!$                       jjEnd = min(j2End, flowDoms(nn,level,1)%BCData(mm)%jEnd)
!!$
!!$                 
!!$                       allocate(normAdj(iiBeg:iiEnd,jjBeg:jjEnd,3), stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Memory allocation failure for normAdj.")
!!$                       
!!$                       !======================================================
!!$                       ! Compute the forces.
!!$                       
!!$                       call computeForcesAdj(level,i2Beg,j2Beg,i2End,j2End,iiBeg,&
!!$                            & jjBeg,iiEnd,jjEnd,xAdj,mm,cFxAdj, cFyAdj, cFzAdj, cMxAdjP,&
!!$                            & cMyAdj,cMzAdj, yplusMax, refPoint, sps, CLAdjP, CDAdjP, nn,&
!!$                            & CfpAdj,cMpAdj,cFvAdj, cMvAdj)
!!$                       
!!$ 
!!$                       ! Release the memory of normAdj again.
!!$                       
!!$                       deallocate(normAdj, stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Deallocation failure for normAdj.") 
!!$                       
!!$                    enddo bocoLoop1
!!$
!!$                    !zero the forces
!!$                    cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$                    cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$                    cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$                    cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$
!!$                    ClAdjM = 0
!!$                    CDAdjM = 0
!!$                    CmxAdjM = 0
!!$                    CmyAdj = 0
!!$                    CmzAdj = 0
!!$                    CfxAdj = 0
!!$                    CfyAdj = 0
!!$                    CfzAdj = 0
!!$                    
!!$                    ! Perturb x (backward) and compute dx.
!!$                    
!!$                    xAdj(i,j,k,l) = xAdjRef - deltax
!!$                    
!!$                    bocoLoop2: do mm=1,nBocos!flowDoms(nn,level,1)%nBocos
!!$                       !       print *,'In bocoloop...',mm
!!$                       
!!$                       
!!$                       i2Beg = flowDoms(nn,level,1)%BCData(mm)%iBeg
!!$                       j2Beg = flowDoms(nn,level,1)%BCData(mm)%jBeg
!!$                       i2End = flowDoms(nn,level,1)%BCData(mm)%iEnd
!!$                       j2End = flowDoms(nn,level,1)%BCData(mm)%jEnd
!!$       
!!$                       select case (flowDoms(nn,level,1)%BCFaceID(mm))
!!$                       case (iMin, iMax)
!!$                          if(i2End == jl) i2End = min(jl+1,je)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (jMin, jMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (kMin, kMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == jl) j2End = min(jl+1,je)
!!$                       end select
!!$    
!!$                       ! Determine the nodal range of the owned cells. Due to block
!!$                       ! splitting iBeg and jBeg may correspond to a halo.
!!$!!!$                       iiBeg = max(i2Beg, 1_intType)
!!$!!!$                       jjBeg = max(j2Beg, 1_intType)
!!$!!!$                       iiEnd = i2End
!!$!!!$                       jjEnd = j2End
!!$
!!$                       iiBeg = max(i2Beg, 1_intType)
!!$                       jjBeg = max(j2Beg, 1_intType)
!!$                       iiEnd = min(i2End, flowDoms(nn,level,1)%BCData(mm)%iEnd)
!!$                       jjEnd = min(j2End, flowDoms(nn,level,1)%BCData(mm)%jEnd)
!!$
!!$                       allocate(normAdj(iiBeg:iiEnd,jjBeg:jjEnd,3), stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Memory allocation failure for normAdj.")
!!$                       
!!$                       !======================================================
!!$                       ! Compute the forces.
!!$                       
!!$                       call computeForcesAdj(level,i2Beg,j2Beg,i2End,j2End,iiBeg,&
!!$                            & jjBeg,iiEnd,jjEnd,xAdj,mm,cFxAdj, cFyAdj, cFzAdj, cMxAdjM,&
!!$                            & cMyAdj,cMzAdj, yplusMax, refPoint, sps, CLAdjM, CDAdjM, nn,&
!!$                            & CfpAdj,cMpAdj,cFvAdj, cMvAdj)
!!$                       
!!$ 
!!$                       ! Release the memory of normAdj again.
!!$                       
!!$                       deallocate(normAdj, stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Deallocation failure for normAdj.") 
!!$                       
!!$                    enddo bocoLoop2
!!$
!!$                    xAdj(i,j,k,l) = xAdjRef
!!$
!!$
!!$                    dCLdxFD = (CLAdjP-CLAdjM)/(two*deltax)  
!!$                    dCDdxFD = (CDAdjP-CDAdjM)/(two*deltax) 
!!$                    dCmxdxFD = (CmxAdjP-CmxAdjM)/(two*deltax) 
!!$
!!$                    dCLFD(nn,i,j,k,l)=dCLdxFD
!!$
!!$                    dCDFD(nn,i,j,k,l)=dCDdxFD
!!$                    
!!$                    dCmxFD(nn,i,j,k,l)=dCmxdxFD
!!$                    
!!$ 
!!$                 enddo
!!$              enddo
!!$           enddo
!!$        enddo
!!$        deallocate(xAdj, stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("boundarySurfaceNormals", &
!!$             "Deallocation failure for xAdj.") 
!!$     enddo domainForcesLoopFD

  
      ! Get new time and compute the elapsed FD time.

      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) then
        call cpu_time(time(4))
        timeFD = time(4)-time(3)
      endif
!
!     ******************************************************************
!     *                                                                *
!     * Output debug information.                                      *
!     *                                                                *
!     ******************************************************************
!
      ! Output debug information.

      domainDebugLoop: do nn=1,nDom

        ! Set the variables, which are related to the dimensions of the
        ! block. In this way the dimensions of the automatic arrays used
        ! in the flux routines are set a bit easier.
         !print *,'setting pointers',nn,level,sps
         call setPointers(nn,level,sps)
!!$
!!$        il = flowDoms(nn,currentLevel,1)%il
!!$        jl = flowDoms(nn,currentLevel,1)%jl
!!$        kl = flowDoms(nn,currentLevel,1)%kl

        ! Loop over the location of the output cell.

        do kCell=0,kb
          do jCell=0,jb
            do iCell=0,ib

              ! Relative error

              do n=1,nw

                 !if ( dCL(nn,iCell,jCell,kCell,n) < 1e-10 ) then
                 if ( dCLfd(nn,iCell,jCell,kCell,n) < 1e-10 ) then
                    dCLer(nn,iCell,jCell,kCell,n)  = zero
                 else
                    dCLer(nn,iCell,jCell,kCell,n)  =                   &
                         (  dCL(nn,iCell,jCell,kCell,n)      &
                         - dCLfd(nn,iCell,jCell,kCell,n) )  &
                         /  dCLfd(nn,iCell,jCell,kCell,n)
                 endif
                 
                 if ( dCD(nn,iCell,jCell,kCell,n) < 1e-10 ) then
                    dCDer(nn,iCell,jCell,kCell,n)  = zero
                 else
                    dCDer(nn,iCell,jCell,kCell,n)  =                   &
                         (  dCD(nn,iCell,jCell,kCell,n)      &
                         - dCDfd(nn,iCell,jCell,kCell,n) )  &
                         /  dCD(nn,iCell,jCell,kCell,n)
                 endif
                 
                 if ( dCmx(nn,iCell,jCell,kCell,n) < 1e-10 ) then
                    dCmxer(nn,iCell,jCell,kCell,n)  = zero
                 else
                    dCmxer(nn,iCell,jCell,kCell,n)  =                   &
                         (  dCmx(nn,iCell,jCell,kCell,n)      &
                         - dCmxfd(nn,iCell,jCell,kCell,n) )  &
                         /  dCmx(nn,iCell,jCell,kCell,n)
                 endif
                 
              enddo
              
              ! Output if error

              write(*,10) "Jacobian dCLer,dCL,dCLfd @ proc/block", &
                    myID, nn, "for cell", iCell,jCell,kCell
              do m=1,nw
                 if (dCLer(nn,iCell,jCell,kCell,m)/=0)          &
                  write(*,20) (dCLer(nn,iCell,jCell,kCell,m)), &
                              (dCL(nn,iCell,jCell,kCell,m)),   &
                              (dCLfd(nn,iCell,jCell,kCell,m))
              enddo
              write(*,10) "Jacobian dCDer,dCD,dCDfd @ proc/block", &
                   myID, nn, "for cell", iCell,jCell,kCell
              do m=1,nw
                 if (dCDer(nn,iCell,jCell,kCell,m)/=0)          &
                      write(*,20) (dCDer(nn,iCell,jCell,kCell,m)), &
                      (dCD(nn,iCell,jCell,kCell,m)),   &
                      (dCDfd(nn,iCell,jCell,kCell,m))
              enddo
              
              write(*,10) "Jacobian dCmxer,dCmx,dCmxfd @ proc/block", &
                   myID, nn, "for cell", iCell,jCell,kCell
              do m=1,nw
                 if (dCmxer(nn,iCell,jCell,kCell,m)/=0)          &
                      write(*,20) (dCmxer(nn,iCell,jCell,kCell,m)), &
                      (dCmx(nn,iCell,jCell,kCell,m)),   &
                      (dCmxfd(nn,iCell,jCell,kCell,m))
              enddo
              
           enddo
        enddo
     enddo
     
  enddo domainDebugLoop
  
  ! Flush the output buffer and synchronize the processors.
  
  call f77flush()
  call mpi_barrier(SUmb_comm_world, ierr)
  
  ! Output elapsed time for the adjoint and FD computations.
  
  if( myID==0 ) then
     print *, "====================================================="
     print *, " Time for reverse mode       =", timeAdj
     print *, " Time for finite differences =", timeFD
     print *, " Factor                      =", timeFD/timeAdj
     print *, "====================================================="
  endif

!
!     ******************************************************************
!     *                                                                *
!     * Compute the errors in dCf/dx.                                   *
!     *                                                                *
!     ******************************************************************
!
      write(*,*)
      write(*,30) "dCLer : proc, min/loc, max/loc =", myID,          &
                 minval(dCLer(:,:,:,:,:)), minloc(dCLer(:,:,:,:,:)), &
                 maxval(dCLer(:,:,:,:,:)), maxloc(dCLer(:,:,:,:,:))
      write(*,30) "dCDer : proc, min/loc, max/loc =", myID,          &
                 minval(dCDer(:,:,:,:,:)), minloc(dCDer(:,:,:,:,:)), &
                 maxval(dCDer(:,:,:,:,:)), maxloc(dCDer(:,:,:,:,:))
      write(*,30) "dCmxer : proc, min/loc, max/loc =", myID,          &
                 minval(dCmxer(:,:,:,:,:)), minloc(dCmxer(:,:,:,:,:)), &
                 maxval(dCmxer(:,:,:,:,:)), maxloc(dCmxer(:,:,:,:,:))

      ! Flush the output buffer and synchronize the processors.

      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
!
!     ******************************************************************
!
      deallocate(monLoc1, monGlob1)
      deallocate(monLoc2, monGlob2)
      
      ! Deallocate memory for the temporary arrays.
      !print *,'deallocating dcl'
      deallocate(dCl,  dCLfd,  dCLer)
      deallocate(dCD,  dCDfd,  dCDer)
      deallocate(dCmx, dCmxfd, dCmxer)
      !print *,'finished deallocating dcl'
  
      ! Output formats.

  10  format(1x,a,1x,i3,1x,i3,1x,a,1x,i3,1x,i3,1x,i3)           
  20  format(1x,(e18.6),2x,(e18.6),2x,(e18.6))
  30  format(1x,a,1x,i3,2x,e13.6,1x,5(i2,1x),3x,e13.6,1x,5(i2,1x))
  99  format(a,1x,i6)
#endif
    end subroutine verifydCfdw
