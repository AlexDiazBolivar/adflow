!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of computetsstabilityderivadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: cdadj dcldalpha
!                cladj cl0 dcddalpha cmzadj dcmzdalpha cd0 cmz0
!   of linear combination of output variables: dcldalpha cl0 dcddalpha
!                dcmzdalpha cd0 cmz0
!
!     ******************************************************************
!     *                                                                *
!     * File:          computeTSStabilityDerivAdj.f90                  *
!     * Author:        C.A.(Sandy) Mader                               *
!     * Starting date: 11-25-2009                                      *
!     * Last modified: 11-26-2009                                      *
!     *                                                                *
!     ******************************************************************
!
SUBROUTINE COMPUTETSSTABILITYDERIVADJ_B(cfxadj, cfyadj, cfzadj, cmxadj, &
&  cmyadj, cmzadj, cmzadjb, cladj, cladjb, cdadj, cdadjb, cl0, cl0b, cd0&
&  , cd0b, cmz0, cmz0b, dcldalpha, dcldalphab, dcddalpha, dcddalphab, &
&  dcmzdalpha, dcmzdalphab)
  USE communication
  USE inputmotion
  USE inputphysics
  USE inputtimespectral
  USE inputtsstabderiv
  USE monitor
  USE section
  IMPLICIT NONE
  REAL(KIND=REALTYPE) :: cd0, cd0b, cl0, cl0b, cmz0, cmz0b
  REAL(KIND=REALTYPE) :: cdadj(ntimeintervalsspectral), cdadjb(&
&  ntimeintervalsspectral), cfxadj(ntimeintervalsspectral), cfyadj(&
&  ntimeintervalsspectral), cfzadj(ntimeintervalsspectral), cladj(&
&  ntimeintervalsspectral), cladjb(ntimeintervalsspectral), cmxadj(&
&  ntimeintervalsspectral), cmyadj(ntimeintervalsspectral), cmzadj(&
&  ntimeintervalsspectral), cmzadjb(ntimeintervalsspectral)
  REAL(KIND=REALTYPE) :: dcddalpha, dcddalphab, dcldalpha, dcldalphab, &
&  dcmzdalpha, dcmzdalphab
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: cd0dot, cl0dot, cmz0dot
  REAL(KIND=REALTYPE) :: dcddalphadot, dcldalphadot, dcmzdalphadot
  REAL(KIND=REALTYPE) :: dcddq, dcddqb, dcddqdot, dcldq, dcldqb, &
&  dcldqdot, dcmzdq, dcmzdqb, dcmzdqdot
  REAL(KIND=REALTYPE) :: dcddr, dcddrb, dcddrdot, dcldr, dcldrb, &
&  dcldrdot, dcmzdr, dcmzdrb, dcmzdrdot
  REAL(KIND=REALTYPE) :: dcddmach, dcddmachb, dcddmachdot, dcldmach, &
&  dcldmachb, dcldmachdot, dcmzdmach, dcmzdmachb, dcmzdmachdot
  REAL(KIND=REALTYPE) :: dcddp, dcddpb, dcddpdot, dcldp, dcldpb, &
&  dcldpdot, dcmzdp, dcmzdpb, dcmzdpdot
  REAL(KIND=REALTYPE) :: DERIVATIVERIGIDROTANGLE, res, res0, res1, &
&  SECONDDERIVATIVERIGIDROTANGLE
  REAL(KIND=REALTYPE) :: dphix(ntimeintervalsspectral), dphiy(&
&  ntimeintervalsspectral), dphiz(ntimeintervalsspectral)
  REAL(KIND=REALTYPE) :: dphixdot(ntimeintervalsspectral), dphiydot(&
&  ntimeintervalsspectral), dphizdot(ntimeintervalsspectral)
  REAL(KIND=REALTYPE) :: intervalalpha(ntimeintervalsspectral), &
&  intervalalphadot(ntimeintervalsspectral)
  REAL(KIND=REALTYPE) :: intervalmach(ntimeintervalsspectral), &
&  intervalmachdot(ntimeintervalsspectral)
  INTEGER(KIND=INTTYPE) :: i, nn, sps
  REAL(KIND=REALTYPE) :: rescd(ntimeintervalsspectral), rescfx(&
&  ntimeintervalsspectral), rescfy(ntimeintervalsspectral), rescfz(&
&  ntimeintervalsspectral), rescl(ntimeintervalsspectral), rescmx(&
&  ntimeintervalsspectral), rescmy(ntimeintervalsspectral), rescmz(&
&  ntimeintervalsspectral)
  REAL(KIND=REALTYPE) :: t(nsections)
  REAL(KIND=REALTYPE) :: res2, TSALPHA, TSALPHADOT
  REAL(KIND=REALTYPE) :: res3, result1, TSMACH, TSMACHDOT
  EXTERNAL TSALPHA, TSMACHDOT, DERIVATIVERIGIDROTANGLE, TSMACH, &
&      TSALPHADOT, SECONDDERIVATIVERIGIDROTANGLE, TERMINATE
!Given
  IF (tspmode) THEN
!P is roll
    DO sps=1,ntimeintervalsspectral
!compute the time of this interval
      t = timeunsteadyrestart
      IF (equationmode .EQ. timespectral) THEN
        DO nn=1,nsections
!t(nn) = t(nn) + (sps-1)*sections(nn)%timePeriod &
!     /         real(nTimeIntervalsSpectral,realType)
          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&            ntimeintervalsspectral*1.0)
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
! Compute the time derivative of the rotation angles around the
! x-axis. i.e. compute p
      dphix(sps) = DERIVATIVERIGIDROTANGLE(degreepolxrot, coefpolxrot, &
&        degreefourxrot, omegafourxrot, coscoeffourxrot, sincoeffourxrot&
&        , t)
!if(myID==0)print *,'dphix',dphix
!add in pdot computation here!
      res = SECONDDERIVATIVERIGIDROTANGLE(degreepolxrot, coefpolxrot, &
&        degreefourxrot, omegafourxrot, coscoeffourxrot, sincoeffourxrot&
&        , t)
    END DO
!now compute dCl/dp
    CALL COMPUTELEASTSQUARESREGRESSION(cladj, dphix, &
&                                 ntimeintervalsspectral, dcldp, cl0)
!now compute dCd/dp
    CALL COMPUTELEASTSQUARESREGRESSION(cdadj, dphix, &
&                                 ntimeintervalsspectral, dcddp, cd0)
!now compute dCmz/dp
    dcmzdpb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cmzadj, cmzadjb, dphix, &
&                                   ntimeintervalsspectral, dcmzdp, &
&                                   dcmzdpb, cmz0, cmz0b)
    dcddpb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cdadj, cdadjb, dphix, &
&                                   ntimeintervalsspectral, dcddp, &
&                                   dcddpb, cd0, cd0b)
    dcldpb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cladj, cladjb, dphix, &
&                                   ntimeintervalsspectral, dcldp, &
&                                   dcldpb, cl0, cl0b)
    DO sps=ntimeintervalsspectral,1,-1
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) nn = 0
    END DO
  ELSE IF (tsqmode) THEN
!q is pitch
    DO sps=1,ntimeintervalsspectral
!compute the time of this interval
      t = timeunsteadyrestart
      IF (equationmode .EQ. timespectral) THEN
        DO nn=1,nsections
!t(nn) = t(nn) + (sps-1)*sections(nn)%timePeriod &
!     /         real(nTimeIntervalsSpectral,realType)
          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&            ntimeintervalsspectral*1.0)
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
! Compute the time derivative of the rotation angles around the
! z-axis. i.e. compute q
      dphiz(sps) = DERIVATIVERIGIDROTANGLE(degreepolzrot, coefpolzrot, &
&        degreefourzrot, omegafourzrot, coscoeffourzrot, sincoeffourzrot&
&        , t)
!if(myID==0)print *,'dphiz',dphiz
! add in q_dot computation
      res0 = SECONDDERIVATIVERIGIDROTANGLE(degreepolzrot, coefpolzrot, &
&        degreefourzrot, omegafourzrot, coscoeffourzrot, sincoeffourzrot&
&        , t)
    END DO
!now compute dCl/dq
    CALL COMPUTELEASTSQUARESREGRESSION(cladj, dphiz, &
&                                 ntimeintervalsspectral, dcldq, cl0)
!now compute dCd/dq
    CALL COMPUTELEASTSQUARESREGRESSION(cdadj, dphiz, &
&                                 ntimeintervalsspectral, dcddq, cd0)
!now compute dCmz/dq
    dcmzdqb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cmzadj, cmzadjb, dphiz, &
&                                   ntimeintervalsspectral, dcmzdq, &
&                                   dcmzdqb, cmz0, cmz0b)
    dcddqb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cdadj, cdadjb, dphiz, &
&                                   ntimeintervalsspectral, dcddq, &
&                                   dcddqb, cd0, cd0b)
    dcldqb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cladj, cladjb, dphiz, &
&                                   ntimeintervalsspectral, dcldq, &
&                                   dcldqb, cl0, cl0b)
    DO sps=ntimeintervalsspectral,1,-1
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) nn = 0
    END DO
  ELSE IF (tsrmode) THEN
!r is yaw
    DO sps=1,ntimeintervalsspectral
!compute the time of this interval
      t = timeunsteadyrestart
      IF (equationmode .EQ. timespectral) THEN
        DO nn=1,nsections
!t(nn) = t(nn) + (sps-1)*sections(nn)%timePeriod &
!     /         real(nTimeIntervalsSpectral,realType)
          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&            ntimeintervalsspectral*1.0)
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
! Compute the time derivative of the rotation angles around the
! y-axis and z-axis. i.e. compute r
      dphiy(sps) = DERIVATIVERIGIDROTANGLE(degreepolyrot, coefpolyrot, &
&        degreefouryrot, omegafouryrot, coscoeffouryrot, sincoeffouryrot&
&        , t)
!if(myID==0)print *,'dphiy',dphiy
! add in r_dot computation
      res1 = SECONDDERIVATIVERIGIDROTANGLE(degreepolyrot, coefpolyrot, &
&        degreefouryrot, omegafouryrot, coscoeffouryrot, sincoeffouryrot&
&        , t)
    END DO
!now compute dCl/dr
    CALL COMPUTELEASTSQUARESREGRESSION(cladj, dphiy, &
&                                 ntimeintervalsspectral, dcldr, cl0)
!now compute dCD/dr
    CALL COMPUTELEASTSQUARESREGRESSION(cdadj, dphiy, &
&                                 ntimeintervalsspectral, dcddr, cd0)
!now compute dCmz/dr
    dcmzdrb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cmzadj, cmzadjb, dphiy, &
&                                   ntimeintervalsspectral, dcmzdr, &
&                                   dcmzdrb, cmz0, cmz0b)
    dcddrb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cdadj, cdadjb, dphiy, &
&                                   ntimeintervalsspectral, dcddr, &
&                                   dcddrb, cd0, cd0b)
    dcldrb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cladj, cladjb, dphiy, &
&                                   ntimeintervalsspectral, dcldr, &
&                                   dcldrb, cl0, cl0b)
    DO sps=ntimeintervalsspectral,1,-1
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) nn = 0
    END DO
  ELSE IF (tsalphamode) THEN
!compute the alphas and alphadots
    DO sps=1,ntimeintervalsspectral
!compute the time of this interval
      t = timeunsteadyrestart
      IF (equationmode .EQ. timespectral) THEN
        DO nn=1,nsections
!t(nn) = t(nn) + (sps-1)*sections(nn)%timePeriod &
!     /         real(nTimeIntervalsSpectral,realType)
          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&            ntimeintervalsspectral*1.0)
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      intervalalpha(sps) = TSALPHA(degreepolalpha, coefpolalpha, &
&        degreefouralpha, omegafouralpha, coscoeffouralpha, &
&        sincoeffouralpha, t)
      res2 = TSALPHADOT(degreepolalpha, coefpolalpha, degreefouralpha, &
&        omegafouralpha, coscoeffouralpha, sincoeffouralpha, t)
    END DO
!now compute dCl/dalpha
    CALL COMPUTELEASTSQUARESREGRESSION(cladj, intervalalpha, &
&                                 ntimeintervalsspectral, dcldalpha, cl0&
&                                )
!now compute dCd/dalpha
    CALL COMPUTELEASTSQUARESREGRESSION(cdadj, intervalalpha, &
&                                 ntimeintervalsspectral, dcddalpha, cd0&
&                                )
!now compute dCmz/dq
    CALL COMPUTELEASTSQUARESREGRESSION_B(cmzadj, cmzadjb, intervalalpha&
&                                   , ntimeintervalsspectral, dcmzdalpha&
&                                   , dcmzdalphab, cmz0, cmz0b)
    CALL COMPUTELEASTSQUARESREGRESSION_B(cdadj, cdadjb, intervalalpha, &
&                                   ntimeintervalsspectral, dcddalpha, &
&                                   dcddalphab, cd0, cd0b)
    CALL COMPUTELEASTSQUARESREGRESSION_B(cladj, cladjb, intervalalpha, &
&                                   ntimeintervalsspectral, dcldalpha, &
&                                   dcldalphab, cl0, cl0b)
    DO sps=ntimeintervalsspectral,1,-1
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) nn = 0
    END DO
  ELSE IF (tsmachmode) THEN
!compute the alphas and alphadots
    DO sps=1,ntimeintervalsspectral
!compute the time of this interval
      t = timeunsteadyrestart
      IF (equationmode .EQ. timespectral) THEN
        DO nn=1,nsections
!t(nn) = t(nn) + (sps-1)*sections(nn)%timePeriod &
!     /         real(nTimeIntervalsSpectral,realType)
          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&            ntimeintervalsspectral*1.0)
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      result1 = TSMACH(degreepolmach, coefpolmach, degreefourmach, &
&        omegafourmach, coscoeffourmach, sincoeffourmach, t)
      intervalmach(sps) = machgrid + result1
      res3 = TSMACHDOT(degreepolmach, coefpolmach, degreefourmach, &
&        omegafourmach, coscoeffourmach, sincoeffourmach, t)
    END DO
!now compute dCl/dalpha
    CALL COMPUTELEASTSQUARESREGRESSION(cladj, intervalmach, &
&                                 ntimeintervalsspectral, dcldmach, cl0)
!now compute dCd/dalpha
    CALL COMPUTELEASTSQUARESREGRESSION(cdadj, intervalmach, &
&                                 ntimeintervalsspectral, dcddmach, cd0)
!now compute dCmz/dq
    dcmzdmachb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cmzadj, cmzadjb, intervalmach, &
&                                   ntimeintervalsspectral, dcmzdmach, &
&                                   dcmzdmachb, cmz0, cmz0b)
    dcddmachb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cdadj, cdadjb, intervalmach, &
&                                   ntimeintervalsspectral, dcddmach, &
&                                   dcddmachb, cd0, cd0b)
    dcldmachb = 0.0
    CALL COMPUTELEASTSQUARESREGRESSION_B(cladj, cladjb, intervalmach, &
&                                   ntimeintervalsspectral, dcldmach, &
&                                   dcldmachb, cl0, cl0b)
    DO sps=ntimeintervalsspectral,1,-1
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) nn = 0
    END DO
  ELSE
    cdadjb(1:ntimeintervalsspectral) = 0.0
    cladjb(1:ntimeintervalsspectral) = 0.0
    cmzadjb(1:ntimeintervalsspectral) = 0.0
  END IF
  dcldalphab = 0.0
  cl0b = 0.0
  dcddalphab = 0.0
  dcmzdalphab = 0.0
  cd0b = 0.0
  cmz0b = 0.0
END SUBROUTINE COMPUTETSSTABILITYDERIVADJ_B
