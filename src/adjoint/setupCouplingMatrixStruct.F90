!     ******************************************************************
!     *                                                                *
!     * File:          setupCouplingMatrixStruct.f90                   *
!     * Author:        C.A.(Sandy) Mader                               *
!     * Starting date: 08-18-2008                                      *
!     * Last modified: 08-18-2008                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine setupCouplingMatrixStruct(pts,npts)
  !
  !     ******************************************************************
  !     *                                                                *
  !     * Compute all entries in dSdw (partial) using the automatically  *
  !     * differentiated routines generated by Tapenade and store        *
  !     * them in PETSc                                                  *
  !     *                                                                *
  !     ******************************************************************
  !
  use adjointpetsc        
  use adjointVars         !nCellsGlobal
  use blockPointers
  use communication       ! procHalo(currentLevel)%nProcSend, myID
  use inputPhysics        ! equations
  use flowVarRefState     ! nw
  use inputDiscretization ! spaceDiscr, useCompactDiss
  use bcTypes             !imin,imax,jmin,jmax,kmin,kmax

  implicit none

  ! Subroutine Arguments

  real(kind=realType), intent(in) :: pts(3,npts)
  integer(kind=intType),intent(in):: npts

  integer(kind=intType) :: i,j,k,ii,jj,kk,iii,jjj,kkk,idim,l,irow
  integer(kind=intType) :: rowStart,rowEnd
  integer(kind=intType) :: nn,mm,sps
  real(kind=realType)   :: force(3),forceb(3)
  real(kind=realType)   :: wAdj(2,2,2,nw),wAdjb(2,2,2,nw)
  real(kind=realType)   :: grid_pts(3,3,3),grid_ptsb(3,3,3)
  integer(kind=intType) :: pts_ind(3,3),w_ind(2,2,2)
  integer(kind=intType) :: iBeg,jBeg,iEnd,jEnd,iStride,jStride
  integer(kind=intType) :: lower_left,lower_right,upper_left,upper_right
  integer(kind=intType) :: colStart_x,colEnd_x
  real(kind=realType)   :: fact
  integer(kind=intType) :: ierr
  logical :: rightHanded

  ii=0
  call MatGetOwnershipRange(dsdw,rowStart,rowEnd,ierr)
  call MatGetOwnershipRangeColumn(dsdx,colStart_x,colEnd_x,ierr)

  domains: do nn=1,nDom
     call setPointersAdj(nn,1_intType,1_intType)

     rightHanded = flowDoms(nn,1_intType,1_intType)%rightHanded

     bocos: do mm=1,nBocos
        if(BCType(mm) == EulerWall.or.BCType(mm) == NSWallAdiabatic .or.&
             BCType(mm) == NSWallIsothermal) then
           jBeg = BCData(mm)%jnBeg ; jEnd = BCData(mm)%jnEnd
           iBeg = BCData(mm)%inBeg ; iEnd = BCData(mm)%inEnd
           iStride = iEnd-iBeg+1
           jStride = jEnd-jBeg+1

           
           do j=jBeg,jEnd
              do i=iBeg,iEnd
                
                 grid_pts(:,:,:) = 0.0
                 wAdj(:,:,:,:)   = 0.0
                 pts_ind(:,:) = -1_intTYpe
                 do iii =1,2
                    do jjj=1,2
                       if (.not.(i+iii-2 < iBeg .or. i+iii-1 > iEnd .or. &
                            j+jjj-2 < jBeg .or. j+jjj-1 > jEnd)) then
 
                          lower_left  = ii + iii + (jjj-1)*iStride-istride-1
                          lower_right = ii + iii + (jjj-1)*iStride-istride
                          upper_left  = ii + iii + (jjj  )*iStride-istride-1
                          upper_right = ii + iii + (jjj  )*iStride-istride

                          grid_pts(:,iii  ,jjj  ) = pts(:,lower_left)
                          grid_pts(:,iii+1,jjj  ) = pts(:,lower_right)
                          grid_pts(:,iii  ,jjj+1) = pts(:,upper_left)
                          grid_pts(:,iii+1,jjj+1) = pts(:,upper_right)
                          pts_ind (iii  ,jjj  ) = lower_left -1
                          pts_ind (iii+1,jjj  ) = lower_right-1
                          pts_ind (iii  ,jjj+1) = upper_left -1
                          pts_ind (iii+1,jjj+1) = upper_right-1
                       end if
                    end do
                 end do

                 ! Copy over the states

                 select case (BCFaceID(mm))
                 case (iMin)
                    fact = -1_realType
                    do kkk=1,2
                       wadj(kkk,1,1,:) = w(kkk+1,i  ,j  ,:)
                       wadj(kkk,2,1,:) = w(kkk+1,i+1,j  ,:)
                       wadj(kkk,1,2,:) = w(kkk+1,i  ,j+1,:)
                       wadj(kkk,2,2,:) = w(kkk+1,i+1,j+1,:)
                       w_ind(kkk,1,1)  = globalCell(kkk+1,i  ,j  ) 
                       w_ind(kkk,2,1)  = globalCell(kkk+1,i+1,j  ) 
                       w_ind(kkk,1,2)  = globalCell(kkk+1,i  ,j+1) 
                       w_ind(kkk,2,2)  = globalCell(kkk+1,i+1,j+1) 
                    end do
                 case (iMax)
                    fact = 1_realType
                    do kkk=1,2
                       wadj(kkk,1,1,:) = w(ib-kkk-1,i  ,j  ,:)
                       wadj(kkk,2,1,:) = w(ib-kkk-1,i+1,j  ,:)
                       wadj(kkk,1,2,:) = w(ib-kkk-1,i  ,j+1,:)
                       wadj(kkk,2,2,:) = w(ib-kkk-1,i+1,j+1,:)
                       w_ind(kkk,1,1)  = globalCell(ib-kkk-1,i  ,j  ) 
                       w_ind(kkk,2,1)  = globalCell(ib-kkk-1,i+1,j  ) 
                       w_ind(kkk,1,2)  = globalCell(ib-kkk-1,i  ,j+1) 
                       w_ind(kkk,2,2)  = globalCell(ib-kkk-1,i+1,j+1) 
                    end do
                 case (jMin)
                    fact = -1_realType
                    do kkk=1,2
                       wadj(kkk,1,1,:) = w(i  ,kkk+1,j  ,:)
                       wadj(kkk,2,1,:) = w(i+1,kkk+1,j  ,:)
                       wadj(kkk,1,2,:) = w(i  ,kkk+1,j+1,:)
                       wadj(kkk,2,2,:) = w(i+1,kkk+1,j+1,:)
                       w_ind(kkk,1,1)  = globalCell(i  ,kkk+1,j  )
                       w_ind(kkk,2,1)  = globalCell(i+1,kkk+1,j  )
                       w_ind(kkk,1,2)  = globalCell(i  ,kkk+1,j+1)
                       w_ind(kkk,2,2)  = globalCell(i+1,kkk+1,j+1)
                    end do
                 case (jMax)
                    fact = 1_realType
                    do kkk=1,2
                       wadj(kkk,1,1,:) = w(i  ,jb-kkk-1,j  ,:)
                       wadj(kkk,2,1,:) = w(i+1,jb-kkk-1,j  ,:)
                       wadj(kkk,1,2,:) = w(i  ,jb-kkk-1,j+1,:)
                       wadj(kkk,2,2,:) = w(i+1,jb-kkk-1,j+1,:)
                       w_ind(kkk,1,1)  = globalCell(i  ,jb-kkk-1,j  ) 
                       w_ind(kkk,2,1)  = globalCell(i+1,jb-kkk-1,j  ) 
                       w_ind(kkk,1,2)  = globalCell(i  ,jb-kkk-1,j+1) 
                       w_ind(kkk,2,2)  = globalCell(i+1,jb-kkk-1,j+1) 
                    end do
                 case (kMin)
                    fact = -1_realType
                    do kkk=1,2
                       wadj(kkk,1,1,:) = w(i  ,j  ,kkk+1,:)
                       wadj(kkk,2,1,:) = w(i+1,j  ,kkk+1,:)
                       wadj(kkk,1,2,:) = w(i  ,j+1,kkk+1,:)
                       wadj(kkk,2,2,:) = w(i+1,j+1,kkk+1,:)
                       w_ind(kkk,1,1)  = globalCell(i  ,j  ,kkk+1) 
                       w_ind(kkk,2,1)  = globalCell(i+1,j  ,kkk+1) 
                       w_ind(kkk,1,2)  = globalCell(i  ,j+1,kkk+1) 
                       w_ind(kkk,2,2)  = globalCell(i+1,j+1,kkk+1) 
                    end do
                 case (kMax)
                    fact = 1_realType
                    do kkk=1,2
                       wadj(kkk,1,1,:) = w(i  ,j  ,kb-kkk-1,:)
                       wadj(kkk,2,1,:) = w(i+1,j  ,kb-kkk-1,:)
                       wadj(kkk,1,2,:) = w(i  ,j+1,kb-kkk-1,:)
                       wadj(kkk,2,2,:) = w(i+1,j+1,kb-kkk-1,:)
                       w_ind(kkk,1,1)  = globalCell(i  ,j  ,kb-kkk-1) 
                       w_ind(kkk,2,1)  = globalCell(i+1,j  ,kb-kkk-1) 
                       w_ind(kkk,1,2)  = globalCell(i  ,j+1,kb-kkk-1) 
                       w_ind(kkk,2,2)  = globalCell(i+1,j+1,kb-kkk-1) 
                    end do
                 end select

                 ! Call the reverse mode AD routine

                 do idim =1,3
                    forceb(:)    = 0.0_realType
                    forceb(idim) = 1.0_realType
                    force = 0.0
                    grid_ptsb = 0.0
                    wadjb = 0.0

                    call COMPUTEFORCECOUPLINGADJ_B(force, forceb, grid_pts, &
                         grid_ptsb, wadj, wadjb, fact, ibeg, iend, jbeg, jend, &
                         i, j, righthanded)
               
                    ! Set dSdw first
                    irow = rowStart + ii*3+idim-1

                    do l=1,nw                   
                       do kkk=1,2
                          do iii=1,2
                             do jjj=1,2
                                if (.not.(i+iii-2 < iBeg .or. i+iii-1 > iEnd .or. &
                                     j+jjj-2 < jBeg .or. j+jjj-1 > jEnd)) then
                                   
                                   call MatSetValue(dSdw,irow,&
                                        w_ind(kkk,iii,jjj)*nw+l-1,&
                                        wadjb(kkk,iii,jjj,l),&
                                        INSERT_VALUES, ierr)
                                end if
                             end do
                          end do
                       end do
                    end do
                    ! Now Set dSdx
                    do jjj=1,3
                       do iii=1,3
                          do kkk=1,3
                             call MatSetValue(dSdx,irow,&
                                  colStart_x+pts_ind(iii,jjj)*3+kkk-1,grid_ptsb(kkk,iii,jjj),&
                                  INSERT_VALUES,ierr)
                          end do
                       end do
                    end do

                 end do ! idim loop
                
                 ii = ii + 1
              enddo
           end do
        end if
     end do bocos
  end do domains

  call MatAssemblyBegin(dSdw,MAT_FINAL_ASSEMBLY,ierr)
  call MatAssemblyEnd(dSdw,MAT_FINAL_ASSEMBLY,ierr)
  call MatAssemblyBegin(dSdx,MAT_FINAL_ASSEMBLY,ierr)
  call MatAssemblyEnd(dSdx,MAT_FINAL_ASSEMBLY,ierr)

    
end subroutine setupCouplingMatrixStruct

