!
!     ******************************************************************
!     *                                                                *
!     * File:          setupADjointMatrix.F90                          *
!     * Author:        Andre C. Marta, C.A.(Sandy) Mader               *
!     * Starting date: 07-27-2006                                      *
!     * Last modified: 06-09-2008                                      *
!     *                                                                *
!     ******************************************************************
!
      subroutine setupADjointMatrix(level)
!
!     ******************************************************************
!     *                                                                *
!     * Compute the matrix dRdW of the discrete ADjoint problem for    *
!     * subsequent use by the solveADjointPETSc subroutine. The entries*
!     * in dRdw are obtained using the automatically differentiated    *
!     * routines generated by Tapenade.                                *
!     *                                                                *
!     * The ordering of the unknowns in the ADjoint matrix used here   *
!     * is based on the global node numbering and is consistent with   *
!     * the ordering used in the vector for the ADjoint problem        *
!     * assembled in setupADjointRHS.                                  *
!     *                                                                *
!     ******************************************************************
!
      use ADjointPETSc
      use ADjointVars ! nCellsGlobal, nCellsLocal, nOffsetLocal
      use blockPointers       ! i/j/kl/b/e, i/j/k/Min/MaxBoundaryStencil
      use cgnsGrid            ! cgnsDoms
      use communication       ! procHalo(currentLevel)%nProcSend
      use inputDiscretization ! spaceDiscr
      use iteration           ! overset, currentLevel
      use flowVarRefState     ! nw
      use inputTimeSpectral ! spaceDiscr	
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level
!
!     Local variables.
!
      integer(kind=intType) :: discr, nHalo
      integer(kind=intType) :: iCell, jCell, kCell
      integer(kind=intType) :: mm, nn, m, n
      integer(kind=intType) :: ii, jj, kk, i, j, k,liftIndex

      logical :: fineGrid, correctForK, exchangeTurb,secondhalo

      real(kind=realType), dimension(-2:2,-2:2,-2:2,nw) :: wAdj, wAdjB
      real(kind=realType), dimension(-3:2,-3:2,-3:2,3)  :: xAdj, xAdjB

      real(kind=realType), dimension(nw) :: dwAdj, dwAdjB

      REAL(KIND=REALTYPE) :: machadj, machcoefadj, uinfadj, pinfcorradj
      REAL(KIND=REALTYPE) :: machadjb, machcoefadjb
      REAL(KIND=REALTYPE) :: prefadj, rhorefadj
      REAL(KIND=REALTYPE) :: pinfdimadj, rhoinfdimadj
      REAL(KIND=REALTYPE) :: rhoinfadj, pinfadj
      REAL(KIND=REALTYPE) :: murefadj, timerefadj
      REAL(KIND=REALTYPE) :: alphaadj, betaadj
      REAL(KIND=REALTYPE) :: alphaadjb, betaadjb

      integer(kind=intType), dimension(0:nProc-1) :: offsetRecv

      real(kind=realType), dimension(2) :: time
      real(kind=realType)               :: timeAdjLocal, timeAdj

      ! dR/dw stencil

      real(kind=realType), dimension(nw,nw) :: Aad, Bad, BBad, &
                   Cad, CCad, Dad, DDad, Ead, EEad, Fad, FFad, Gad, GGad

      ! idxmgb - global block row index
      ! idxngb - global block column index

      integer(kind=intType) :: idxmgb, idxngb,ierr, sps

      ! idxmgb - array of global row indices
      ! idxngb - array of global column indices

      integer(kind=intType), dimension(nw) :: idxmg, idxng
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
#ifndef USE_NO_PETSC

      ! Set the grid level of the current MG cycle, the value of the
      ! discretization and the logical correctForK.

      currentLevel = level
      !discr        = spaceDiscr
      fineGrid     = .true.

      ! Determine whether or not the total energy must be corrected
      ! for the presence of the turbulent kinetic energy and whether
      ! or not turbulence variables should be exchanged.

      if( kPresent ) then
         if((currentLevel <= groundLevel) .or. turbCoupled) then
            correctForK = .true.
         else
            correctForK = .false.
         endif
      else
         correctForK = .false.
      endif

      exchangeTurb = .false.

      ! Set the value of secondHalo, depending on the situation.
      ! In the full MG (currentLevel < groundLevel) the second halo is
      ! always set; otherwise only on the finest mesh in the current mg
      ! cycle.

      if(currentLevel <= groundLevel) then
         secondHalo = .true.
      else
         secondHalo = .false.
      endif

!
!     ******************************************************************
!     *                                                                *
!     * Exchange halo data to make sure it is up-to-date.              *
!     * (originally called inside "rungeKuttaSmoother" subroutine).    *
!     *                                                                *
!     ******************************************************************
!
      ! Exchange the pressure if the pressure must be exchanged early.
      ! Only the first halo's are needed, thus whalo1 is called.
      ! Only on the fine grid.
      
      if(exchangePressureEarly .and. currentLevel <= groundLevel) &
           call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
           .false., .false.)
      
      ! Apply all boundary conditions to all blocks on this level.
     
      call applyAllBC(secondHalo)
      
      ! Exchange the solution. Either whalo1 or whalo2
      ! must be called.
      
      if( secondHalo ) then
         call whalo2(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      else
         call whalo1(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      endif

      ! Reset the values of rkStage and currentLevel, such that
      ! they correspond to a new iteration.

      rkStage = 0
      currentLevel = groundLevel
 
!
!     ******************************************************************
!     *                                                                *
!     * Compute the ADjoint matrix dR/dW using Tapenade's reverse mode *
!     * of Automatic Differentiation.  NOTE: This is the reason I have *
!     * been writing the word "ADjoint" with A and D capitalized. A    *
!     * simple play with letter so that:                               *
!     *                                                                *
!     * ADjoint = Automatically Differentiated adjoint                 *
!     *                                                                *
!     ******************************************************************
!
      ! Send some feedback to screen.

      if( PETScRank==0 ) &
        write(*,10) "Assembling ADjoint matrix..."
 
      call mpi_barrier(SUmb_comm_world, ierr)
      if( myID==0 ) call cpu_time(time(1))
      
      !print *,'Entering Domain loop'
      domainLoopAD: do nn=1,nDom
         
         ! Loop over the number of time instances for this block.

         spectralLoop: do sps=1,nTimeIntervalsSpectral
         !print *,'Setting Pointers',nn,level,sps
         call setPointersAdj(nn,level,sps)
		
         do kCell = 2, kl
           do jCell = 2, jl
              do iCell = 2, il
                 ! Copy the state w to the wAdj array in the stencil
                 call copyADjointStencil(wAdj, xAdj,alphaAdj,betaAdj,MachAdj,&
                          machCoefAdj,iCell, jCell, kCell,prefAdj,&
                          rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
                          rhoinfAdj, pinfAdj,&
                          murefAdj, timerefAdj,pInfCorrAdj,liftIndex)
		!call copyADjointStencil(wAdj, xAdj, iCell, jCell, kCell)
		!print *,'wAdj',wadj

	        Aad(:,:)  = zero
                Bad(:,:)  = zero
                BBad(:,:) = zero
                Cad(:,:)  = zero
                CCad(:,:) = zero
                Dad(:,:)  = zero
                DDad(:,:) = zero
                Ead(:,:)  = zero
                EEad(:,:) = zero
                Fad(:,:)  = zero
                FFad(:,:) = zero
                Gad(:,:)  = zero
                GGad(:,:) = zero

                 mLoop: do m = 1, nw      ! Loop over output cell residuals (R)
!                   print *,'initializing variables'
                    ! Initialize the seed for the reverse mode
                    dwAdjb(:) = 0.
		    dwAdjb(m) = 1.
                    dwAdj(:)  = 0.
                    wAdjb(:,:,:,:)  = 0.  !dR(m)/dw
		    alphaadjb = 0.
	            betaadjb = 0.
		    machadjb = 0.
!                    print *,'dwadjb',dwadjb,'wadjb',wadjb(0,0,0,:)
  !                 print *,'calling reverse mode'
!                   print *,'secondhalo',secondhalo

	        ! Call the reverse mode of residual computation.
                !
                !                          dR(iCell,jCell,kCell,l)
                ! wAdjb(ii,jj,kk,n) = --------------------------------
                !                     dW(iCell+ii,jCell+jj,kCell+kk,n)

                    ! Call reverse mode of residual computation
                    call COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, dwadj, dwadjb, &
&  alphaadj, alphaadjb, betaadj, betaadjb, machadj, machadjb, &	
&  machcoefadj, icell, jcell, kcell, nn, sps, correctfork, secondhalo, &
&  prefadj, rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, &
&  murefadj, timerefadj, pinfcorradj, liftindex)
!(wadj, wadjb, xadj, xadjb, dwadj,&
!			  &  dwadjb, alphaadj, alphaadjb, betaadj, betaadjb,&
!	                  &  machadj, machadjb, machcoefadj, icell, jcell,&
!                          &  kcell, nn, sps, correctfork, secondhalo, prefadj,&
!                          &  rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj,&
!                          &  pinfadj, murefadj, timerefadj, pinfcorradj,&
!			  &liftIndex)

                    ! Store the block Jacobians (by rows).

                Aad(m,:)  = wAdjB( 0, 0, 0,:)
                Bad(m,:)  = wAdjB(-1, 0, 0,:)
                BBad(m,:) = wAdjB(-2, 0, 0,:)
                Cad(m,:)  = wAdjB( 1, 0, 0,:)
                CCad(m,:) = wAdjB( 2, 0, 0,:)
                Dad(m,:)  = wAdjB( 0,-1, 0,:)
                DDad(m,:) = wAdjB( 0,-2, 0,:)
                Ead(m,:)  = wAdjB( 0, 1, 0,:)
                EEad(m,:) = wAdjB( 0, 2, 0,:)
                Fad(m,:)  = wAdjB( 0, 0,-1,:)
                FFad(m,:) = wAdjB( 0, 0,-2,:)
                Gad(m,:)  = wAdjB( 0, 0, 1,:)
                GGad(m,:) = wAdjB( 0, 0, 2,:)

               enddo mLoop
	
              !*********************************************************
              !                                                        *
              ! Transfer the block Jacobians to the PETSc matrix.      *
              ! For the off-diagonal blocks, take into account halo    *
              ! nodes at the boundaries, if present.                   *
              !                                                        *
              ! This depends on the type of the PETsc matrix dRdW,     *
              ! whether is blocked or not.                             *
              !                                                        *
              !*********************************************************

              ! >>> block sparse matrix -> use MatSetValuesBlocked

              ! When using the block compressed sparse row matrix format
              ! (MATSEQBAIJ or MATMPIBAIJ), one can insert elements more
              ! efficiently using the block variant MatSetValuesBlocked.
              !
              ! MatSetValuesBlocked - Inserts or adds a block of values
              !                       into a matrix.
              ! Synopsis
              !
              ! #include "petscmat.h" 
              ! call MatSetValuesBlocked(Mat mat,                      &
              !                  PetscInt m,const PetscInt idxm[],     &
              !                  PetscInt n,const PetscInt idxn[],     &
              !                  const PetscScalar v[],InsertMode addv,&
              !                  PetscErrorCode ierr)
              !
              ! Not Collective
              !
              ! Input Parameters
              !   mat     - the matrix
              !   v       - a logically two-dimensional array of values
              !   m, idxm - the number of block rows and their global
              !             block indices
              !   n, idxn - the number of block columns and their global
              !             block indices
              !   addv    - either ADD_VALUES or INSERT_VALUES, where
              !             ADD_VALUES adds values to any existing
              !             entries, and INSERT_VALUES replaces existing
              !             entries with new values
              ! Notes
              ! The m and n count the NUMBER of blocks in the row
              !   direction and column direction, NOT the total number
              !   of rows/columns; for example, if the block size is 2
              !   and you are passing in values for rows 2,3,4,5 then m
              !   would be 2 (not 4).
              !
              ! By default the values, v, are row-oriented and unsorted.
              !   So the layout of v is the same as for MatSetValues().
              !   See MatSetOption() for other options.
              !
              ! Calls to MatSetValuesBlocked() with the INSERT_VALUES
              !   and ADD_VALUES options cannot be mixed without
              !   intervening calls to the assembly routines.
              !
              ! MatSetValuesBlocked() uses 0-based row and column
              !   numbers in Fortran as well as in C. 
              !
              ! see .../petsc/docs/manualpages/Mat/MatSetValuesBlocked.html

              if(PETScBlockMatrix) then

                ! Global matrix block row mgb function of node indices.
                !
                ! MatSetValuesBlocked() uses 0-based row and column 
                ! numbers but the global node numbering already accounts
                ! for that since it starts at node 0.

                idxmgb = globalCell(iCell,jCell,kCell)
		!print *,'globalcell',idxmgb,globalCell(iCell,jCell,kCell)
                ! >>> center block A < W(i,j,k)

                idxngb = idxmgb
		!print *,'indicies0',idxmgb,idxngb
                call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                         Aad, INSERT_VALUES,PETScIerr)
                if( PETScIerr/=0 ) &
                  call errAssemb("MatSetValuesBlocked", "Aad")

                ! >>> west block B < W(i-1,j,k)
	
                if( (iCell-1) >= 0 ) then
                  idxngb = globalCell(iCell-1,jCell,kCell)
	          if (idxngb >=0 .and. idxngb.ne.-5) then
		     !print *,'indiciesi-1',idxmgb,idxngb
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                           Bad, INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                        call errAssemb("MatSetValuesBlocked", "Bad")
		  endif
                endif

                ! far west block BB < W(i-2,j,k)

                if( (iCell-2) >= 0 ) then
                  idxngb = globalCell(iCell-2,jCell,kCell)
		  if (idxngb >=0 .and. idxngb.ne.-5) then
		     !print *,'indiciesi-2',idxmgb,idxngb
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              BBad,INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "BBad")
                  endif
                end if

                ! >>> east block C < W(i+1,j,k)

                if( (iCell+1) <= ib ) then
                  idxngb = globalCell(iCell+1,jCell,kCell)
		  !print *,'ncellsglobal',ncellsglobal,globalcell(13,5,5)
		  !stop
		  if (idxngb<nCellsGlobal .and. idxngb.ne.-5) then
                      call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              Cad, INSERT_VALUES,PETScIerr)
                      if( PETScIerr/=0 ) &
                        call errAssemb("MatSetValuesBlocked", "Cad")
		  endif
                end if

                ! >>> far east block CC < W(i+2,j,k)

                if( (iCell+2) <= ib ) then
                  idxngb = globalCell(iCell+2,jCell,kCell)
	          if (idxngb<nCellsGlobal .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              CCad,INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                        call errAssemb("MatSetValuesBlocked", "CCad")
		  endif
                end if

                ! >>> south block D < W(i,j-1,k)

                if( (jCell-1) >= 0 ) then
                  idxngb = globalCell(iCell,jCell-1,kCell)
		  if (idxngb>=0 .and. idxngb.ne.-5) then
                      call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                               Dad, INSERT_VALUES,PETScIerr)
                      if( PETScIerr/=0 ) &
                         call errAssemb("MatSetValuesBlocked", "Dad")
	  	  endif
                endif

                ! >>> far south block DD < W(i,j-2,k)

                if( (jCell-2) >= 0 ) then
                  idxngb = globalCell(iCell,jCell-2,kCell)
		  if (idxngb>=0 .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              DDad,INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "DDad")
	 	  endif
                end if

                ! >>> north block E < W(i,j+1,k)

                if( (jCell+1) <= jb ) then
                  idxngb = globalCell(iCell,jCell+1,kCell)
                  if (idxngb<nCellsGlobal .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              Ead, INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "Ead")
		  endif
                end if

                ! >>> far north block EE < W(i,j+2,k)

                if( (jCell+2) <= jb ) then
                  idxngb = globalCell(iCell,jCell+2,kCell)
		  if (idxngb<nCellsGlobal .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              EEad,INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "EEad")
	          endif
                end if

                ! >>> back block F < W(i,j,k-1)

                if( (kCell-1) >= 0 ) then
                  idxngb = globalCell(iCell,jCell,kCell-1)
                  if (idxngb>=0 .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              Fad, INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "Fad")
		  endif
                endif

                ! >>> far back block FF < W(i,j,k-2)

                if( (kCell-2) >= 0 ) then
                  idxngb = globalCell(iCell,jCell,kCell-2)
		  if (idxngb>=0 .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              FFad,INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "FFad")
		  endif
                end if

                ! >>> front block G < W(i,j,k+1)

                if( (kCell+1) <= kb ) then
                  idxngb = globalCell(iCell,jCell,kCell+1)
 		  if (idxngb<nCellsGlobal .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              Gad, INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "Gad")
		  endif
                end if

                ! >>> far front block GG < W(i,j,k+2)

                if( (kCell+2) <= kb ) then
                  idxngb = globalCell(iCell,jCell,kCell+2)
		  if (idxngb<nCellsGlobal .and. idxngb.ne.-5) then
                     call MatSetValuesBlocked(dRdW, 1, idxmgb, 1, idxngb, &
                                              GGad,INSERT_VALUES,PETScIerr)
                     if( PETScIerr/=0 ) &
                       call errAssemb("MatSetValuesBlocked", "GGad")
		  endif
                end if



              ! >>> sparse matrix -> use MatSetValues

              ! MatSetValues - Inserts or adds a block of values into a
              !                matrix. These values may be cached, so
              !                MatAssemblyBegin() and MatAssemblyEnd()
              !                MUST be called after all calls to 
              !                MatSetValues() have been completed.
              !
              ! Synopsis
              !
              ! #include "petscmat.h" 
              ! call MatSetValues(Mat mat,                             &
              !                PetscInt m,const PetscInt idxm[],       &
              !                PetscInt n,const PetscInt idxn[],       &
              !                const PetscScalar v[], InsertMode addv, &
              !                PetscErrorCodeierr)
              !
              ! Not Collective
              !
              ! Input Parameters
              !   mat     - the matrix
              !   v       - a logically two-dimensional array of values
              !   m, idxm - the number of rows and their global indices
              !   n, idxn - the number of columns and their global indices
              !   addv    - either ADD_VALUES or INSERT_VALUES, where
              !             ADD_VALUES adds values to any existing
              !             entries, and INSERT_VALUES replaces existing
              !             entries with new values
              !
              ! Notes
              ! By default the values, v, are row-oriented and unsorted.
              !   See MatSetOption() for other options.
              !
              ! Calls to MatSetValues() with the INSERT_VALUES
              !   and ADD_VALUES options cannot be mixed without
              !   intervening calls to the assembly routines.
              !
              ! MatSetValues() uses 0-based row and column
              !   numbers in Fortran as well as in C.
              !
              ! Efficiency Alert
              ! The routine MatSetValuesBlocked() may offer much better
              ! efficiency for users of block sparse formats
              ! (MATSEQBAIJ and MATMPIBAIJ).
              !
              ! see .../petsc/docs/manualpages/Mat/MatSetValues.html
              !
              !*********************************************************

              else ! PETScBlockMatrix
		stop
                ! Global matrix block row mgb function of node indices.
                !
                ! MatSetValues() uses 0-based row and column 
                ! numbers but the global node numbering already accounts
                ! for that since it starts at node 0.

                idxmgb = globalCell(iCell,jCell,kCell)
                call blockIndices(idxmgb, idxmg)

                ! >>> center block A < W(i,j,k)

                idxngb = idxmgb
                call blockIndices(idxngb, idxng)

                call MatSetValues(dRdW, nw, idxmg, nw, idxng,  &
                                  Aad, INSERT_VALUES, PETScIerr)
                if( PETScIerr/=0 ) &
                  call errAssemb("MatSetValues", "Aad")

                ! >>> west block B < W(i-1,j,k)

                if( (iCell-1) >= ib ) then
                  idxngb = globalCell(iCell-1,jCell,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,  &
                                    Bad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "Bad")
                endif

                ! far west block BB < W(i-2,j,k)

                if( (iCell-2) >= ib ) then
                  idxngb = globalCell(iCell-2,jCell,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,   &
                                    BBad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "BBad")
                end if

                ! >>> east block C < W(i+1,j,k)

                if( (iCell+1) <= ie ) then
                  idxngb = globalCell(iCell+1,jCell,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,  &
                                    Cad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "Cad")
                end if

                ! >>> far east block CC < W(i+2,j,k)

                if( (iCell+2) <= ie ) then
                  idxngb = globalCell(iCell+2,jCell,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,   &
                                    CCad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "CCad")
                end if

                ! >>> south block D < W(i,j-1,k)

                if( (jCell-1) >= jb ) then
                  idxngb = globalCell(iCell,jCell-1,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,  &
                                    Dad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "Dad")
                endif

                ! >>> far south block DD < W(i,j-2,k)

                if( (jCell-2) >= jb ) then
                  idxngb = globalCell(iCell,jCell-2,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,   &
                                    DDad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "DDad")
                end if

                ! >>> north block E < W(i,j+1,k)

                if( (jCell+1) <= je ) then
                  idxngb = globalCell(iCell,jCell+1,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,  &
                                    Ead, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "Ead")
                end if

                ! >>> far north block EE < W(i,j+2,k)

                if( (jCell+2) <= je ) then
                  idxngb = globalCell(iCell,jCell+2,kCell)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,   &
                                    EEad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "EEad")
                end if

                ! >>> back block F < W(i,j,k-1)

                if( (kCell-1) >= kb ) then
                  idxngb = globalCell(iCell,jCell,kCell-1)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,  &
                                    Fad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "Fad")
                endif

                ! >>> far back block FF < W(i,j,k-2)

                if( (kCell-2) >= kb ) then
                  idxngb = globalCell(iCell,jCell,kCell-2)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,   &
                                    FFad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "FFad")
                end if

                ! >>> front block G < W(i,j,k+1)

                if( (kCell+1) <= ke ) then
                  idxngb = globalCell(iCell,jCell,kCell+1)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,  &
                                    Gad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "Gad")
                end if

                ! >>> far front block GG < W(i,j,k+2)

                if( (kCell+2) <= ke ) then
                  idxngb = globalCell(iCell,jCell,kCell+2)
                  call blockIndices(idxngb, idxng)

                  call MatSetValues(dRdW, nw, idxmg, nw, idxng,   &
                                    GGad, INSERT_VALUES, PETScIerr)
                  if( PETScIerr/=0 ) &
                    call errAssemb("MatSetValues", "GGad")
                end if

   

              endif ! PETScBlockMatrix

	
            enddo
          enddo 
        enddo 

      enddo spectralLoop
        !===============================================================

      enddo domainLoopad
!
!     ******************************************************************
!     *                                                                *
!     * Complete the PETSc matrix assembly process.                    *
!     *                                                                *
!     ******************************************************************
!
      ! MatAssemblyBegin - Begins assembling the matrix. This routine
      !  should be called after completing all calls to MatSetValues().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyBegin(Mat mat, &
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      ! Notes
      ! MatSetValues() generally caches the values. The matrix is ready
      !  to use only after MatAssemblyBegin() and MatAssemblyEnd() have
      !  been called. Use MAT_FLUSH_ASSEMBLY when switching between
      !  ADD_VALUES and INSERT_VALUES in MatSetValues(); use
      !  MAT_FINAL_ASSEMBLY for the final assembly before using the
      !  matrix.
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyBegin.html

      call MatAssemblyBegin(dRdW,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrix","Error in MatAssemblyBegin")

      ! MatAssemblyEnd - Completes assembling the matrix. This routine
      !                  should be called after MatAssemblyBegin().
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatAssemblyEnd(Mat mat,&
      !                                            MatAssemblyType type)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat  - the matrix
      !   type - type of assembly, either MAT_FLUSH_ASSEMBLY or
      !          MAT_FINAL_ASSEMBLY
      !
      ! see .../petsc/docs/manualpages/Mat/MatAssemblyEnd.html

      call MatAssemblyEnd  (dRdW,MAT_FINAL_ASSEMBLY,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrix","Error in MatAssemblyEnd")

      ! Let PETSc know that the dRdW matrix retains the same nonzero 
      ! pattern, in case the matrix is assembled again, as for a new
      ! point in the design space.

      ! MatSetOption - Sets a parameter option for a matrix.
      !   Some options may be specific to certain storage formats.
      !   Some options determine how values will be inserted (or added).
      !   Sorted,row-oriented input will generally assemble the fastest.
      !   The default is row-oriented, nonsorted input.
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! call MatSetOption(Mat mat,MatOption op,PetscErrorCode ierr)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat    - the matrix
      !   option - the option, one of those listed below (and possibly
      !     others), e.g., MAT_ROWS_SORTED, MAT_NEW_NONZERO_LOCATION_ERR
      !
      ! see .../petsc/docs/manualpages/Mat/MatSetOption.html
      ! or PETSc users manual, pp.52

      call MatSetOption(dRdW,MAT_NO_NEW_NONZERO_LOCATIONS,PETScIerr)

      if( PETScIerr/=0 ) &
        call terminate("setupADjointMatrix", "Error in MatSetOption")

      ! Get new time and compute the elapsed time.

      call cpu_time(time(2))
      timeAdjLocal = time(2)-time(1)

      ! Determine maximum time using MPI reduce
      ! with operation mpi_max.

      call mpi_reduce(timeAdjLocal, timeAdj, 1, sumb_real, &
                      mpi_max, 0, PETSC_COMM_WORLD, PETScIerr)

      if( PETScRank==0 ) &
        write(*,20) "Assembling ADjoint matrix time (s) = ", timeAdj
!
!     ******************************************************************
!     *                                                                *
!     * Visualize the assembled matrix.                                *
!     *                                                                *
!     ******************************************************************
!
      ! MatView - Visualizes a matrix object.
      !
      ! Synopsis
      !
      ! #include "petscmat.h" 
      ! PetscErrorCode PETSCMAT_DLLEXPORT MatView(Mat mat, &
      !                                              PetscViewer viewer)
      !
      ! Collective on Mat
      !
      ! Input Parameters
      !   mat    - the matrix
      !   viewer - visualization context
      !
      ! Notes
      ! The available visualization contexts include
      !  PETSC_VIEWER_STDOUT_SELF  - standard output (default)
      !  PETSC_VIEWER_STDOUT_WORLD - synchronized standard output where
      !                         only the first processor opens the file.
      !                         All other processors send their data to
      !                         the first processor to print.
      !  PETSC_VIEWER_DRAW_WORLD- graphical display of nonzero structure
      !
      ! see .../petsc/docs/manualpages/Mat/MatView.html
      ! or PETSc users manual, pp.57,148

      if( debug ) then
        call MatView(dRdW,PETSC_VIEWER_DRAW_WORLD,PETScIerr)
        !call MatView(dRdW,PETSC_VIEWER_STDOUT_WORLD,PETScIerr)
        if( PETScIerr/=0 ) &
          call terminate("setupADjointMatrix", "Error in MatView")
        pause
      endif

      ! Flush the output buffer and synchronize the processors.

      call f77flush()
      call mpi_barrier(PETSC_COMM_WORLD, PETScIerr)

      ! Output formats.

   10 format(a)
   20 format(a,1x,f8.2)

      !=================================================================

      contains

        !===============================================================

        subroutine blockIndices(indexBlock, indexArray)
!
!       ****************************************************************
!       *                                                              *
!       * blockIndices fill the array containing the block matrix      *
!       * indices used when assembling the Jacobian matrix with the    *
!       * PETSc function MatSetValues().                               *
!       *                                                              *
!       ****************************************************************
!
        implicit none
!
!       Subroutine arguments.
!
        integer(kind=intType), intent(in) :: indexBlock
        integer(kind=intType), dimension(nw), intent(out) :: indexArray
!
!       Local variables.
!
        integer(kind=intType) :: idx
!
!       ****************************************************************
!       *                                                              *
!       * Begin execution.                                             *
!       *                                                              *
!       ****************************************************************
!
        indexArray(1) = indexBlock * nw
        do idx = 2, nw
          indexArray(idx) = indexArray(idx-1) + 1
        enddo

        end subroutine blockIndices

        !===============================================================

        subroutine errAssemb(routineName, matrixName)
!
!       ****************************************************************
!       *                                                              *
!       * errAssemb handles the error message and program termination  *
!       * during the Jacobian matrix dRdW assembly.                    *
!       *                                                              *
!       ****************************************************************
!
        implicit none
!
!       Subroutine arguments.
!
        character(len=*), intent(in) :: routineName
        character(len=*), intent(in) :: matrixName
!
!       Local variables.
!
        character(len=2*maxStringLen) :: errorMessage
!
!       ****************************************************************
!       *                                                              *
!       * Begin execution.                                             *
!       *                                                              *
!       ****************************************************************
!
        ! Determine the number of halo nodes to be communicated and
        ! check if halo data should be copied to the buffer.

        write(errorMessage,99) "Error in",                          &
                               trim(routineName), trim(matrixName), &
                               "for global node", idxmgb
        call terminate("setupADjointMatrix", errorMessage)

        ! Output format.

   99   format(a,1x,a,1x,a,1x,a,1x,i6)

        end subroutine errAssemb

#endif

      end subroutine setupADjointMatrix
