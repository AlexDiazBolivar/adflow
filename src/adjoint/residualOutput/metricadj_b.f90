!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 2.2.4 (r2308) - 03/04/2008 10:03
!  
!  Differentiation of metricadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: xadj
!   of linear combination of output variables: voladj skadj sjadj
!                siadj normadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          metricAdj.f90                                   *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi                                    *
!      * Starting date: 12-15-2007                                      *
!      * Last modified: 12-26-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE METRICADJ_B(xadj, xadjb, siadj, siadjb, sjadj, sjadjb, skadj&
&  , skadjb, voladj, voladjb, normadj, normadjb, icell, jcell, kcell)
  USE cgnsgrid
  USE blockpointers
  USE section
  USE inputtimespectral
  USE bctypes
  USE communication
  USE constants
  IMPLICIT NONE
!                   call terminate("metric", &
!                   "Normals do not sum up to 0")
!
!      ******************************************************************
!      *                                                                *
!      * metric computes the face normals and the volume for the given  *
!      * grid level for all spectral solutions. First the volumes are   *
!      * computed assuming that the block is right handed. Then the     *
!      * number of positive and negative volumes are determined. If all *
!      * volumes are positive the block is indeed right handed; if all  *
!      * volumes are negative the block is left handed and both the     *
!      * volumes and the normals must be negated (for the normals this  *
!      * is done by the introduction of fact, which is either -0.5 or   *
!      * 0.5); if there are both positive and negative volumes the mesh *
!      * is not valid.                                                  *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
  REAL(KIND=REALTYPE), DIMENSION(-2:3, -2:3, -2:3, 3) :: xadj
  REAL(KIND=REALTYPE), DIMENSION(-2:3, -2:3, -2:3, 3) :: xadjb
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadj, sjadj, &
&  skadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadjb, sjadjb&
&  , skadjb
  REAL(KIND=REALTYPE) :: voladj
  REAL(KIND=REALTYPE) :: voladjb
  REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, 3) :: normadj
  REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, 3) :: normadjb
  INTEGER(KIND=INTTYPE), INTENT(IN) :: icell, jcell, kcell
!
!      Local parameter.
!
  REAL(KIND=REALTYPE), PARAMETER :: thresvolume=1.e-2_realType
!
!      Local variables.
!
  INTEGER :: ierr
  INTEGER(KIND=INTTYPE) :: i, j, k, n, m, l, ist, ien, jst, jen, jj, kk
  INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
  INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
  INTEGER(KIND=INTTYPE) :: irbeg, irend, jrbeg, jrend, krbeg, krend
  INTEGER(KIND=INTTYPE) :: istart, iend, jstart, jend, kstart, kend
  INTEGER(KIND=INTTYPE) :: mm, sps, ntime
  INTEGER(KIND=INTTYPE) :: nvolbad, nvolbadglobal
  REAL(KIND=REALTYPE) :: fact, mult
  REAL(KIND=REALTYPE) :: factb
  REAL(KIND=REALTYPE) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
  REAL(KIND=REALTYPE) :: xpb, ypb, zpb, vp1b, vp2b, vp3b, vp4b, vp5b, &
&  vp6b
  REAL(KIND=REALTYPE), DIMENSION(3) :: v1, v2
  REAL(KIND=REALTYPE), DIMENSION(3) :: v1b, v2b
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, 3) :: ss
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, 3) :: ssb
  CHARACTER(len=10) :: integerstring
  LOGICAL :: checkk, checkj, checki, checkall
  LOGICAL :: badvolume
  LOGICAL :: volumeisneg, ioverlap, joverlap, koverlap, secondhalo
  REAL(KIND=REALTYPE) :: temp
  REAL(KIND=REALTYPE) :: temp0
  REAL(KIND=REALTYPE) :: temp1
  REAL(KIND=REALTYPE) :: temp2
  REAL(KIND=REALTYPE) :: temp3
  REAL(KIND=REALTYPE) :: temp4
  REAL(KIND=REALTYPE) :: temp5
  REAL(KIND=REALTYPE) :: temp6
  REAL(KIND=REALTYPE) :: temp7
  REAL(KIND=REALTYPE) :: temp8
  REAL(KIND=REALTYPE) :: temp9
  REAL(KIND=REALTYPE) :: temp10
  REAL(KIND=REALTYPE) :: temp11
  INTEGER :: ad_from
  INTEGER :: ad_to
  INTEGER :: branch
  INTEGER :: ad_from0
  INTEGER :: ad_to0
  INTEGER :: ad_from1
  INTEGER :: ad_to1
  INTEGER :: ad_from2
  INTEGER :: ad_to2
  INTEGER :: ad_from3
  INTEGER :: ad_to3
  INTEGER :: ad_from4
  INTEGER :: ad_to4
  INTEGER :: ad_from5
  INTEGER :: ad_to5
  INTEGER :: ad_from6
  INTEGER :: ad_to6
  REAL(KIND=REALTYPE) :: tempb9
  REAL(KIND=REALTYPE) :: tempb8
  REAL(KIND=REALTYPE) :: tempb7
  REAL(KIND=REALTYPE) :: tempb6
  REAL(KIND=REALTYPE) :: tempb5
  REAL(KIND=REALTYPE) :: tempb4
  REAL(KIND=REALTYPE) :: tempb3
  REAL(KIND=REALTYPE) :: tempb2
  REAL(KIND=REALTYPE) :: tempb1
  REAL(KIND=REALTYPE) :: tempb0
  REAL(KIND=REALTYPE) :: temp0b
  INTRINSIC MAX
  REAL(KIND=REALTYPE) :: tempb13
  REAL(KIND=REALTYPE) :: tempb12
  REAL(KIND=REALTYPE) :: tempb11
  REAL(KIND=REALTYPE) :: tempb10
  REAL(KIND=REALTYPE) :: temp3b
  INTRINSIC ABS
  REAL(KIND=REALTYPE) :: tempb
  REAL(KIND=REALTYPE) :: temp2b
  REAL(KIND=REALTYPE) :: temp5b
  REAL(KIND=REALTYPE) :: abs7
  REAL(KIND=REALTYPE) :: abs6
  REAL(KIND=REALTYPE) :: abs5
  REAL(KIND=REALTYPE) :: abs4
  REAL(KIND=REALTYPE) :: abs3
  REAL(KIND=REALTYPE) :: abs2
  REAL(KIND=REALTYPE) :: abs1
  INTRINSIC MIN
  REAL(KIND=REALTYPE) :: temp1b
  INTRINSIC SQRT
  REAL(KIND=REALTYPE) :: temp4b
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
! Some initialization for siAdj,sjAdj,skAdj,normAdj 
! Volume needs only one stencil so it does not need initialization
  siadj = zero
  sjadj = zero
  skadj = zero
!
!
!      **************************************************************
!      *                                                            *
!      * Volume computation
!      *                                                            *
!      **************************************************************
!
! Compute the volumes. The hexahedron is split into 6 pyramids
! whose volumes are computed. The volume is positive for a
! right handed block.
! Initialize the volumes to zero. The reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
  k = 0
  j = 0
  i = 0
  n = k - 1
  m = j - 1
  l = i - 1
! always check the volume of changed cell
! Compute the coordinates of the center of gravity.
  xp = eighth*(xadj(i, j, k, 1)+xadj(i, m, k, 1)+xadj(i, m, n, 1)+xadj(i&
&    , j, n, 1)+xadj(l, j, k, 1)+xadj(l, m, k, 1)+xadj(l, m, n, 1)+xadj(&
&    l, j, n, 1))
  yp = eighth*(xadj(i, j, k, 2)+xadj(i, m, k, 2)+xadj(i, m, n, 2)+xadj(i&
&    , j, n, 2)+xadj(l, j, k, 2)+xadj(l, m, k, 2)+xadj(l, m, n, 2)+xadj(&
&    l, j, n, 2))
  zp = eighth*(xadj(i, j, k, 3)+xadj(i, m, k, 3)+xadj(i, m, n, 3)+xadj(i&
&    , j, n, 3)+xadj(l, j, k, 3)+xadj(l, m, k, 3)+xadj(l, m, n, 3)+xadj(&
&    l, j, n, 3))
! Compute the volumes of the 6 sub pyramids. The
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
  CALL VOLPYM2(xadj(i, j, k, 1), xadj(i, j, k, 2), xadj(i, j, k, 3), &
&         xadj(i, j, n, 1), xadj(i, j, n, 2), xadj(i, j, n, 3), xadj(i, &
&         m, n, 1), xadj(i, m, n, 2), xadj(i, m, n, 3), xadj(i, m, k, 1)&
&         , xadj(i, m, k, 2), xadj(i, m, k, 3), xp, yp, zp, vp1)
  CALL VOLPYM2(xadj(l, j, k, 1), xadj(l, j, k, 2), xadj(l, j, k, 3), &
&         xadj(l, m, k, 1), xadj(l, m, k, 2), xadj(l, m, k, 3), xadj(l, &
&         m, n, 1), xadj(l, m, n, 2), xadj(l, m, n, 3), xadj(l, j, n, 1)&
&         , xadj(l, j, n, 2), xadj(l, j, n, 3), xp, yp, zp, vp2)
  CALL VOLPYM2(xadj(i, j, k, 1), xadj(i, j, k, 2), xadj(i, j, k, 3), &
&         xadj(l, j, k, 1), xadj(l, j, k, 2), xadj(l, j, k, 3), xadj(l, &
&         j, n, 1), xadj(l, j, n, 2), xadj(l, j, n, 3), xadj(i, j, n, 1)&
&         , xadj(i, j, n, 2), xadj(i, j, n, 3), xp, yp, zp, vp3)
  CALL VOLPYM2(xadj(i, m, k, 1), xadj(i, m, k, 2), xadj(i, m, k, 3), &
&         xadj(i, m, n, 1), xadj(i, m, n, 2), xadj(i, m, n, 3), xadj(l, &
&         m, n, 1), xadj(l, m, n, 2), xadj(l, m, n, 3), xadj(l, m, k, 1)&
&         , xadj(l, m, k, 2), xadj(l, m, k, 3), xp, yp, zp, vp4)
  CALL VOLPYM2(xadj(i, j, k, 1), xadj(i, j, k, 2), xadj(i, j, k, 3), &
&         xadj(i, m, k, 1), xadj(i, m, k, 2), xadj(i, m, k, 3), xadj(l, &
&         m, k, 1), xadj(l, m, k, 2), xadj(l, m, k, 3), xadj(l, j, k, 1)&
&         , xadj(l, j, k, 2), xadj(l, j, k, 3), xp, yp, zp, vp5)
  CALL VOLPYM2(xadj(i, j, n, 1), xadj(i, j, n, 2), xadj(i, j, n, 3), &
&         xadj(l, j, n, 1), xadj(l, j, n, 2), xadj(l, j, n, 3), xadj(l, &
&         m, n, 1), xadj(l, m, n, 2), xadj(l, m, n, 3), xadj(i, m, n, 1)&
&         , xadj(i, m, n, 2), xadj(i, m, n, 3), xp, yp, zp, vp6)
! Set the volume to 1/6 of the sum of the volumes of the
! pyramid. Remember that volpym computes 6 times the
! volume.
  voladj = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
! Check the volume and update the number of positive
! and negative volumes if needed.
  IF (voladj .GE. 0.) THEN
    CALL PUSHINTEGER4(0)
  ELSE
    CALL PUSHINTEGER4(1)
  END IF
!!$           ! Some additional safety stuff for halo volumes.
!!$
!!$           do k=2,kl
!!$             do j=2,jl
!!$               if(vol(1, j,k) <= eps) vol(1, j,k) = vol(2, j,k)
!!$               if(vol(ie,j,k) <= eps) vol(ie,j,k) = vol(il,j,k)
!!$             enddo
!!$           enddo
!!$
!!$           do k=2,kl
!!$             do i=1,ie
!!$               if(vol(i,1, k) <= eps) vol(i,1, k) = vol(i,2, k)
!!$               if(vol(i,je,k) <= eps) vol(i,je,k) = vol(i,jl,k)
!!$             enddo
!!$           enddo
!!$
!!$           do j=1,je
!!$             do i=1,ie
!!$               if(vol(i,j,1)  <= eps) vol(i,j,1)  = vol(i,j,2)
!!$               if(vol(i,j,ke) <= eps) vol(i,j,ke) = vol(i,j,kl)
!!$             enddo
!!$           enddo
!
!          **************************************************************
!          *                                                            *
!          * Computation of the face normals in i-, j- and k-direction. *
!          * Formula's are valid for a right handed block; for a left   *
!          * handed block the correct orientation is obtained via fact. *
!          * The normals point in the direction of increasing index.    *
!          * The absolute value of fact is 0.5, because the cross       *
!          * product of the two diagonals is twice the normal vector.   *
!          *                                                            *
!          * Note that also the normals of the first level halo cells   *
!          * are computed. These are needed for the viscous fluxes.     *
!          *                                                            *
!          **************************************************************
!
!s           if( flowDoms(nn,level,sps)%rightHanded ) then
  fact = half
!s           else
!s             fact = -half
!s           endif
! Projected areas of cell faces in the i direction.
  kstart = -2
  kend = 2
  jstart = -2
  jend = 2
  istart = -2
  iend = 2
  IF (icell .EQ. il) iend = 1
  IF (jcell .EQ. 2) jstart = -1
  IF (jcell .EQ. jl) jend = 1
  IF (kcell .EQ. 2) kstart = -1
  IF (kcell .EQ. kl) kend = 1
  ad_from = kstart
  CALL PUSHINTEGER4(k)
!-2,2
  DO k=ad_from,kend
    CALL PUSHINTEGER4(n)
    n = k - 1
    ad_from0 = jstart
    CALL PUSHINTEGER4(j)
!-2,2
    DO j=ad_from0,jend
      CALL PUSHINTEGER4(m)
      m = j - 1
      ad_from1 = istart
      CALL PUSHINTEGER4(i)
!-2,2
      DO i=ad_from1,iend
        CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
        v1(1) = xadj(i, j, n, 1) - xadj(i, m, k, 1)
        CALL PUSHREAL8(v1(2))
        v1(2) = xadj(i, j, n, 2) - xadj(i, m, k, 2)
        CALL PUSHREAL8(v1(3))
        v1(3) = xadj(i, j, n, 3) - xadj(i, m, k, 3)
        CALL PUSHREAL8(v2(1))
        v2(1) = xadj(i, j, k, 1) - xadj(i, m, n, 1)
        CALL PUSHREAL8(v2(2))
        v2(2) = xadj(i, j, k, 2) - xadj(i, m, n, 2)
        CALL PUSHREAL8(v2(3))
        v2(3) = xadj(i, j, k, 3) - xadj(i, m, n, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        siadj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        siadj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        siadj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from1)
    END DO
    CALL PUSHINTEGER4(j - 1)
    CALL PUSHINTEGER4(ad_from0)
  END DO
  CALL PUSHINTEGER4(k - 1)
  CALL PUSHINTEGER4(ad_from)
! Projected areas of cell faces in the j direction.
  kstart = -2
  kend = 2
  jstart = -2
  jend = 2
  istart = -2
  iend = 2
  IF (icell .EQ. 2) istart = -1
  IF (icell .EQ. il) iend = 1
  IF (jcell .EQ. jl) jend = 1
  IF (kcell .EQ. 2) kstart = -1
  IF (kcell .EQ. kl) kend = 1
  ad_from2 = kstart
!-2,2
  DO k=ad_from2,kend
    CALL PUSHINTEGER4(n)
    n = k - 1
    ad_from3 = jstart
    CALL PUSHINTEGER4(j)
!-2,2
    DO j=ad_from3,jend
      ad_from4 = istart
      CALL PUSHINTEGER4(i)
!-2,2
      DO i=ad_from4,iend
        CALL PUSHINTEGER4(l)
        l = i - 1
        CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
        v1(1) = xadj(i, j, n, 1) - xadj(l, j, k, 1)
        CALL PUSHREAL8(v1(2))
        v1(2) = xadj(i, j, n, 2) - xadj(l, j, k, 2)
        CALL PUSHREAL8(v1(3))
        v1(3) = xadj(i, j, n, 3) - xadj(l, j, k, 3)
        CALL PUSHREAL8(v2(1))
        v2(1) = xadj(l, j, n, 1) - xadj(i, j, k, 1)
        CALL PUSHREAL8(v2(2))
        v2(2) = xadj(l, j, n, 2) - xadj(i, j, k, 2)
        CALL PUSHREAL8(v2(3))
        v2(3) = xadj(l, j, n, 3) - xadj(i, j, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        sjadj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        sjadj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        sjadj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from4)
    END DO
    CALL PUSHINTEGER4(j - 1)
    CALL PUSHINTEGER4(ad_from3)
  END DO
  CALL PUSHINTEGER4(k - 1)
  CALL PUSHINTEGER4(ad_from2)
! Projected areas of cell faces in the k direction.
! Projected areas of cell faces in the j direction.
  kstart = -2
  kend = 2
  jstart = -2
  jend = 2
  istart = -2
  iend = 2
  IF (icell .EQ. 2) istart = -1
  IF (icell .EQ. il) iend = 1
  IF (jcell .EQ. 2) jstart = -1
  IF (jcell .EQ. jl) jend = 1
  IF (kcell .EQ. kl) kend = 1
!-2,2
  DO k=kstart,kend
    CALL PUSHINTEGER4(j)
!-2,2
    DO j=jstart,jend
      CALL PUSHINTEGER4(m)
      m = j - 1
      CALL PUSHINTEGER4(i)
!-2,2
      DO i=istart,iend
        CALL PUSHINTEGER4(l)
        l = i - 1
        CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
        v1(1) = xadj(i, j, k, 1) - xadj(l, m, k, 1)
        CALL PUSHREAL8(v1(2))
        v1(2) = xadj(i, j, k, 2) - xadj(l, m, k, 2)
        CALL PUSHREAL8(v1(3))
        v1(3) = xadj(i, j, k, 3) - xadj(l, m, k, 3)
        CALL PUSHREAL8(v2(1))
        v2(1) = xadj(l, j, k, 1) - xadj(i, m, k, 1)
        CALL PUSHREAL8(v2(2))
        v2(2) = xadj(l, j, k, 2) - xadj(i, m, k, 2)
        CALL PUSHREAL8(v2(3))
        v2(3) = xadj(l, j, k, 3) - xadj(i, m, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        skadj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        skadj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        skadj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
    END DO
  END DO
!
!        **************************************************************
!        *                                                            *
!        * If the considering cell is on the subfaces, then compute   *
!        * normAdj(-2:2,-2:2,-2:2,3). Otherwise return!               *
!        *                                                            *
!        * The unit normals on the boundary faces. These always point *
!        *  out of the domain, so a multiplication by -1 is needed for *
!        * the iMin, jMin and kMin boundaries.                        *
!        *                                                            *
!        **************************************************************
!
! Determine the range of the stencil for the given cell.
  isbeg = icell - 2
  isend = icell + 2
  jsbeg = jcell - 2
  jsend = jcell + 2
  ksbeg = kcell - 2
  ksend = kcell + 2
! Loop over the number of physical boundary subfaces of the block.
bocoloop:DO mm=1,nbocos
! Determine the range of halo cells which this boundary subface
! will change.
    SELECT CASE  (bcfaceid(mm)) 
    CASE (imin) 
      ibbeg = 0
      ibend = 1
      jbbeg = bcdata(mm)%icbeg
      jbend = bcdata(mm)%icend
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
    CASE (imax) 
!=============================================================
      ibbeg = ie
      ibend = ib
      jbbeg = bcdata(mm)%icbeg
      jbend = bcdata(mm)%icend
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
    CASE (jmin) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = 0
      jbend = 1
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
    CASE (jmax) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = je
      jbend = jb
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
    CASE (kmin) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = bcdata(mm)%jcbeg
      jbend = bcdata(mm)%jcend
      kbbeg = 0
      kbend = 1
    CASE (kmax) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = bcdata(mm)%jcbeg
      jbend = bcdata(mm)%jcend
      kbbeg = ke
      kbend = kb
    END SELECT
! Check for an overlap between the stencil range and the
! halo cells influenced by this boundary subface.
    ioverlap = .false.
    IF (isbeg .LE. ibend .AND. isend .GE. ibbeg) ioverlap = .true.
    joverlap = .false.
    IF (jsbeg .LE. jbend .AND. jsend .GE. jbbeg) joverlap = .true.
    koverlap = .false.
    IF (ksbeg .LE. kbend .AND. ksend .GE. kbbeg) koverlap = .true.
    IF (ioverlap .AND. joverlap .AND. koverlap) THEN
      IF (isbeg .LT. ibbeg) THEN
        irbeg = ibbeg
      ELSE
        irbeg = isbeg
      END IF
      IF (isend .GT. ibend) THEN
        irend = ibend
      ELSE
        irend = isend
      END IF
      IF (jsbeg .LT. jbbeg) THEN
        jrbeg = jbbeg
      ELSE
        jrbeg = jsbeg
      END IF
      IF (jsend .GT. jbend) THEN
        jrend = jbend
      ELSE
        jrend = jsend
      END IF
      IF (ksbeg .LT. kbbeg) THEN
        krbeg = kbbeg
      ELSE
        krbeg = ksbeg
      END IF
      IF (ksend .GT. kbend) THEN
        krend = kbend
      ELSE
        krend = ksend
      END IF
      CALL PUSHINTEGER4(ist)
      ist = -2
      CALL PUSHINTEGER4(ien)
      ien = 2
      CALL PUSHINTEGER4(jst)
      jst = -2
      CALL PUSHINTEGER4(jen)
      jen = 2
      SELECT CASE  (bcfaceid(mm)) 
      CASE (imin) 
        IF (jcell .EQ. 2) ist = -1
        IF (jcell .EQ. jl) ien = 1
        IF (kcell .EQ. 2) jst = -1
        IF (kcell .EQ. kl) jen = 1
        secondhalo = .true.
        IF (irbeg .EQ. irend) secondhalo = .false.
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = siadj(-1, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(11)
        ELSE
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = siadj(-2, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(12)
        END IF
      CASE (imax) 
        IF (jcell .EQ. 2) ist = -1
        IF (jcell .EQ. jl) ien = 1
        IF (kcell .EQ. 2) jst = -1
        IF (kcell .EQ. kl) jen = 1
        secondhalo = .true.
        IF (irbeg .EQ. irend) secondhalo = .false.
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = siadj(0, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(9)
        ELSE
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = siadj(1, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(10)
        END IF
      CASE (jmin) 
        IF (icell .EQ. 2) ist = -1
        IF (icell .EQ. il) ien = 1
        IF (kcell .EQ. 2) jst = -1
        IF (kcell .EQ. kl) jen = 1
        secondhalo = .true.
        IF (jrbeg .EQ. jrend) secondhalo = .false.
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -1, jst:jen, :)
          CALL PUSHINTEGER4(7)
        ELSE
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -2, jst:jen, :)
          CALL PUSHINTEGER4(8)
        END IF
      CASE (jmax) 
        IF (icell .EQ. 2) ist = -1
        IF (icell .EQ. il) ien = 1
        IF (kcell .EQ. 2) jst = -1
        IF (kcell .EQ. kl) jen = 1
        secondhalo = .true.
        IF (jrbeg .EQ. jrend) secondhalo = .false.
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 0, jst:jen, :)
          CALL PUSHINTEGER4(5)
        ELSE
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 1, jst:jen, :)
          CALL PUSHINTEGER4(6)
        END IF
      CASE (kmin) 
        IF (icell .EQ. 2) ist = -1
        IF (icell .EQ. il) ien = 1
        IF (jcell .EQ. 2) jst = -1
        IF (jcell .EQ. jl) jen = 1
        secondhalo = .true.
        IF (krbeg .EQ. krend) secondhalo = .false.
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -1, :)
          CALL PUSHINTEGER4(3)
        ELSE
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -2, :)
          CALL PUSHINTEGER4(4)
        END IF
      CASE (kmax) 
        IF (icell .EQ. 2) ist = -1
        IF (icell .EQ. il) ien = 1
        IF (jcell .EQ. 2) jst = -1
        IF (jcell .EQ. jl) jen = 1
        secondhalo = .true.
        IF (krbeg .EQ. krend) secondhalo = .false.
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 0, :)
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 1, :)
          CALL PUSHINTEGER4(2)
        END IF
      CASE DEFAULT
        CALL PUSHINTEGER4(0)
      END SELECT
      ad_from5 = jst
      DO kk=ad_from5,jen
        ad_from6 = ist
        DO jj=ad_from6,ien
          CALL PUSHREAL8(xp)
! Compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
          xp = ss(jj, kk, 1)
          CALL PUSHREAL8(yp)
          yp = ss(jj, kk, 2)
          CALL PUSHREAL8(zp)
          zp = ss(jj, kk, 3)
          CALL PUSHREAL8(fact)
          fact = SQRT(xp*xp + yp*yp + zp*zp)
          IF (fact .GT. zero) THEN
            CALL PUSHREAL8(fact)
            fact = mult/fact
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
          END IF
        END DO
        CALL PUSHINTEGER4(jj - 1)
        CALL PUSHINTEGER4(ad_from6)
      END DO
      CALL PUSHINTEGER4(kk - 1)
      CALL PUSHINTEGER4(ad_from5)
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  END DO bocoloop
!
!          **************************************************************
!          *                                                            *
!          * Check in debug mode the sum of the normals of the cells.   *
!          * If everything is correct this should sum up to zero.       *
!          *                                                            *
!          **************************************************************
!
  IF (debug) THEN
    CALL PUSHINTEGER4(i)
! Loop over the cells including the 1st level halo's.
    i = 0
    CALL PUSHINTEGER4(j)
    j = 0
    k = 0
    CALL PUSHINTEGER4(l)
    l = i - 1
    CALL PUSHINTEGER4(m)
    m = j - 1
    CALL PUSHINTEGER4(n)
    n = k - 1
! Store the sum of the outward pointing surrounding
! normals in v1. Due to the outward convention the
! normals with the lowest index get a negative sign;
! normals point in the direction of the higher index.
! Store the inverse of the sum of the areas of the
! six faces in fact.
    temp = skadj(i, j, n, 1)**2 + skadj(i, j, n, 2)**2 + skadj(i, j, n, &
&      3)**2
    temp11 = SQRT(temp)
    temp0 = skadj(i, j, k, 1)**2 + skadj(i, j, k, 2)**2 + skadj(i, j, k&
&      , 3)**2
    temp10 = SQRT(temp0)
    temp1 = sjadj(i, m, k, 1)**2 + sjadj(i, m, k, 2)**2 + sjadj(i, m, k&
&      , 3)**2
    temp9 = SQRT(temp1)
    temp2 = sjadj(i, j, k, 1)**2 + sjadj(i, j, k, 2)**2 + sjadj(i, j, k&
&      , 3)**2
    temp8 = SQRT(temp2)
    temp3 = siadj(l, j, k, 1)**2 + siadj(l, j, k, 2)**2 + siadj(l, j, k&
&      , 3)**2
    temp7 = SQRT(temp3)
    temp4 = siadj(i, j, k, 1)**2 + siadj(i, j, k, 2)**2 + siadj(i, j, k&
&      , 3)**2
    temp6 = SQRT(temp4)
    temp5 = temp6 + temp7 + temp8 + temp9 + temp10 + temp11
    temp5b = -(one*factb/temp5**2)
    IF (temp4 .EQ. 0.0) THEN
      temp4b = 0.0
    ELSE
      temp4b = temp5b/(2.0*temp6)
    END IF
    IF (temp3 .EQ. 0.0) THEN
      temp3b = 0.0
    ELSE
      temp3b = temp5b/(2.0*temp7)
    END IF
    IF (temp2 .EQ. 0.0) THEN
      temp2b = 0.0
    ELSE
      temp2b = temp5b/(2.0*temp8)
    END IF
    IF (temp1 .EQ. 0.0) THEN
      temp1b = 0.0
    ELSE
      temp1b = temp5b/(2.0*temp9)
    END IF
    IF (temp0 .EQ. 0.0) THEN
      temp0b = 0.0
    ELSE
      temp0b = temp5b/(2.0*temp10)
    END IF
    IF (temp .EQ. 0.0) THEN
      tempb13 = 0.0
    ELSE
      tempb13 = temp5b/(2.0*temp11)
    END IF
    CALL POPINTEGER4(n)
    CALL POPINTEGER4(m)
    CALL POPINTEGER4(l)
    CALL POPINTEGER4(j)
    CALL POPINTEGER4(i)
  END IF
  ssb(-2:2, -2:2, :) = 0.0
  DO mm=nbocos,1,-1
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 2) THEN
      CALL POPINTEGER4(ad_from5)
      CALL POPINTEGER4(ad_to5)
      DO kk=ad_to5,ad_from5,-1
        CALL POPINTEGER4(ad_from6)
        CALL POPINTEGER4(ad_to6)
        DO jj=ad_to6,ad_from6,-1
          factb = zp*normadjb(mm, jj, kk, 3)
          zpb = fact*normadjb(mm, jj, kk, 3)
          normadjb(mm, jj, kk, 3) = 0.0
          factb = factb + yp*normadjb(mm, jj, kk, 2)
          ypb = fact*normadjb(mm, jj, kk, 2)
          normadjb(mm, jj, kk, 2) = 0.0
          factb = factb + xp*normadjb(mm, jj, kk, 1)
          xpb = fact*normadjb(mm, jj, kk, 1)
          normadjb(mm, jj, kk, 1) = 0.0
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) THEN
            CALL POPREAL8(fact)
            factb = -(mult*factb/fact**2)
          END IF
          CALL POPREAL8(fact)
          IF (xp**2 + yp**2 + zp**2 .EQ. 0.0) THEN
            tempb12 = 0.0
          ELSE
            tempb12 = factb/(2.0*SQRT(xp**2+yp**2+zp**2))
          END IF
          xpb = xpb + 2*xp*tempb12
          ypb = ypb + 2*yp*tempb12
          zpb = zpb + 2*zp*tempb12
          CALL POPREAL8(zp)
          ssb(jj, kk, 3) = ssb(jj, kk, 3) + zpb
          CALL POPREAL8(yp)
          ssb(jj, kk, 2) = ssb(jj, kk, 2) + ypb
          CALL POPREAL8(xp)
          ssb(jj, kk, 1) = ssb(jj, kk, 1) + xpb
        END DO
      END DO
      CALL POPINTEGER4(branch)
      IF (branch .LT. 7) THEN
        IF (branch .LT. 4) THEN
          IF (branch .LT. 2) THEN
            IF (.NOT.branch .LT. 1) THEN
              skadjb(ist:ien, jst:jen, 0, :) = skadjb(ist:ien, jst:jen, &
&                0, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
            END IF
          ELSE IF (branch .LT. 3) THEN
            skadjb(ist:ien, jst:jen, 1, :) = skadjb(ist:ien, jst:jen, 1&
&              , :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          ELSE
            skadjb(ist:ien, jst:jen, -1, :) = skadjb(ist:ien, jst:jen, -&
&              1, :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          END IF
        ELSE IF (branch .LT. 6) THEN
          IF (branch .LT. 5) THEN
            skadjb(ist:ien, jst:jen, -2, :) = skadjb(ist:ien, jst:jen, -&
&              2, :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          ELSE
            sjadjb(ist:ien, 0, jst:jen, :) = sjadjb(ist:ien, 0, jst:jen&
&              , :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          END IF
        ELSE
          sjadjb(ist:ien, 1, jst:jen, :) = sjadjb(ist:ien, 1, jst:jen, :&
&            ) + ssb(ist:ien, jst:jen, :)
          ssb(ist:ien, jst:jen, :) = 0.0
          CALL POPREAL8(mult)
        END IF
      ELSE IF (branch .LT. 10) THEN
        IF (branch .LT. 9) THEN
          IF (branch .LT. 8) THEN
            sjadjb(ist:ien, -1, jst:jen, :) = sjadjb(ist:ien, -1, jst:&
&              jen, :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          ELSE
            sjadjb(ist:ien, -2, jst:jen, :) = sjadjb(ist:ien, -2, jst:&
&              jen, :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          END IF
        ELSE
          siadjb(0, ist:ien, jst:jen, :) = siadjb(0, ist:ien, jst:jen, :&
&            ) + ssb(ist:ien, jst:jen, :)
          ssb(ist:ien, jst:jen, :) = 0.0
          CALL POPREAL8(mult)
        END IF
      ELSE IF (branch .LT. 12) THEN
        IF (branch .LT. 11) THEN
          siadjb(1, ist:ien, jst:jen, :) = siadjb(1, ist:ien, jst:jen, :&
&            ) + ssb(ist:ien, jst:jen, :)
          ssb(ist:ien, jst:jen, :) = 0.0
          CALL POPREAL8(mult)
        ELSE
          siadjb(-1, ist:ien, jst:jen, :) = siadjb(-1, ist:ien, jst:jen&
&            , :) + ssb(ist:ien, jst:jen, :)
          ssb(ist:ien, jst:jen, :) = 0.0
          CALL POPREAL8(mult)
        END IF
      ELSE
        siadjb(-2, ist:ien, jst:jen, :) = siadjb(-2, ist:ien, jst:jen, :&
&          ) + ssb(ist:ien, jst:jen, :)
        ssb(ist:ien, jst:jen, :) = 0.0
        CALL POPREAL8(mult)
      END IF
      CALL POPINTEGER4(jen)
      CALL POPINTEGER4(jst)
      CALL POPINTEGER4(ien)
      CALL POPINTEGER4(ist)
    END IF
  END DO
  xadjb(-2:3, -2:3, -2:3, :) = 0.0
  v1b(:) = 0.0
  v2b(:) = 0.0
  DO k=kend,kstart,-1
    DO j=jend,jstart,-1
      DO i=iend,istart,-1
        tempb9 = fact*skadjb(i, j, k, 3)
        v1b(1) = v1b(1) + v2(2)*tempb9
        v2b(2) = v2b(2) + v1(1)*tempb9
        v1b(2) = v1b(2) - v2(1)*tempb9
        skadjb(i, j, k, 3) = 0.0
        tempb10 = fact*skadjb(i, j, k, 2)
        v2b(1) = v2b(1) + v1(3)*tempb10 - v1(2)*tempb9
        v1b(3) = v1b(3) + v2(1)*tempb10
        v1b(1) = v1b(1) - v2(3)*tempb10
        skadjb(i, j, k, 2) = 0.0
        tempb11 = fact*skadjb(i, j, k, 1)
        v2b(3) = v2b(3) + v1(2)*tempb11 - v1(1)*tempb10
        v1b(2) = v1b(2) + v2(3)*tempb11
        v1b(3) = v1b(3) - v2(2)*tempb11
        v2b(2) = v2b(2) - v1(3)*tempb11
        skadjb(i, j, k, 1) = 0.0
        CALL POPREAL8(v2(3))
        xadjb(l, j, k, 3) = xadjb(l, j, k, 3) + v2b(3)
        xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v2b(3)
        v2b(3) = 0.0
        CALL POPREAL8(v2(2))
        xadjb(l, j, k, 2) = xadjb(l, j, k, 2) + v2b(2)
        xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v2b(2)
        v2b(2) = 0.0
        CALL POPREAL8(v2(1))
        xadjb(l, j, k, 1) = xadjb(l, j, k, 1) + v2b(1)
        xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v2b(1)
        v2b(1) = 0.0
        CALL POPREAL8(v1(3))
        xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v1b(3)
        xadjb(l, m, k, 3) = xadjb(l, m, k, 3) - v1b(3)
        v1b(3) = 0.0
        CALL POPREAL8(v1(2))
        xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v1b(2)
        xadjb(l, m, k, 2) = xadjb(l, m, k, 2) - v1b(2)
        v1b(2) = 0.0
        CALL POPREAL8(v1(1))
        xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v1b(1)
        xadjb(l, m, k, 1) = xadjb(l, m, k, 1) - v1b(1)
        v1b(1) = 0.0
        CALL POPINTEGER4(l)
      END DO
      CALL POPINTEGER4(i)
      CALL POPINTEGER4(m)
    END DO
    CALL POPINTEGER4(j)
  END DO
  CALL POPINTEGER4(ad_from2)
  CALL POPINTEGER4(ad_to2)
  DO k=ad_to2,ad_from2,-1
    CALL POPINTEGER4(ad_from3)
    CALL POPINTEGER4(ad_to3)
    DO j=ad_to3,ad_from3,-1
      CALL POPINTEGER4(ad_from4)
      CALL POPINTEGER4(ad_to4)
      DO i=ad_to4,ad_from4,-1
        tempb6 = fact*sjadjb(i, j, k, 3)
        v1b(1) = v1b(1) + v2(2)*tempb6
        v2b(2) = v2b(2) + v1(1)*tempb6
        v1b(2) = v1b(2) - v2(1)*tempb6
        sjadjb(i, j, k, 3) = 0.0
        tempb7 = fact*sjadjb(i, j, k, 2)
        v2b(1) = v2b(1) + v1(3)*tempb7 - v1(2)*tempb6
        v1b(3) = v1b(3) + v2(1)*tempb7
        v1b(1) = v1b(1) - v2(3)*tempb7
        sjadjb(i, j, k, 2) = 0.0
        tempb8 = fact*sjadjb(i, j, k, 1)
        v2b(3) = v2b(3) + v1(2)*tempb8 - v1(1)*tempb7
        v1b(2) = v1b(2) + v2(3)*tempb8
        v1b(3) = v1b(3) - v2(2)*tempb8
        v2b(2) = v2b(2) - v1(3)*tempb8
        sjadjb(i, j, k, 1) = 0.0
        CALL POPREAL8(v2(3))
        xadjb(l, j, n, 3) = xadjb(l, j, n, 3) + v2b(3)
        xadjb(i, j, k, 3) = xadjb(i, j, k, 3) - v2b(3)
        v2b(3) = 0.0
        CALL POPREAL8(v2(2))
        xadjb(l, j, n, 2) = xadjb(l, j, n, 2) + v2b(2)
        xadjb(i, j, k, 2) = xadjb(i, j, k, 2) - v2b(2)
        v2b(2) = 0.0
        CALL POPREAL8(v2(1))
        xadjb(l, j, n, 1) = xadjb(l, j, n, 1) + v2b(1)
        xadjb(i, j, k, 1) = xadjb(i, j, k, 1) - v2b(1)
        v2b(1) = 0.0
        CALL POPREAL8(v1(3))
        xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
        xadjb(l, j, k, 3) = xadjb(l, j, k, 3) - v1b(3)
        v1b(3) = 0.0
        CALL POPREAL8(v1(2))
        xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
        xadjb(l, j, k, 2) = xadjb(l, j, k, 2) - v1b(2)
        v1b(2) = 0.0
        CALL POPREAL8(v1(1))
        xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
        xadjb(l, j, k, 1) = xadjb(l, j, k, 1) - v1b(1)
        v1b(1) = 0.0
        CALL POPINTEGER4(l)
      END DO
      CALL POPINTEGER4(i)
    END DO
    CALL POPINTEGER4(j)
    CALL POPINTEGER4(n)
  END DO
  CALL POPINTEGER4(ad_from)
  CALL POPINTEGER4(ad_to)
  DO k=ad_to,ad_from,-1
    CALL POPINTEGER4(ad_from0)
    CALL POPINTEGER4(ad_to0)
    DO j=ad_to0,ad_from0,-1
      CALL POPINTEGER4(ad_from1)
      CALL POPINTEGER4(ad_to1)
      DO i=ad_to1,ad_from1,-1
        tempb3 = fact*siadjb(i, j, k, 3)
        v1b(1) = v1b(1) + v2(2)*tempb3
        v2b(2) = v2b(2) + v1(1)*tempb3
        v1b(2) = v1b(2) - v2(1)*tempb3
        siadjb(i, j, k, 3) = 0.0
        tempb4 = fact*siadjb(i, j, k, 2)
        v2b(1) = v2b(1) + v1(3)*tempb4 - v1(2)*tempb3
        v1b(3) = v1b(3) + v2(1)*tempb4
        v1b(1) = v1b(1) - v2(3)*tempb4
        siadjb(i, j, k, 2) = 0.0
        tempb5 = fact*siadjb(i, j, k, 1)
        v2b(3) = v2b(3) + v1(2)*tempb5 - v1(1)*tempb4
        v1b(2) = v1b(2) + v2(3)*tempb5
        v1b(3) = v1b(3) - v2(2)*tempb5
        v2b(2) = v2b(2) - v1(3)*tempb5
        siadjb(i, j, k, 1) = 0.0
        CALL POPREAL8(v2(3))
        xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v2b(3)
        xadjb(i, m, n, 3) = xadjb(i, m, n, 3) - v2b(3)
        v2b(3) = 0.0
        CALL POPREAL8(v2(2))
        xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v2b(2)
        xadjb(i, m, n, 2) = xadjb(i, m, n, 2) - v2b(2)
        v2b(2) = 0.0
        CALL POPREAL8(v2(1))
        xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v2b(1)
        xadjb(i, m, n, 1) = xadjb(i, m, n, 1) - v2b(1)
        v2b(1) = 0.0
        CALL POPREAL8(v1(3))
        xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
        xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v1b(3)
        v1b(3) = 0.0
        CALL POPREAL8(v1(2))
        xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
        xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v1b(2)
        v1b(2) = 0.0
        CALL POPREAL8(v1(1))
        xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
        xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v1b(1)
        v1b(1) = 0.0
      END DO
      CALL POPINTEGER4(i)
      CALL POPINTEGER4(m)
    END DO
    CALL POPINTEGER4(j)
    CALL POPINTEGER4(n)
  END DO
  CALL POPINTEGER4(k)
  CALL POPINTEGER4(branch)
  IF (.NOT.branch .LT. 1) voladjb = -voladjb
  tempb = sixth*voladjb
  vp1b = tempb
  vp2b = tempb
  vp3b = tempb
  vp4b = tempb
  vp5b = tempb
  vp6b = tempb
  zpb = 0.0
  ypb = 0.0
  xpb = 0.0
  CALL VOLPYM2_B(xadj(i, j, n, 1), xadjb(i, j, n, 1), xadj(i, j, n, 2), &
&           xadjb(i, j, n, 2), xadj(i, j, n, 3), xadjb(i, j, n, 3), xadj&
&           (l, j, n, 1), xadjb(l, j, n, 1), xadj(l, j, n, 2), xadjb(l, &
&           j, n, 2), xadj(l, j, n, 3), xadjb(l, j, n, 3), xadj(l, m, n&
&           , 1), xadjb(l, m, n, 1), xadj(l, m, n, 2), xadjb(l, m, n, 2)&
&           , xadj(l, m, n, 3), xadjb(l, m, n, 3), xadj(i, m, n, 1), &
&           xadjb(i, m, n, 1), xadj(i, m, n, 2), xadjb(i, m, n, 2), xadj&
&           (i, m, n, 3), xadjb(i, m, n, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp6, vp6b)
  CALL VOLPYM2_B(xadj(i, j, k, 1), xadjb(i, j, k, 1), xadj(i, j, k, 2), &
&           xadjb(i, j, k, 2), xadj(i, j, k, 3), xadjb(i, j, k, 3), xadj&
&           (i, m, k, 1), xadjb(i, m, k, 1), xadj(i, m, k, 2), xadjb(i, &
&           m, k, 2), xadj(i, m, k, 3), xadjb(i, m, k, 3), xadj(l, m, k&
&           , 1), xadjb(l, m, k, 1), xadj(l, m, k, 2), xadjb(l, m, k, 2)&
&           , xadj(l, m, k, 3), xadjb(l, m, k, 3), xadj(l, j, k, 1), &
&           xadjb(l, j, k, 1), xadj(l, j, k, 2), xadjb(l, j, k, 2), xadj&
&           (l, j, k, 3), xadjb(l, j, k, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp5, vp5b)
  CALL VOLPYM2_B(xadj(i, m, k, 1), xadjb(i, m, k, 1), xadj(i, m, k, 2), &
&           xadjb(i, m, k, 2), xadj(i, m, k, 3), xadjb(i, m, k, 3), xadj&
&           (i, m, n, 1), xadjb(i, m, n, 1), xadj(i, m, n, 2), xadjb(i, &
&           m, n, 2), xadj(i, m, n, 3), xadjb(i, m, n, 3), xadj(l, m, n&
&           , 1), xadjb(l, m, n, 1), xadj(l, m, n, 2), xadjb(l, m, n, 2)&
&           , xadj(l, m, n, 3), xadjb(l, m, n, 3), xadj(l, m, k, 1), &
&           xadjb(l, m, k, 1), xadj(l, m, k, 2), xadjb(l, m, k, 2), xadj&
&           (l, m, k, 3), xadjb(l, m, k, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp4, vp4b)
  CALL VOLPYM2_B(xadj(i, j, k, 1), xadjb(i, j, k, 1), xadj(i, j, k, 2), &
&           xadjb(i, j, k, 2), xadj(i, j, k, 3), xadjb(i, j, k, 3), xadj&
&           (l, j, k, 1), xadjb(l, j, k, 1), xadj(l, j, k, 2), xadjb(l, &
&           j, k, 2), xadj(l, j, k, 3), xadjb(l, j, k, 3), xadj(l, j, n&
&           , 1), xadjb(l, j, n, 1), xadj(l, j, n, 2), xadjb(l, j, n, 2)&
&           , xadj(l, j, n, 3), xadjb(l, j, n, 3), xadj(i, j, n, 1), &
&           xadjb(i, j, n, 1), xadj(i, j, n, 2), xadjb(i, j, n, 2), xadj&
&           (i, j, n, 3), xadjb(i, j, n, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp3, vp3b)
  CALL VOLPYM2_B(xadj(l, j, k, 1), xadjb(l, j, k, 1), xadj(l, j, k, 2), &
&           xadjb(l, j, k, 2), xadj(l, j, k, 3), xadjb(l, j, k, 3), xadj&
&           (l, m, k, 1), xadjb(l, m, k, 1), xadj(l, m, k, 2), xadjb(l, &
&           m, k, 2), xadj(l, m, k, 3), xadjb(l, m, k, 3), xadj(l, m, n&
&           , 1), xadjb(l, m, n, 1), xadj(l, m, n, 2), xadjb(l, m, n, 2)&
&           , xadj(l, m, n, 3), xadjb(l, m, n, 3), xadj(l, j, n, 1), &
&           xadjb(l, j, n, 1), xadj(l, j, n, 2), xadjb(l, j, n, 2), xadj&
&           (l, j, n, 3), xadjb(l, j, n, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp2, vp2b)
  CALL VOLPYM2_B(xadj(i, j, k, 1), xadjb(i, j, k, 1), xadj(i, j, k, 2), &
&           xadjb(i, j, k, 2), xadj(i, j, k, 3), xadjb(i, j, k, 3), xadj&
&           (i, j, n, 1), xadjb(i, j, n, 1), xadj(i, j, n, 2), xadjb(i, &
&           j, n, 2), xadj(i, j, n, 3), xadjb(i, j, n, 3), xadj(i, m, n&
&           , 1), xadjb(i, m, n, 1), xadj(i, m, n, 2), xadjb(i, m, n, 2)&
&           , xadj(i, m, n, 3), xadjb(i, m, n, 3), xadj(i, m, k, 1), &
&           xadjb(i, m, k, 1), xadj(i, m, k, 2), xadjb(i, m, k, 2), xadj&
&           (i, m, k, 3), xadjb(i, m, k, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp1, vp1b)
  tempb0 = eighth*zpb
  xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + tempb0
  xadjb(i, m, k, 3) = xadjb(i, m, k, 3) + tempb0
  xadjb(i, m, n, 3) = xadjb(i, m, n, 3) + tempb0
  xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + tempb0
  xadjb(l, j, k, 3) = xadjb(l, j, k, 3) + tempb0
  xadjb(l, m, k, 3) = xadjb(l, m, k, 3) + tempb0
  xadjb(l, m, n, 3) = xadjb(l, m, n, 3) + tempb0
  xadjb(l, j, n, 3) = xadjb(l, j, n, 3) + tempb0
  tempb1 = eighth*ypb
  xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + tempb1
  xadjb(i, m, k, 2) = xadjb(i, m, k, 2) + tempb1
  xadjb(i, m, n, 2) = xadjb(i, m, n, 2) + tempb1
  xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + tempb1
  xadjb(l, j, k, 2) = xadjb(l, j, k, 2) + tempb1
  xadjb(l, m, k, 2) = xadjb(l, m, k, 2) + tempb1
  xadjb(l, m, n, 2) = xadjb(l, m, n, 2) + tempb1
  xadjb(l, j, n, 2) = xadjb(l, j, n, 2) + tempb1
  tempb2 = eighth*xpb
  xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + tempb2
  xadjb(i, m, k, 1) = xadjb(i, m, k, 1) + tempb2
  xadjb(i, m, n, 1) = xadjb(i, m, n, 1) + tempb2
  xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + tempb2
  xadjb(l, j, k, 1) = xadjb(l, j, k, 1) + tempb2
  xadjb(l, m, k, 1) = xadjb(l, m, k, 1) + tempb2
  xadjb(l, m, n, 1) = xadjb(l, m, n, 1) + tempb2
  xadjb(l, j, n, 1) = xadjb(l, j, n, 1) + tempb2
END SUBROUTINE METRICADJ_B
