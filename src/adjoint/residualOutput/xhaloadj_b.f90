!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of xhaloadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: xadj xblockcorneradj
!   of linear combination of output variables: xadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          xhaloAdj.f90                                    *
!      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
!      * Starting date: 08-13-2009                                      *
!      * Last modified: 08-13-2009                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE XHALOADJ_B(xadj, xadjb, xblockcorneradj, xblockcorneradjb, &
&  icell, jcell, kcell)
  USE bctypes
  USE blockpointers
  USE communication
  USE inputtimespectral
  IMPLICIT NONE
!     enddo domains
!  enddo spectralLoop
!!$!
!!$!      ******************************************************************
!!$!      *                                                                *
!!$!      * Exchange the coordinates for the internal halo's.              *
!!$!      *                                                                *
!!$!      ******************************************************************
!!$!
!!$   call exchangeCoor(level)
  INTEGER(KIND=INTTYPE), INTENT(IN) :: icell
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jcell
  INTEGER(KIND=INTTYPE), INTENT(IN) :: kcell
  REAL(KIND=REALTYPE) :: xadj(-3:2, -3:2, -3:2, 3), xadjb(-3:2, -3:2, -3&
&  :2, 3)
  REAL(KIND=REALTYPE) :: xblockcorneradj(2, 2, 2, 3), xblockcorneradjb(2&
&  , 2, 2, 3)
  INTEGER :: ad_from, ad_from0, ad_to, ad_to0, branch
  INTEGER(KIND=INTTYPE) :: ibeg, iend, iimax, jbeg, jend, jjmax
  LOGICAL :: imaxoverlap, iminoverlap, jmaxoverlap, jminoverlap, &
&  kmaxoverlap, kminoverlap
  INTEGER(KIND=INTTYPE) :: ioffset, joffset, koffset
  INTEGER(KIND=INTTYPE) :: istart, jstart
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, mm, nn, sps
  REAL(KIND=REALTYPE) :: dot, dotb, length, lengthb, tempb, tempb0
  REAL(KIND=REALTYPE) :: norm(3), normb(3), v1(3), v1b(3), v2(3), v2b(3)
  REAL(KIND=REALTYPE) :: x0(-3:2, -3:2, 3), x0b(-3:2, -3:2, 3), x1(-3:2&
&  , -3:2, 3), x1b(-3:2, -3:2, 3), x2(-3:2, -3:2, 3), x2b(-3:2, -3:2, 3)
  REAL(KIND=REALTYPE) :: xfacecorner(2, 2, 3), xfacecornerb(2, 2, 3)
  EXTERNAL CHECKXOVERLAPADJ
  INTRINSIC MAX, MIN, SQRT
!
!      ******************************************************************
!      *                                                                *
!      * xhaloAdj determines the coordinates of the nodal halo's.       *
!      * First it sets all halo coordinates by simple extrapolation,    *
!      * then the symmetry planes are treated (also the unit normal of  *
!      * symmetry planes are determined) the internal halo exchange is  *
!      * ignored. The global indexing in the derivatives takes care of  *
!      * this.                                                          *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
!integer(kind=intType) :: level
!
!      Local variables.
!
!integer(kind=intType) :: iBeg2, iEnd2, jBeg2, jEnd2
!real(kind=realType), dimension(:,:,:), pointer :: x0, x1, x2
!,iend,jend
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
!!$       ! Loop over the number of spectral solutions and the local
!!$       ! number of blocks.
!!$
!!$       spectralLoop: do sps=1,nTimeIntervalsSpectral
!!$         domains: do nn=1,nDom
!!$
!!$           ! Set the pointers to this block.
!!$
!!$           call setPointers(nn, level, sps)
!!$
!Check to see if current cell contains a halo and if so which one...
  CALL CHECKXOVERLAPADJ(icell, jcell, kcell, ioffset, joffset, koffset, &
&                  iminoverlap, jminoverlap, kminoverlap, imaxoverlap, &
&                  jmaxoverlap, kmaxoverlap)
!
!          **************************************************************
!          *                                                            *
!          * Extrapolation of the coordinates. First extrapolation in   *
!          * i-direction, without halo's, followed by extrapolation in  *
!          * j-direction, with i-halo's and finally extrapolation in    *
!          * k-direction, with both i- and j-halo's. In this way also   *
!          * the indirect halo's get a value, albeit a bit arbitrary.   *
!          *                                                            *
!          **************************************************************
!
! Extrapolation in i-direction.
  IF (iminoverlap) THEN
    IF (ioffset .GE. -3) THEN
      DO j=-3,2
        DO k=-3,2
          xadj(ioffset, j, k, 1) = two*xadj(ioffset+1, j, k, 1) - xadj(&
&            ioffset+2, j, k, 1)
          xadj(ioffset, j, k, 2) = two*xadj(ioffset+1, j, k, 2) - xadj(&
&            ioffset+2, j, k, 2)
          xadj(ioffset, j, k, 3) = two*xadj(ioffset+1, j, k, 3) - xadj(&
&            ioffset+2, j, k, 3)
        END DO
      END DO
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (imaxoverlap) THEN
    IF (ioffset .LE. 2) THEN
      DO j=-3,2
        DO k=-3,2
          xadj(ioffset, j, k, 1) = two*xadj(ioffset-1, j, k, 1) - xadj(&
&            ioffset-2, j, k, 1)
          xadj(ioffset, j, k, 2) = two*xadj(ioffset-1, j, k, 2) - xadj(&
&            ioffset-2, j, k, 2)
          xadj(ioffset, j, k, 3) = two*xadj(ioffset-1, j, k, 3) - xadj(&
&            ioffset-2, j, k, 3)
        END DO
      END DO
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
!!$           do k=1,kl
!!$             do j=1,jl
!!$               x(0,j,k,1) = two*x(1,j,k,1) - x(2,j,k,1)
!!$               x(0,j,k,2) = two*x(1,j,k,2) - x(2,j,k,2)
!!$               x(0,j,k,3) = two*x(1,j,k,3) - x(2,j,k,3)
!!$
!!$               x(ie,j,k,1) = two*x(il,j,k,1) - x(nx,j,k,1)
!!$               x(ie,j,k,2) = two*x(il,j,k,2) - x(nx,j,k,2)
!!$               x(ie,j,k,3) = two*x(il,j,k,3) - x(nx,j,k,3)
!!$             enddo
!!$           enddo
! Extrapolation in j-direction.
  IF (jminoverlap) THEN
    IF (joffset .GE. -3) THEN
      DO i=-3,2
        DO k=-3,2
          xadj(i, joffset, k, 1) = two*xadj(i, joffset+1, k, 1) - xadj(i&
&            , joffset+2, k, 1)
          xadj(i, joffset, k, 2) = two*xadj(i, joffset+1, k, 2) - xadj(i&
&            , joffset+2, k, 2)
          xadj(i, joffset, k, 3) = two*xadj(i, joffset+1, k, 3) - xadj(i&
&            , joffset+2, k, 3)
        END DO
      END DO
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (jmaxoverlap) THEN
    IF (joffset .LE. 2) THEN
      DO k=-3,2
        DO i=-3,2
          xadj(i, joffset, k, 1) = two*xadj(i, joffset-1, k, 1) - xadj(i&
&            , joffset-2, k, 1)
          xadj(i, joffset, k, 2) = two*xadj(i, joffset-1, k, 2) - xadj(i&
&            , joffset-2, k, 2)
          xadj(i, joffset, k, 3) = two*xadj(i, joffset-1, k, 3) - xadj(i&
&            , joffset-2, k, 3)
        END DO
      END DO
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
!!$           do k=1,kl
!!$             do i=0,ie
!!$               x(i,0,k,1) = two*x(i,1,k,1) - x(i,2,k,1)
!!$               x(i,0,k,2) = two*x(i,1,k,2) - x(i,2,k,2)
!!$               x(i,0,k,3) = two*x(i,1,k,3) - x(i,2,k,3)
!!$
!!$               x(i,je,k,1) = two*x(i,jl,k,1) - x(i,ny,k,1)
!!$               x(i,je,k,2) = two*x(i,jl,k,2) - x(i,ny,k,2)
!!$               x(i,je,k,3) = two*x(i,jl,k,3) - x(i,ny,k,3)
!!$             enddo
!!$           enddo
! Extrapolation in k-direction.
  IF (kminoverlap) THEN
    IF (koffset .GE. -3) THEN
      DO j=-3,2
        DO i=-3,2
          xadj(i, j, koffset, 1) = two*xadj(i, j, koffset+1, 1) - xadj(i&
&            , j, koffset+2, 1)
          xadj(i, j, koffset, 2) = two*xadj(i, j, koffset+1, 2) - xadj(i&
&            , j, koffset+2, 2)
          xadj(i, j, koffset, 3) = two*xadj(i, j, koffset+1, 3) - xadj(i&
&            , j, koffset+2, 3)
        END DO
      END DO
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (kmaxoverlap) THEN
    IF (koffset .LE. 2) THEN
      DO j=-3,2
        DO i=-3,2
          xadj(i, j, koffset, 1) = two*xadj(i, j, koffset-1, 1) - xadj(i&
&            , j, koffset-2, 1)
          xadj(i, j, koffset, 2) = two*xadj(i, j, koffset-1, 2) - xadj(i&
&            , j, koffset-2, 2)
          xadj(i, j, koffset, 3) = two*xadj(i, j, koffset-1, 3) - xadj(i&
&            , j, koffset-2, 3)
        END DO
      END DO
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
!!$           do j=0,je
!!$             do i=0,ie
!!$               x(i,j,0,1) = two*x(i,j,1,1) - x(i,j,2,1)
!!$               x(i,j,0,2) = two*x(i,j,1,2) - x(i,j,2,2)
!!$               x(i,j,0,3) = two*x(i,j,1,3) - x(i,j,2,3)
!!$
!!$               x(i,j,ke,1) = two*x(i,j,kl,1) - x(i,j,nz,1)
!!$               x(i,j,ke,2) = two*x(i,j,kl,2) - x(i,j,nz,2)
!!$               x(i,j,ke,3) = two*x(i,j,kl,3) - x(i,j,nz,3)
!!$             enddo
!!$           enddo
!
!          **************************************************************
!          *                                                            *
!          * Mirror the halo coordinates adjacent to the symmetry       *
!          * planes                                                     *
!          *                                                            *
!          **************************************************************
!
! Loop over boundary subfaces.
loopbocos:DO mm=1,nbocos
! The actual correction of the coordinates only takes
! place for symmetry planes.
    IF (bctype(mm) .EQ. symm) THEN
!!$               ! Set some variables, depending on the block face on
!!$               ! which the subface is located.
!!$
!!$               select case (BCFaceID(mm))
!!$                 case (iMin)
!!$                   iBeg = jnBeg(mm); iEnd = jnEnd(mm); iiMax = jl
!!$                   jBeg = knBeg(mm); jEnd = knEnd(mm); jjMax = kl
!!$                   x0 => x(0,:,:,:); x1 => x(1,:,:,:); x2 => x(2,:,:,:)
!!$
!!$                 case (iMax)
!!$                   iBeg = jnBeg(mm); iEnd = jnEnd(mm); iiMax = jl
!!$                   jBeg = knBeg(mm); jEnd = knEnd(mm); jjMax = kl
!!$                   x0 => x(ie,:,:,:); x1 => x(il,:,:,:); x2 => x(nx,:,:,:)
!!$
!!$                 case (jMin)
!!$                   iBeg = inBeg(mm); iEnd = inEnd(mm); iiMax = il
!!$                   jBeg = knBeg(mm); jEnd = knEnd(mm); jjMax = kl
!!$                   x0 => x(:,0,:,:); x1 => x(:,1,:,:); x2 => x(:,2,:,:)
!!$
!!$                 case (jMax)
!!$                   iBeg = inBeg(mm); iEnd = inEnd(mm); iiMax = il
!!$                   jBeg = knBeg(mm); jEnd = knEnd(mm); jjMax = kl
!!$                   x0 => x(:,je,:,:); x1 => x(:,jl,:,:); x2 => x(:,ny,:,:)
!!$
!!$                 case (kMin)
!!$                   iBeg = inBeg(mm); iEnd = inEnd(mm); iiMax = il
!!$                   jBeg = jnBeg(mm); jEnd = jnEnd(mm); jjMax = jl
!!$                   x0 => x(:,:,0,:); x1 => x(:,:,1,:); x2 => x(:,:,2,:)
!!$
!!$                 case (kMax)
!!$                   iBeg = inBeg(mm); iEnd = inEnd(mm); iiMax = il
!!$                   jBeg = jnBeg(mm); jEnd = jnEnd(mm); jjMax = jl
!!$                   x0 => x(:,:,ke,:); x1 => x(:,:,kl,:); x2 => x(:,:,nz,:)
!!$               end select
! Set some variables, depending on the block face on
! which the subface is located.
      istart = -3
      iend = 2
      jstart = -3
      jend = 2
      SELECT CASE  (bcfaceid(mm)) 
      CASE (imin) 
        IF (-3 .LT. 2 - jcell - 2) THEN
          istart = 2 - jcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          istart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (-3 .LT. 2 - kcell - 2) THEN
          jstart = 2 - kcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          jstart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. jl - jcell + 1) THEN
          iend = jl - jcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          iend = 2
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. kl - kcell + 1) THEN
          jend = kl - kcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          jend = 2
          CALL PUSHINTEGER4(0)
        END IF
!print *,'bcfaceID,imin',BCFaceID(mm),imin,iMinOverlap,icell,jcell,kcell
        IF (iminoverlap) THEN
          xfacecorner(:, :, :) = xblockcorneradj(1, :, :, :)
          IF (icell .EQ. 2) THEN
            x0(-3:2, -3:2, 1:3) = xadj(-2, -3:2, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-1, -3:2, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(0, -3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(1)
          ELSE
            x0(-3:2, -3:2, 1:3) = xadj(-3, -3:2, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-2, -3:2, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-1, -3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(2)
          END IF
        ELSE
          CALL PUSHINTEGER4(4)
          GOTO 100
        END IF
      CASE (imax) 
!skip remainder of loop
!print *,'cycling imin'
        IF (-3 .LT. 2 - jcell - 2) THEN
          istart = 2 - jcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          istart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (-3 .LT. 2 - kcell - 2) THEN
          jstart = 2 - kcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          jstart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. jl - jcell + 1) THEN
          iend = jl - jcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          iend = 2
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. kl - kcell + 1) THEN
          jend = kl - kcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          jend = 2
          CALL PUSHINTEGER4(0)
        END IF
!print *,'bcfaceID,imax',BCFaceID(mm),imax,iMaxOverlap,icell,jcell,kcell
        IF (imaxoverlap) THEN
          xfacecorner(:, :, :) = xblockcorneradj(2, :, :, :)
          IF (icell .EQ. il) THEN
            x0(-3:2, -3:2, 1:3) = xadj(1, -3:2, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(0, -3:2, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-1, -3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(3)
          ELSE
            x0(-3:2, -3:2, 1:3) = xadj(2, -3:2, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(1, -3:2, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(0, -3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(4)
          END IF
        ELSE
          CALL PUSHINTEGER4(5)
          GOTO 100
        END IF
      CASE (jmin) 
!skip remainder of loop
!print *,'cycling imax'
        IF (-3 .LT. 2 - icell - 2) THEN
          istart = 2 - icell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          istart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (-3 .LT. 2 - kcell - 2) THEN
          jstart = 2 - kcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          jstart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. il - icell + 1) THEN
          iend = il - icell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          iend = 2
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. kl - kcell + 1) THEN
          jend = kl - kcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          jend = 2
          CALL PUSHINTEGER4(0)
        END IF
!print *,'bcfaceID,jmin',BCFaceID(mm),jmin,jMinOverlap,icell,jcell,kcell
        IF (jminoverlap) THEN
          xfacecorner(:, :, :) = xblockcorneradj(:, 1, :, :)
          IF (jcell .EQ. 2) THEN
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, -2, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, -1, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, 0, -3:2, 1:3)
            CALL PUSHINTEGER4(5)
          ELSE
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, -3, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, -2, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, -1, -3:2, 1:3)
            CALL PUSHINTEGER4(6)
          END IF
        ELSE
          CALL PUSHINTEGER4(6)
          GOTO 100
        END IF
      CASE (jmax) 
!skip remainder of loop
!print *,'cycling jmin'
        IF (-3 .LT. 2 - icell - 2) THEN
          istart = 2 - icell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          istart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (-3 .LT. 2 - kcell - 2) THEN
          jstart = 2 - kcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          jstart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. il - icell + 1) THEN
          iend = il - icell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          iend = 2
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. kl - kcell + 1) THEN
          jend = kl - kcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          jend = 2
          CALL PUSHINTEGER4(0)
        END IF
!print *,'bcfaceID,jmax',BCFaceID(mm),jmax,jMaxOverlap,icell,jcell,kcell
        IF (jmaxoverlap) THEN
          xfacecorner(:, :, :) = xblockcorneradj(:, 2, :, :)
          IF (jcell .EQ. jl) THEN
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, 1, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, 0, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, -1, -3:2, 1:3)
            CALL PUSHINTEGER4(7)
          ELSE
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, 2, -3:2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, 1, -3:2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, 0, -3:2, 1:3)
            CALL PUSHINTEGER4(8)
          END IF
        ELSE
          CALL PUSHINTEGER4(7)
          GOTO 100
        END IF
      CASE (kmin) 
!skip remainder of loop
!print *,'cycling jmax'
        IF (-3 .LT. 2 - icell - 2) THEN
          istart = 2 - icell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          istart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (-3 .LT. 2 - jcell - 2) THEN
          jstart = 2 - jcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          jstart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. il - icell + 1) THEN
          iend = il - icell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          iend = 2
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. jl - jcell + 1) THEN
          jend = jl - jcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          jend = 2
          CALL PUSHINTEGER4(0)
        END IF
!print *,'bcfaceID,kmin',BCFaceID(mm),kmin,kMinOverlap,icell,jcell,kcell
        IF (kminoverlap) THEN
          xfacecorner(:, :, :) = xblockcorneradj(:, :, 1, :)
          IF (kcell .EQ. 2) THEN
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, -2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, -1, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, 0, 1:3)
            CALL PUSHINTEGER4(9)
          ELSE
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, -3, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, -2, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, -1, 1:3)
            CALL PUSHINTEGER4(10)
          END IF
        ELSE
          CALL PUSHINTEGER4(8)
          GOTO 100
        END IF
      CASE (kmax) 
!skip remainder of loop
!print *,'cycling kmin'
        IF (-3 .LT. 2 - icell - 2) THEN
          istart = 2 - icell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          istart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (-3 .LT. 2 - jcell - 2) THEN
          jstart = 2 - jcell - 2
          CALL PUSHINTEGER4(1)
        ELSE
          jstart = -3
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. il - icell + 1) THEN
          iend = il - icell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          iend = 2
          CALL PUSHINTEGER4(0)
        END IF
        IF (2 .GT. jl - jcell + 1) THEN
          jend = jl - jcell + 1
          CALL PUSHINTEGER4(1)
        ELSE
          jend = 2
          CALL PUSHINTEGER4(0)
        END IF
!print *,'bcfaceID,kmax',BCFaceID(mm),kmax,kMaxOverlap,icell,jcell,kcell
        IF (kmaxoverlap) THEN
          xfacecorner(:, :, :) = xblockcorneradj(:, :, 2, :)
          IF (kcell .EQ. kl) THEN
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, 1, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, 0, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, -1, 1:3)
            CALL PUSHINTEGER4(11)
          ELSE
            x0(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, 2, 1:3)
            x1(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, 1, 1:3)
            x2(-3:2, -3:2, 1:3) = xadj(-3:2, -3:2, 0, 1:3)
            CALL PUSHINTEGER4(12)
          END IF
        ELSE
          CALL PUSHINTEGER4(9)
          GOTO 100
        END IF
      CASE DEFAULT
        CALL PUSHINTEGER4(0)
      END SELECT
      CALL PUSHREAL8(v1(1))
!skip remainder of loop
!print *,'cycling kmax'
!CAM commented out on Aug. 11, 2009 by C.A.Mader. Computation modified to fit 
!CAM into a single residual stencil...
!!$
!!$               ! Determine the sum of all face normals and store this
!!$               ! in norm. The sum of all faces is taken instead of the
!!$               ! cross product of the diagonals, because for some c-type
!!$               ! grids the diagonals of the subface are aligned.
!!$
!!$               norm = zero
!!$
!!$               do j=(jBeg+1),jEnd
!!$                 do i=(iBeg+1),iEnd
!!$
!!$                   ! Determine the vector from the lower left corner to
!!$                   ! the upper right corner. Due to the usage of pointers
!!$                   ! an offset of +1 must be used, because the original
!!$                   ! array x start at 0.
!!$
!!$                   v1(1) = x1(i+1,j+1,1) - x1(i,j,1)
!!$                   v1(2) = x1(i+1,j+1,2) - x1(i,j,2)
!!$                   v1(3) = x1(i+1,j+1,3) - x1(i,j,3)
!!$                   
!!$                   ! And the vector from the upper left corner to the
!!$                   ! lower right corner.
!!$
!!$                   v2(1) = x1(i+1,j,1) - x1(i,j+1,1)
!!$                   v2(2) = x1(i+1,j,2) - x1(i,j+1,2)
!!$                   v2(3) = x1(i+1,j,3) - x1(i,j+1,3)
!!$                   
!!$                   ! Determine the normal of the face by taking the cross
!!$                   ! product of v1 and v2 and add it to norm.
!!$
!!$                   norm(1) = norm(1) + v1(2)*v2(3) - v1(3)*v2(2)
!!$                   norm(2) = norm(2) + v1(3)*v2(1) - v1(1)*v2(3)
!!$                   norm(3) = norm(3) + v1(1)*v2(2) - v1(2)*v2(1)
!!$                   print *,'norm', x1(i+1,j+1,1) ,x1(i,j,1) ,norm(1),norm(2),norm(3),i,j,BCFaceID(mm)
!!$                 enddo
!!$               enddo
!!$
!!$               ! Compute the length of the normal and test if this is
!!$               ! larger than eps. If this is the case this means that
!!$               ! it is a nonsingular subface and the coordinates are
!!$               ! corrected.
!!$
!!$               length = sqrt(norm(1)**2 + norm(2)**2 + norm(3)**2)
!!$
!!$               testSingular: if(length > eps) then
!!$
!!$                 ! Compute the unit normal of the subface.
!!$
!!$                 norm(1) = norm(1)/length
!!$                 norm(2) = norm(2)/length
!!$                 norm(3) = norm(3)/length
!!$
!!$                 ! Add an overlap to the symmetry subface if the
!!$                 ! boundaries coincide with the block boundaries.
!!$                 ! This way the indirect halo's are treated properly.
!!$
!!$                 if(iBeg == 1)     iBeg = 0
!!$                 if(iEnd == iiMax) iEnd = iiMax + 1
!!$
!!$                 if(jBeg == 1)     jBeg = 0
!!$                 if(jEnd == jjMax) jEnd = jjMax + 1
!!$
!!$                 ! Loop over the nodes of the subface and set the
!!$                 ! corresponding halo coordinates.
!!$
!!$                 do j=jBeg,jEnd
!!$                   do i=iBeg,iEnd
!!$
!!$                     ! Determine the vector from the internal node to the
!!$                     ! node on the face. Again an offset of +1 must be
!!$                     ! used, due to the usage of pointers.
!!$
!!$                     v1(1) = x1(i+1,j+1,1) - x2(i+1,j+1,1)
!!$                     v1(2) = x1(i+1,j+1,2) - x2(i+1,j+1,2)
!!$                     v1(3) = x1(i+1,j+1,3) - x2(i+1,j+1,3)
!!$
!!$                     ! Determine two times the normal component of this
!!$                     ! vector; this vector must be added to the
!!$                     ! coordinates of the internal node to obtain the
!!$                     ! halo coordinates. Again the offset of +1.
!!$
!!$                     dot = two*(v1(1)*norm(1) + v1(2)*norm(2) &
!!$                         +      v1(3)*norm(3))
!!$
!!$                     x0(i+1,j+1,1) = x2(i+1,j+1,1) + dot*norm(1)
!!$                     x0(i+1,j+1,2) = x2(i+1,j+1,2) + dot*norm(2)
!!$                     x0(i+1,j+1,3) = x2(i+1,j+1,3) + dot*norm(3)
!!$                     print *,'xhalo', x0(i+1,j+1,1) ,x2(i+1,j+1,1) , dot,norm(1),i,j,BCFaceID(mm)
!!$
!!$                   enddo
!!$                 enddo
!!$
!!$                endif testSingular
!compute a norm from the 4 corners of the subface. This
! will serve to check the subface for singularity and
!reduce the number of points to be dealt with in the derivatives
! Determine the vector from the lower left corner to
! the upper right corner. Due to the usage of pointers
! an offset of +1 must be used, because the original
! array x start at 0.
      v1(1) = xfacecorner(2, 2, 1) - xfacecorner(1, 1, 1)
      CALL PUSHREAL8(v1(2))
      v1(2) = xfacecorner(2, 2, 2) - xfacecorner(1, 1, 2)
      CALL PUSHREAL8(v1(3))
      v1(3) = xfacecorner(2, 2, 3) - xfacecorner(1, 1, 3)
      CALL PUSHREAL8(v2(1))
!print *,'v1adj',v1,xFaceCorner(2,2,1), xFaceCorner(1,1,1)
! And the vector from the upper left corner to the
! lower right corner.
      v2(1) = xfacecorner(2, 1, 1) - xfacecorner(1, 2, 1)
      CALL PUSHREAL8(v2(2))
      v2(2) = xfacecorner(2, 1, 2) - xfacecorner(1, 2, 2)
      CALL PUSHREAL8(v2(3))
      v2(3) = xfacecorner(2, 1, 3) - xfacecorner(1, 2, 3)
      CALL PUSHREAL8(norm(1))
!               print *,'v2adj',v2    
! Determine the normal of the face by taking the cross
! product of v1 and v2 and add it to norm.
      norm(1) = v1(2)*v2(3) - v1(3)*v2(2)
      CALL PUSHREAL8(norm(2))
      norm(2) = v1(3)*v2(1) - v1(1)*v2(3)
      CALL PUSHREAL8(norm(3))
      norm(3) = v1(1)*v2(2) - v1(2)*v2(1)
      CALL PUSHREAL8(length)
!print *,'normadj',norm
! Compute the length of the normal and test if this is
! larger than eps. If this is the case this means that
! it is a nonsingular subface and the coordinates are
! corrected.
      length = SQRT(norm(1)**2 + norm(2)**2 + norm(3)**2)
      IF (length .GT. eps) THEN
        CALL PUSHREAL8(norm(1))
! Compute the unit normal of the subface.
        norm(1) = norm(1)/length
        CALL PUSHREAL8(norm(2))
        norm(2) = norm(2)/length
        CALL PUSHREAL8(norm(3))
        norm(3) = norm(3)/length
        ad_from = jstart
!!$                  ! Add an overlap to the symmetry subface if the
!!$                  ! boundaries coincide with the block boundaries.
!!$                  ! This way the indirect halo's are treated properly.
!!$                  
!!$                  if(iBeg == 1)     iBeg = 0
!!$                  if(iEnd == iiMax) iEnd = iiMax + 1
!!$                  
!!$                  if(jBeg == 1)     jBeg = 0
!!$                  if(jEnd == jjMax) jEnd = jjMax + 1
! Loop over the nodes of the subface and set the
! corresponding halo coordinates.
!jBeg,jEnd
        DO j=ad_from,jend
          ad_from0 = istart
!iBeg,iEnd
          DO i=ad_from0,iend
            CALL PUSHREAL8(v1(1))
! Determine the vector from the internal node to the
! node on the face. Again an offset of +1 must be
! used, due to the usage of pointers.
!!$                        v1(1) = x1(i+1,j+1,1) - x2(i+1,j+1,1)
!!$                        v1(2) = x1(i+1,j+1,2) - x2(i+1,j+1,2)
!!$                        v1(3) = x1(i+1,j+1,3) - x2(i+1,j+1,3)
            v1(1) = x1(i, j, 1) - x2(i, j, 1)
            CALL PUSHREAL8(v1(2))
            v1(2) = x1(i, j, 2) - x2(i, j, 2)
            CALL PUSHREAL8(v1(3))
            v1(3) = x1(i, j, 3) - x2(i, j, 3)
            CALL PUSHREAL8(dot)
! Determine two times the normal component of this
! vector; this vector must be added to the
! coordinates of the internal node to obtain the
! halo coordinates. Again the offset of +1.
            dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
!x0(i+1,j+1,1) = x2(i+1,j+1,1) + dot*norm(1)
!x0(i+1,j+1,2) = x2(i+1,j+1,2) + dot*norm(2)
!x0(i+1,j+1,3) = x2(i+1,j+1,3) + dot*norm(3)
            x0(i, j, 1) = x2(i, j, 1) + dot*norm(1)
            x0(i, j, 2) = x2(i, j, 2) + dot*norm(2)
            x0(i, j, 3) = x2(i, j, 3) + dot*norm(3)
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from0)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
!print *,'xhaloAdj', x0(i,j,1) ,x2(i,j,1) , dot,norm(1),icell+i,jcell+j,BCFaceID(mm)
! Reset modified xAdj, depending on the block face on
! which the subface is located.
      SELECT CASE  (bcfaceid(mm)) 
      CASE (imin) 
        IF (iminoverlap) THEN
          IF (icell .EQ. 2) THEN
            xadj(-2, -3:2, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-1, -3:2, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(0, -3:2, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(12)
          ELSE
            xadj(-3, -3:2, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-2, -3:2, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-1, -3:2, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(13)
          END IF
        ELSE
          CALL PUSHINTEGER4(11)
        END IF
      CASE (imax) 
        IF (imaxoverlap) THEN
          IF (icell .EQ. il) THEN
            xadj(1, -3:2, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(0, -3:2, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-1, -3:2, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(15)
          ELSE
            xadj(2, -3:2, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(1, -3:2, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(0, -3:2, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(16)
          END IF
        ELSE
          CALL PUSHINTEGER4(14)
        END IF
      CASE (jmin) 
        IF (jminoverlap) THEN
          IF (jcell .EQ. 2) THEN
            xadj(-3:2, -2, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, -1, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, 0, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(18)
          ELSE
            xadj(-3:2, -3, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, -2, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, -1, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(19)
          END IF
        ELSE
          CALL PUSHINTEGER4(17)
        END IF
      CASE (jmax) 
        IF (jmaxoverlap) THEN
          IF (jcell .EQ. jl) THEN
            xadj(-3:2, 1, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, 0, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, -1, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(21)
          ELSE
            xadj(-3:2, 2, -3:2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, 1, -3:2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, 0, -3:2, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(22)
          END IF
        ELSE
          CALL PUSHINTEGER4(20)
        END IF
      CASE (kmin) 
        IF (kminoverlap) THEN
          IF (kcell .EQ. 2) THEN
            xadj(-3:2, -3:2, -2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, -1, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, 0, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(24)
          ELSE
            xadj(-3:2, -3:2, -3, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, -2, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, -1, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(25)
          END IF
        ELSE
          CALL PUSHINTEGER4(23)
        END IF
      CASE (kmax) 
        IF (kmaxoverlap) THEN
          IF (kcell .EQ. kl) THEN
            xadj(-3:2, -3:2, 1, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, 0, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, -1, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(27)
          ELSE
            xadj(-3:2, -3:2, 2, 1:3) = x0(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, 1, 1:3) = x1(-3:2, -3:2, 1:3)
            xadj(-3:2, -3:2, 0, 1:3) = x2(-3:2, -3:2, 1:3)
            CALL PUSHINTEGER4(28)
          END IF
        ELSE
          CALL PUSHINTEGER4(26)
        END IF
      CASE DEFAULT
        CALL PUSHINTEGER4(10)
      END SELECT
    ELSE
      CALL PUSHINTEGER4(3)
    END IF
 100 CONTINUE
  END DO loopbocos
  xblockcorneradjb(1:2, 1:2, 1:2, 1:3) = 0.0
  v1b(1:3) = 0.0
  v2b(1:3) = 0.0
  xfacecornerb(1:2, 1:2, 1:3) = 0.0
  normb(1:3) = 0.0
  x0b(-3:2, -3:2, 1:3) = 0.0
  x1b(-3:2, -3:2, 1:3) = 0.0
  x2b(-3:2, -3:2, 1:3) = 0.0
  DO mm=nbocos,1,-1
    CALL POPINTEGER4(branch)
    IF (branch .LT. 16) THEN
      IF (branch .LT. 10) THEN
        IF (branch .LT. 7) THEN
          IF (branch .LT. 5) THEN
            IF (branch .LT. 4) THEN
              GOTO 190
            ELSE
              GOTO 180
            END IF
          ELSE IF (branch .LT. 6) THEN
            GOTO 170
          ELSE
            GOTO 160
          END IF
        ELSE IF (branch .LT. 9) THEN
          IF (branch .LT. 8) THEN
            GOTO 150
          ELSE
            GOTO 140
          END IF
        ELSE
          GOTO 130
        END IF
      ELSE IF (branch .LT. 13) THEN
        IF (.NOT.branch .LT. 12) THEN
          x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(0, -3:2, -&
&            3:2, 1:3)
          xadjb(0, -3:2, -3:2, 1:3) = 0.0
          x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-1, -3:2, &
&            -3:2, 1:3)
          xadjb(-1, -3:2, -3:2, 1:3) = 0.0
          x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-2, -3:2, &
&            -3:2, 1:3)
          xadjb(-2, -3:2, -3:2, 1:3) = 0.0
        END IF
      ELSE IF (branch .LT. 15) THEN
        IF (branch .LT. 14) THEN
          x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-1, -3:2, &
&            -3:2, 1:3)
          xadjb(-1, -3:2, -3:2, 1:3) = 0.0
          x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-2, -3:2, &
&            -3:2, 1:3)
          xadjb(-2, -3:2, -3:2, 1:3) = 0.0
          x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3, -3:2, &
&            -3:2, 1:3)
          xadjb(-3, -3:2, -3:2, 1:3) = 0.0
        END IF
      ELSE
        x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-1, -3:2, -3&
&          :2, 1:3)
        xadjb(-1, -3:2, -3:2, 1:3) = 0.0
        x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(0, -3:2, -3:&
&          2, 1:3)
        xadjb(0, -3:2, -3:2, 1:3) = 0.0
        x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(1, -3:2, -3:&
&          2, 1:3)
        xadjb(1, -3:2, -3:2, 1:3) = 0.0
      END IF
    ELSE IF (branch .LT. 23) THEN
      IF (branch .LT. 20) THEN
        IF (branch .LT. 18) THEN
          IF (branch .LT. 17) THEN
            x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(0, -3:2&
&              , -3:2, 1:3)
            xadjb(0, -3:2, -3:2, 1:3) = 0.0
            x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(1, -3:2&
&              , -3:2, 1:3)
            xadjb(1, -3:2, -3:2, 1:3) = 0.0
            x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(2, -3:2&
&              , -3:2, 1:3)
            xadjb(2, -3:2, -3:2, 1:3) = 0.0
          END IF
        ELSE IF (branch .LT. 19) THEN
          x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, 0, -&
&            3:2, 1:3)
          xadjb(-3:2, 0, -3:2, 1:3) = 0.0
          x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, -1, &
&            -3:2, 1:3)
          xadjb(-3:2, -1, -3:2, 1:3) = 0.0
          x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, -2, &
&            -3:2, 1:3)
          xadjb(-3:2, -2, -3:2, 1:3) = 0.0
        ELSE
          x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, -1, &
&            -3:2, 1:3)
          xadjb(-3:2, -1, -3:2, 1:3) = 0.0
          x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, -2, &
&            -3:2, 1:3)
          xadjb(-3:2, -2, -3:2, 1:3) = 0.0
          x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3, &
&            -3:2, 1:3)
          xadjb(-3:2, -3, -3:2, 1:3) = 0.0
        END IF
      ELSE IF (branch .LT. 22) THEN
        IF (.NOT.branch .LT. 21) THEN
          x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, -1, &
&            -3:2, 1:3)
          xadjb(-3:2, -1, -3:2, 1:3) = 0.0
          x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, 0, -&
&            3:2, 1:3)
          xadjb(-3:2, 0, -3:2, 1:3) = 0.0
          x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, 1, -&
&            3:2, 1:3)
          xadjb(-3:2, 1, -3:2, 1:3) = 0.0
        END IF
      ELSE
        x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, 0, -3:&
&          2, 1:3)
        xadjb(-3:2, 0, -3:2, 1:3) = 0.0
        x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, 1, -3:&
&          2, 1:3)
        xadjb(-3:2, 1, -3:2, 1:3) = 0.0
        x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, 2, -3:&
&          2, 1:3)
        xadjb(-3:2, 2, -3:2, 1:3) = 0.0
      END IF
    ELSE IF (branch .LT. 26) THEN
      IF (branch .LT. 25) THEN
        IF (.NOT.branch .LT. 24) THEN
          x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2&
&            , 0, 1:3)
          xadjb(-3:2, -3:2, 0, 1:3) = 0.0
          x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2&
&            , -1, 1:3)
          xadjb(-3:2, -3:2, -1, 1:3) = 0.0
          x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2&
&            , -2, 1:3)
          xadjb(-3:2, -3:2, -2, 1:3) = 0.0
        END IF
      ELSE
        x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, &
&          -1, 1:3)
        xadjb(-3:2, -3:2, -1, 1:3) = 0.0
        x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, &
&          -2, 1:3)
        xadjb(-3:2, -3:2, -2, 1:3) = 0.0
        x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, &
&          -3, 1:3)
        xadjb(-3:2, -3:2, -3, 1:3) = 0.0
      END IF
    ELSE IF (branch .LT. 28) THEN
      IF (.NOT.branch .LT. 27) THEN
        x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, &
&          -1, 1:3)
        xadjb(-3:2, -3:2, -1, 1:3) = 0.0
        x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, &
&          0, 1:3)
        xadjb(-3:2, -3:2, 0, 1:3) = 0.0
        x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, &
&          1, 1:3)
        xadjb(-3:2, -3:2, 1, 1:3) = 0.0
      END IF
    ELSE
      x2b(-3:2, -3:2, 1:3) = x2b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, 0&
&        , 1:3)
      xadjb(-3:2, -3:2, 0, 1:3) = 0.0
      x1b(-3:2, -3:2, 1:3) = x1b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, 1&
&        , 1:3)
      xadjb(-3:2, -3:2, 1, 1:3) = 0.0
      x0b(-3:2, -3:2, 1:3) = x0b(-3:2, -3:2, 1:3) + xadjb(-3:2, -3:2, 2&
&        , 1:3)
      xadjb(-3:2, -3:2, 2, 1:3) = 0.0
    END IF
    CALL POPINTEGER4(branch)
    IF (branch .LT. 1) THEN
      lengthb = 0.0
    ELSE
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to)
      DO j=ad_to,ad_from,-1
        CALL POPINTEGER4(ad_from0)
        CALL POPINTEGER4(ad_to0)
        DO i=ad_to0,ad_from0,-1
          x2b(i, j, 3) = x2b(i, j, 3) + x0b(i, j, 3)
          dotb = norm(3)*x0b(i, j, 3)
          normb(3) = normb(3) + dot*x0b(i, j, 3)
          x0b(i, j, 3) = 0.0
          x2b(i, j, 2) = x2b(i, j, 2) + x0b(i, j, 2)
          dotb = dotb + norm(2)*x0b(i, j, 2)
          normb(2) = normb(2) + dot*x0b(i, j, 2)
          x0b(i, j, 2) = 0.0
          x2b(i, j, 1) = x2b(i, j, 1) + x0b(i, j, 1)
          dotb = dotb + norm(1)*x0b(i, j, 1)
          tempb0 = two*dotb
          normb(1) = normb(1) + v1(1)*tempb0 + dot*x0b(i, j, 1)
          x0b(i, j, 1) = 0.0
          CALL POPREAL8(dot)
          v1b(1) = v1b(1) + norm(1)*tempb0
          v1b(2) = v1b(2) + norm(2)*tempb0
          normb(2) = normb(2) + v1(2)*tempb0
          v1b(3) = v1b(3) + norm(3)*tempb0
          normb(3) = normb(3) + v1(3)*tempb0
          CALL POPREAL8(v1(3))
          x1b(i, j, 3) = x1b(i, j, 3) + v1b(3)
          x2b(i, j, 3) = x2b(i, j, 3) - v1b(3)
          v1b(3) = 0.0
          CALL POPREAL8(v1(2))
          x1b(i, j, 2) = x1b(i, j, 2) + v1b(2)
          x2b(i, j, 2) = x2b(i, j, 2) - v1b(2)
          v1b(2) = 0.0
          CALL POPREAL8(v1(1))
          x1b(i, j, 1) = x1b(i, j, 1) + v1b(1)
          x2b(i, j, 1) = x2b(i, j, 1) - v1b(1)
          v1b(1) = 0.0
        END DO
      END DO
      CALL POPREAL8(norm(3))
      lengthb = -(norm(3)*normb(3)/length**2)
      normb(3) = normb(3)/length
      CALL POPREAL8(norm(2))
      lengthb = lengthb - norm(2)*normb(2)/length**2
      normb(2) = normb(2)/length
      CALL POPREAL8(norm(1))
      lengthb = lengthb - norm(1)*normb(1)/length**2
      normb(1) = normb(1)/length
    END IF
    CALL POPREAL8(length)
    tempb = lengthb/(2.0*SQRT(norm(1)**2+norm(2)**2+norm(3)**2))
    normb(1) = normb(1) + 2*norm(1)*tempb
    normb(2) = normb(2) + 2*norm(2)*tempb
    normb(3) = normb(3) + 2*norm(3)*tempb
    CALL POPREAL8(norm(3))
    v1b(1) = v1b(1) + v2(2)*normb(3)
    v2b(2) = v2b(2) + v1(1)*normb(3)
    v1b(2) = v1b(2) - v2(1)*normb(3)
    v2b(1) = v2b(1) - v1(2)*normb(3)
    normb(3) = 0.0
    CALL POPREAL8(norm(2))
    v1b(3) = v1b(3) + v2(1)*normb(2)
    v2b(1) = v2b(1) + v1(3)*normb(2)
    v1b(1) = v1b(1) - v2(3)*normb(2)
    v2b(3) = v2b(3) - v1(1)*normb(2)
    normb(2) = 0.0
    CALL POPREAL8(norm(1))
    v1b(2) = v1b(2) + v2(3)*normb(1)
    v2b(3) = v2b(3) + v1(2)*normb(1)
    v1b(3) = v1b(3) - v2(2)*normb(1)
    v2b(2) = v2b(2) - v1(3)*normb(1)
    normb(1) = 0.0
    CALL POPREAL8(v2(3))
    xfacecornerb(2, 1, 3) = xfacecornerb(2, 1, 3) + v2b(3)
    xfacecornerb(1, 2, 3) = xfacecornerb(1, 2, 3) - v2b(3)
    v2b(3) = 0.0
    CALL POPREAL8(v2(2))
    xfacecornerb(2, 1, 2) = xfacecornerb(2, 1, 2) + v2b(2)
    xfacecornerb(1, 2, 2) = xfacecornerb(1, 2, 2) - v2b(2)
    v2b(2) = 0.0
    CALL POPREAL8(v2(1))
    xfacecornerb(2, 1, 1) = xfacecornerb(2, 1, 1) + v2b(1)
    xfacecornerb(1, 2, 1) = xfacecornerb(1, 2, 1) - v2b(1)
    v2b(1) = 0.0
    CALL POPREAL8(v1(3))
    xfacecornerb(2, 2, 3) = xfacecornerb(2, 2, 3) + v1b(3)
    xfacecornerb(1, 1, 3) = xfacecornerb(1, 1, 3) - v1b(3)
    v1b(3) = 0.0
    CALL POPREAL8(v1(2))
    xfacecornerb(2, 2, 2) = xfacecornerb(2, 2, 2) + v1b(2)
    xfacecornerb(1, 1, 2) = xfacecornerb(1, 1, 2) - v1b(2)
    v1b(2) = 0.0
    CALL POPREAL8(v1(1))
    xfacecornerb(2, 2, 1) = xfacecornerb(2, 2, 1) + v1b(1)
    xfacecornerb(1, 1, 1) = xfacecornerb(1, 1, 1) - v1b(1)
    v1b(1) = 0.0
    CALL POPINTEGER4(branch)
    IF (branch .LT. 7) THEN
      IF (branch .LT. 4) THEN
        IF (branch .LT. 2) THEN
          IF (branch .LT. 1) THEN
            GOTO 190
          ELSE
            xadjb(0, -3:2, -3:2, 1:3) = xadjb(0, -3:2, -3:2, 1:3) + x2b(&
&              -3:2, -3:2, 1:3)
            x2b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-1, -3:2, -3:2, 1:3) = xadjb(-1, -3:2, -3:2, 1:3) + &
&              x1b(-3:2, -3:2, 1:3)
            x1b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-2, -3:2, -3:2, 1:3) = xadjb(-2, -3:2, -3:2, 1:3) + &
&              x0b(-3:2, -3:2, 1:3)
            x0b(-3:2, -3:2, 1:3) = 0.0
          END IF
        ELSE IF (branch .LT. 3) THEN
          xadjb(-1, -3:2, -3:2, 1:3) = xadjb(-1, -3:2, -3:2, 1:3) + x2b(&
&            -3:2, -3:2, 1:3)
          x2b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-2, -3:2, -3:2, 1:3) = xadjb(-2, -3:2, -3:2, 1:3) + x1b(&
&            -3:2, -3:2, 1:3)
          x1b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-3, -3:2, -3:2, 1:3) = xadjb(-3, -3:2, -3:2, 1:3) + x0b(&
&            -3:2, -3:2, 1:3)
          x0b(-3:2, -3:2, 1:3) = 0.0
        ELSE
          xadjb(-1, -3:2, -3:2, 1:3) = xadjb(-1, -3:2, -3:2, 1:3) + x2b(&
&            -3:2, -3:2, 1:3)
          x2b(-3:2, -3:2, 1:3) = 0.0
          xadjb(0, -3:2, -3:2, 1:3) = xadjb(0, -3:2, -3:2, 1:3) + x1b(-3&
&            :2, -3:2, 1:3)
          x1b(-3:2, -3:2, 1:3) = 0.0
          xadjb(1, -3:2, -3:2, 1:3) = xadjb(1, -3:2, -3:2, 1:3) + x0b(-3&
&            :2, -3:2, 1:3)
          x0b(-3:2, -3:2, 1:3) = 0.0
          GOTO 110
        END IF
        xblockcorneradjb(1, :, :, :) = xblockcorneradjb(1, :, :, :) + &
&          xfacecornerb(:, :, :)
        xfacecornerb(:, :, :) = 0.0
        GOTO 180
      ELSE
        IF (branch .LT. 6) THEN
          IF (branch .LT. 5) THEN
            xadjb(0, -3:2, -3:2, 1:3) = xadjb(0, -3:2, -3:2, 1:3) + x2b(&
&              -3:2, -3:2, 1:3)
            x2b(-3:2, -3:2, 1:3) = 0.0
            xadjb(1, -3:2, -3:2, 1:3) = xadjb(1, -3:2, -3:2, 1:3) + x1b(&
&              -3:2, -3:2, 1:3)
            x1b(-3:2, -3:2, 1:3) = 0.0
            xadjb(2, -3:2, -3:2, 1:3) = xadjb(2, -3:2, -3:2, 1:3) + x0b(&
&              -3:2, -3:2, 1:3)
            x0b(-3:2, -3:2, 1:3) = 0.0
            GOTO 110
          ELSE
            xadjb(-3:2, 0, -3:2, 1:3) = xadjb(-3:2, 0, -3:2, 1:3) + x2b(&
&              -3:2, -3:2, 1:3)
            x2b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, -1, -3:2, 1:3) = xadjb(-3:2, -1, -3:2, 1:3) + &
&              x1b(-3:2, -3:2, 1:3)
            x1b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, -2, -3:2, 1:3) = xadjb(-3:2, -2, -3:2, 1:3) + &
&              x0b(-3:2, -3:2, 1:3)
            x0b(-3:2, -3:2, 1:3) = 0.0
          END IF
        ELSE
          xadjb(-3:2, -1, -3:2, 1:3) = xadjb(-3:2, -1, -3:2, 1:3) + x2b(&
&            -3:2, -3:2, 1:3)
          x2b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-3:2, -2, -3:2, 1:3) = xadjb(-3:2, -2, -3:2, 1:3) + x1b(&
&            -3:2, -3:2, 1:3)
          x1b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-3:2, -3, -3:2, 1:3) = xadjb(-3:2, -3, -3:2, 1:3) + x0b(&
&            -3:2, -3:2, 1:3)
          x0b(-3:2, -3:2, 1:3) = 0.0
        END IF
        xblockcorneradjb(:, 1, :, :) = xblockcorneradjb(:, 1, :, :) + &
&          xfacecornerb(:, :, :)
        xfacecornerb(:, :, :) = 0.0
        GOTO 160
      END IF
 110  xblockcorneradjb(2, :, :, :) = xblockcorneradjb(2, :, :, :) + &
&        xfacecornerb(:, :, :)
      xfacecornerb(:, :, :) = 0.0
      GOTO 170
    ELSE
      IF (branch .LT. 10) THEN
        IF (branch .LT. 9) THEN
          IF (branch .LT. 8) THEN
            xadjb(-3:2, -1, -3:2, 1:3) = xadjb(-3:2, -1, -3:2, 1:3) + &
&              x2b(-3:2, -3:2, 1:3)
            x2b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, 0, -3:2, 1:3) = xadjb(-3:2, 0, -3:2, 1:3) + x1b(&
&              -3:2, -3:2, 1:3)
            x1b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, 1, -3:2, 1:3) = xadjb(-3:2, 1, -3:2, 1:3) + x0b(&
&              -3:2, -3:2, 1:3)
            x0b(-3:2, -3:2, 1:3) = 0.0
          ELSE
            xadjb(-3:2, 0, -3:2, 1:3) = xadjb(-3:2, 0, -3:2, 1:3) + x2b(&
&              -3:2, -3:2, 1:3)
            x2b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, 1, -3:2, 1:3) = xadjb(-3:2, 1, -3:2, 1:3) + x1b(&
&              -3:2, -3:2, 1:3)
            x1b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, 2, -3:2, 1:3) = xadjb(-3:2, 2, -3:2, 1:3) + x0b(&
&              -3:2, -3:2, 1:3)
            x0b(-3:2, -3:2, 1:3) = 0.0
          END IF
          xblockcorneradjb(:, 2, :, :) = xblockcorneradjb(:, 2, :, :) + &
&            xfacecornerb(:, :, :)
          xfacecornerb(:, :, :) = 0.0
          GOTO 150
        ELSE
          xadjb(-3:2, -3:2, 0, 1:3) = xadjb(-3:2, -3:2, 0, 1:3) + x2b(-3&
&            :2, -3:2, 1:3)
          x2b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-3:2, -3:2, -1, 1:3) = xadjb(-3:2, -3:2, -1, 1:3) + x1b(&
&            -3:2, -3:2, 1:3)
          x1b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-3:2, -3:2, -2, 1:3) = xadjb(-3:2, -3:2, -2, 1:3) + x0b(&
&            -3:2, -3:2, 1:3)
          x0b(-3:2, -3:2, 1:3) = 0.0
        END IF
      ELSE
        IF (branch .LT. 12) THEN
          IF (branch .LT. 11) THEN
            xadjb(-3:2, -3:2, -1, 1:3) = xadjb(-3:2, -3:2, -1, 1:3) + &
&              x2b(-3:2, -3:2, 1:3)
            x2b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, -3:2, -2, 1:3) = xadjb(-3:2, -3:2, -2, 1:3) + &
&              x1b(-3:2, -3:2, 1:3)
            x1b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, -3:2, -3, 1:3) = xadjb(-3:2, -3:2, -3, 1:3) + &
&              x0b(-3:2, -3:2, 1:3)
            x0b(-3:2, -3:2, 1:3) = 0.0
            GOTO 120
          ELSE
            xadjb(-3:2, -3:2, -1, 1:3) = xadjb(-3:2, -3:2, -1, 1:3) + &
&              x2b(-3:2, -3:2, 1:3)
            x2b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, -3:2, 0, 1:3) = xadjb(-3:2, -3:2, 0, 1:3) + x1b(&
&              -3:2, -3:2, 1:3)
            x1b(-3:2, -3:2, 1:3) = 0.0
            xadjb(-3:2, -3:2, 1, 1:3) = xadjb(-3:2, -3:2, 1, 1:3) + x0b(&
&              -3:2, -3:2, 1:3)
            x0b(-3:2, -3:2, 1:3) = 0.0
          END IF
        ELSE
          xadjb(-3:2, -3:2, 0, 1:3) = xadjb(-3:2, -3:2, 0, 1:3) + x2b(-3&
&            :2, -3:2, 1:3)
          x2b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-3:2, -3:2, 1, 1:3) = xadjb(-3:2, -3:2, 1, 1:3) + x1b(-3&
&            :2, -3:2, 1:3)
          x1b(-3:2, -3:2, 1:3) = 0.0
          xadjb(-3:2, -3:2, 2, 1:3) = xadjb(-3:2, -3:2, 2, 1:3) + x0b(-3&
&            :2, -3:2, 1:3)
          x0b(-3:2, -3:2, 1:3) = 0.0
        END IF
        xblockcorneradjb(:, :, 2, :) = xblockcorneradjb(:, :, 2, :) + &
&          xfacecornerb(:, :, :)
        xfacecornerb(:, :, :) = 0.0
        GOTO 130
      END IF
 120  xblockcorneradjb(:, :, 1, :) = xblockcorneradjb(:, :, 1, :) + &
&        xfacecornerb(:, :, :)
      xfacecornerb(:, :, :) = 0.0
      GOTO 140
    END IF
 130 CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    GOTO 190
 140 CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    GOTO 190
 150 CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    GOTO 190
 160 CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    GOTO 190
 170 CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    GOTO 190
 180 CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
 190 CONTINUE
  END DO
  CALL POPINTEGER4(branch)
  IF (.NOT.branch .LT. 2) THEN
    DO j=2,-3,-1
      DO i=2,-3,-1
        xadjb(i, j, koffset-1, 3) = xadjb(i, j, koffset-1, 3) + two*&
&          xadjb(i, j, koffset, 3)
        xadjb(i, j, koffset-2, 3) = xadjb(i, j, koffset-2, 3) - xadjb(i&
&          , j, koffset, 3)
        xadjb(i, j, koffset, 3) = 0.0
        xadjb(i, j, koffset-1, 2) = xadjb(i, j, koffset-1, 2) + two*&
&          xadjb(i, j, koffset, 2)
        xadjb(i, j, koffset-2, 2) = xadjb(i, j, koffset-2, 2) - xadjb(i&
&          , j, koffset, 2)
        xadjb(i, j, koffset, 2) = 0.0
        xadjb(i, j, koffset-1, 1) = xadjb(i, j, koffset-1, 1) + two*&
&          xadjb(i, j, koffset, 1)
        xadjb(i, j, koffset-2, 1) = xadjb(i, j, koffset-2, 1) - xadjb(i&
&          , j, koffset, 1)
        xadjb(i, j, koffset, 1) = 0.0
      END DO
    END DO
  END IF
  CALL POPINTEGER4(branch)
  IF (.NOT.branch .LT. 2) THEN
    DO j=2,-3,-1
      DO i=2,-3,-1
        xadjb(i, j, koffset+1, 3) = xadjb(i, j, koffset+1, 3) + two*&
&          xadjb(i, j, koffset, 3)
        xadjb(i, j, koffset+2, 3) = xadjb(i, j, koffset+2, 3) - xadjb(i&
&          , j, koffset, 3)
        xadjb(i, j, koffset, 3) = 0.0
        xadjb(i, j, koffset+1, 2) = xadjb(i, j, koffset+1, 2) + two*&
&          xadjb(i, j, koffset, 2)
        xadjb(i, j, koffset+2, 2) = xadjb(i, j, koffset+2, 2) - xadjb(i&
&          , j, koffset, 2)
        xadjb(i, j, koffset, 2) = 0.0
        xadjb(i, j, koffset+1, 1) = xadjb(i, j, koffset+1, 1) + two*&
&          xadjb(i, j, koffset, 1)
        xadjb(i, j, koffset+2, 1) = xadjb(i, j, koffset+2, 1) - xadjb(i&
&          , j, koffset, 1)
        xadjb(i, j, koffset, 1) = 0.0
      END DO
    END DO
  END IF
  CALL POPINTEGER4(branch)
  IF (.NOT.branch .LT. 2) THEN
    DO k=2,-3,-1
      DO i=2,-3,-1
        xadjb(i, joffset-1, k, 3) = xadjb(i, joffset-1, k, 3) + two*&
&          xadjb(i, joffset, k, 3)
        xadjb(i, joffset-2, k, 3) = xadjb(i, joffset-2, k, 3) - xadjb(i&
&          , joffset, k, 3)
        xadjb(i, joffset, k, 3) = 0.0
        xadjb(i, joffset-1, k, 2) = xadjb(i, joffset-1, k, 2) + two*&
&          xadjb(i, joffset, k, 2)
        xadjb(i, joffset-2, k, 2) = xadjb(i, joffset-2, k, 2) - xadjb(i&
&          , joffset, k, 2)
        xadjb(i, joffset, k, 2) = 0.0
        xadjb(i, joffset-1, k, 1) = xadjb(i, joffset-1, k, 1) + two*&
&          xadjb(i, joffset, k, 1)
        xadjb(i, joffset-2, k, 1) = xadjb(i, joffset-2, k, 1) - xadjb(i&
&          , joffset, k, 1)
        xadjb(i, joffset, k, 1) = 0.0
      END DO
    END DO
  END IF
  CALL POPINTEGER4(branch)
  IF (.NOT.branch .LT. 2) THEN
    DO i=2,-3,-1
      DO k=2,-3,-1
        xadjb(i, joffset+1, k, 3) = xadjb(i, joffset+1, k, 3) + two*&
&          xadjb(i, joffset, k, 3)
        xadjb(i, joffset+2, k, 3) = xadjb(i, joffset+2, k, 3) - xadjb(i&
&          , joffset, k, 3)
        xadjb(i, joffset, k, 3) = 0.0
        xadjb(i, joffset+1, k, 2) = xadjb(i, joffset+1, k, 2) + two*&
&          xadjb(i, joffset, k, 2)
        xadjb(i, joffset+2, k, 2) = xadjb(i, joffset+2, k, 2) - xadjb(i&
&          , joffset, k, 2)
        xadjb(i, joffset, k, 2) = 0.0
        xadjb(i, joffset+1, k, 1) = xadjb(i, joffset+1, k, 1) + two*&
&          xadjb(i, joffset, k, 1)
        xadjb(i, joffset+2, k, 1) = xadjb(i, joffset+2, k, 1) - xadjb(i&
&          , joffset, k, 1)
        xadjb(i, joffset, k, 1) = 0.0
      END DO
    END DO
  END IF
  CALL POPINTEGER4(branch)
  IF (.NOT.branch .LT. 2) THEN
    DO j=2,-3,-1
      DO k=2,-3,-1
        xadjb(ioffset-1, j, k, 3) = xadjb(ioffset-1, j, k, 3) + two*&
&          xadjb(ioffset, j, k, 3)
        xadjb(ioffset-2, j, k, 3) = xadjb(ioffset-2, j, k, 3) - xadjb(&
&          ioffset, j, k, 3)
        xadjb(ioffset, j, k, 3) = 0.0
        xadjb(ioffset-1, j, k, 2) = xadjb(ioffset-1, j, k, 2) + two*&
&          xadjb(ioffset, j, k, 2)
        xadjb(ioffset-2, j, k, 2) = xadjb(ioffset-2, j, k, 2) - xadjb(&
&          ioffset, j, k, 2)
        xadjb(ioffset, j, k, 2) = 0.0
        xadjb(ioffset-1, j, k, 1) = xadjb(ioffset-1, j, k, 1) + two*&
&          xadjb(ioffset, j, k, 1)
        xadjb(ioffset-2, j, k, 1) = xadjb(ioffset-2, j, k, 1) - xadjb(&
&          ioffset, j, k, 1)
        xadjb(ioffset, j, k, 1) = 0.0
      END DO
    END DO
  END IF
  CALL POPINTEGER4(branch)
  IF (.NOT.branch .LT. 2) THEN
    DO j=2,-3,-1
      DO k=2,-3,-1
        xadjb(ioffset+1, j, k, 3) = xadjb(ioffset+1, j, k, 3) + two*&
&          xadjb(ioffset, j, k, 3)
        xadjb(ioffset+2, j, k, 3) = xadjb(ioffset+2, j, k, 3) - xadjb(&
&          ioffset, j, k, 3)
        xadjb(ioffset, j, k, 3) = 0.0
        xadjb(ioffset+1, j, k, 2) = xadjb(ioffset+1, j, k, 2) + two*&
&          xadjb(ioffset, j, k, 2)
        xadjb(ioffset+2, j, k, 2) = xadjb(ioffset+2, j, k, 2) - xadjb(&
&          ioffset, j, k, 2)
        xadjb(ioffset, j, k, 2) = 0.0
        xadjb(ioffset+1, j, k, 1) = xadjb(ioffset+1, j, k, 1) + two*&
&          xadjb(ioffset, j, k, 1)
        xadjb(ioffset+2, j, k, 1) = xadjb(ioffset+2, j, k, 1) - xadjb(&
&          ioffset, j, k, 1)
        xadjb(ioffset, j, k, 1) = 0.0
      END DO
    END DO
  END IF
END SUBROUTINE XHALOADJ_B
