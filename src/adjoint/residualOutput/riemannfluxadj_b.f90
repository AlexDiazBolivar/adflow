!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 2.2.4 (r2308) - 03/04/2008 10:03
!  
!  Differentiation of riemannfluxadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: rfil flux left right
!                sx sy sz
!   of linear combination of output variables: flux left right
!
!      ******************************************************************
!      *                                                                *
!      * File:          riemannFluxAdj.f90                              *
!      * Author:        Edwin van der Weide, C.A.(Sandy) Mader          *
!      * Starting date: 04-25-2008                                      *
!      * Last modified: 04-25-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&  , gammaface, correctfork, sx, sxb, sy, syb, sz, szb, sface, finegrid)
  USE inputdiscretization
  USE constants
  USE iteration
  IMPLICIT NONE
!print *,'riemanflux complete'
!
!        ****************************************************************
!        *                                                              *
!        * riemannFlux computes the flux for the given face and left    *
!        * and right states.                                            *
!        *                                                              *
!        ****************************************************************
!
!
!        Subroutine arguments.
!
  INTEGER(KIND=PORTYPE) :: por
  REAL(KIND=REALTYPE) :: sx, sy, sz, gammaface
  REAL(KIND=REALTYPE) :: sxb, syb, szb
  REAL(KIND=REALTYPE) :: sface
  REAL(KIND=REALTYPE), DIMENSION(*) :: left, right
  REAL(KIND=REALTYPE), DIMENSION(*) :: leftb, rightb
  REAL(KIND=REALTYPE), DIMENSION(*) :: flux
  REAL(KIND=REALTYPE), DIMENSION(*) :: fluxb
  LOGICAL, INTENT(IN) :: finegrid, correctfork
!
!        Local variables.
!
  REAL(KIND=REALTYPE) :: porflux, rface
  REAL(KIND=REALTYPE) :: rfaceb
  REAL(KIND=REALTYPE) :: etl, etr, z1l, z1r, tmp
  REAL(KIND=REALTYPE) :: etlb, etrb, z1lb, z1rb, tmpb
  REAL(KIND=REALTYPE) :: dr, dru, drv, drw, dre, drk
  REAL(KIND=REALTYPE) :: drb, drub, drvb, drwb, dreb, drkb
  REAL(KIND=REALTYPE) :: ravg, uavg, vavg, wavg, havg, kavg
  REAL(KIND=REALTYPE) :: uavgb, vavgb, wavgb, havgb, kavgb
  REAL(KIND=REALTYPE) :: alphaavg, a2avg, aavg, unavg
  REAL(KIND=REALTYPE) :: alphaavgb, a2avgb, aavgb, unavgb
  REAL(KIND=REALTYPE) :: ovaavg, ova2avg, area, eta
  REAL(KIND=REALTYPE) :: ovaavgb, ova2avgb, areab, etab
  REAL(KIND=REALTYPE) :: gm1, gm53
  REAL(KIND=REALTYPE) :: lam1, lam2, lam3
  REAL(KIND=REALTYPE) :: lam1b, lam2b, lam3b
  REAL(KIND=REALTYPE) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
  REAL(KIND=REALTYPE) :: abv1b, abv2b, abv3b, abv4b, abv5b, abv6b, abv7b
  INTEGER(KIND=INTTYPE) :: limused, riemannused
  REAL(KIND=REALTYPE), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
  REAL(KIND=REALTYPE), DIMENSION(2) :: rhotmpb, utmpb, vtmpb, wtmpb
  REAL(KIND=REALTYPE), DIMENSION(2) :: ptmp, ktmp, etmp
  REAL(KIND=REALTYPE), DIMENSION(2) :: ptmpb, ktmpb, etmpb
  EXTERNAL TERMINATE
  REAL(KIND=REALTYPE) :: temp
  REAL(KIND=REALTYPE) :: temp0
  REAL(KIND=REALTYPE) :: temp1
  REAL(KIND=REALTYPE) :: temp2
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: abs1b
  REAL(KIND=REALTYPE) :: tempb4
  REAL(KIND=REALTYPE) :: tempb3
  REAL(KIND=REALTYPE) :: tempb2
  REAL(KIND=REALTYPE) :: tempb1
  REAL(KIND=REALTYPE) :: tempb0
  REAL(KIND=REALTYPE) :: temp0b
  INTRINSIC MAX
  REAL(KIND=REALTYPE) :: temp3b
  INTRINSIC ABS
  REAL(KIND=REALTYPE) :: x2
  REAL(KIND=REALTYPE) :: x1
  REAL(KIND=REALTYPE) :: x2b
  REAL(realType) :: max1b
  REAL(KIND=REALTYPE) :: tempb
  REAL(KIND=REALTYPE) :: temp2b
  REAL(KIND=REALTYPE) :: x1b
  REAL(KIND=REALTYPE) :: temp3b7
  REAL(KIND=REALTYPE) :: temp3b6
  REAL(KIND=REALTYPE) :: temp3b5
  REAL(KIND=REALTYPE) :: temp3b4
  REAL(KIND=REALTYPE) :: temp3b3
  REAL(KIND=REALTYPE) :: temp3b2
  REAL(KIND=REALTYPE) :: temp3b1
  REAL(KIND=REALTYPE) :: temp3b0
  REAL(KIND=REALTYPE) :: abs2
  REAL(KIND=REALTYPE) :: abs1
  REAL(KIND=REALTYPE) :: abs2b
  REAL(KIND=REALTYPE) :: temp1b
  INTRINSIC SQRT
  REAL(realType) :: max1
  REAL(KIND=REALTYPE) :: temp1b2
  REAL(KIND=REALTYPE) :: temp1b1
  REAL(KIND=REALTYPE) :: temp1b0
!
!        ****************************************************************
!        *                                                              *
!        * Begin execution.                                             *
!        *                                                              *
!        ****************************************************************
!
! Set the porosity for the flux. The default value, 0.5*rFil, is
! a scaling factor where an rFil != 1 is taken into account.
!print *,'adjflux2*****************************',half,rfil
!stop
  porflux = half*rfil
  IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
! Determine the riemann solver which must be used.
!print *,'selecting riemann',riemann,riemannused,riemannCoarse,finegrid
  riemannused = riemanncoarse
  IF (finegrid) riemannused = riemann
! Abbreviate some expressions in which gamma occurs.
!print *,'some constantts',gammaface
  gm1 = gammaface - one
  gm53 = gammaface - five*third
! Determine which riemann solver must be solved.
  SELECT CASE  (riemannused) 
  CASE (roe) 
!print *,'using roe solver'
! Determine the preconditioner used.
    SELECT CASE  (precond) 
    CASE (noprecond) 
! No preconditioner used. Use the Roe scheme of the
! standard equations.
! Compute the square root of the left and right densities
! and the inverse of the sum.
      z1l = SQRT(left(irho))
      z1r = SQRT(right(irho))
      tmp = one/(z1l+z1r)
! Compute some variables depending whether or not a
! k-equation is present.
      IF (correctfork) THEN
!print *,'correcting for k'
! Store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
        ktmp(1) = left(itu1)
        ktmp(2) = right(itu1)
! Store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
        drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! Compute the average turbulent energy per unit mass
! using Roe averages.
        kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
!print *,'not correcting for k'
! Set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
        drk = 0.0
        kavg = 0.0
      END IF
! Compute the total energy of the left and right state.
!print *,'calculating temp vaars'
      rhotmp(1) = left(irho)
      rhotmp(2) = right(irho)
      utmp(1) = left(ivx)
      utmp(2) = right(ivx)
      vtmp(1) = left(ivy)
      vtmp(2) = right(ivy)
      wtmp(1) = left(ivz)
      wtmp(2) = right(ivz)
      ptmp(1) = left(irhoe)
      ptmp(2) = right(irhoe)
      CALL PUSHREAL8ARRAY(etmp, 2)
!                 call etotArrayAdj(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, &
!                                Etmp, correctForK, 2_intType)
      CALL ETOTARRAYADJ(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
&                  correctfork, 2)
      etl = etmp(1)
      etr = etmp(2)
! Compute the difference of the conservative mean
! flow variables.
      dr = right(irho) - left(irho)
      dru = right(irho)*right(ivx) - left(irho)*left(ivx)
      drv = right(irho)*right(ivy) - left(irho)*left(ivy)
      drw = right(irho)*right(ivz) - left(irho)*left(ivz)
      dre = etr - etl
! Compute the Roe average variables, which can be
! computed directly from the average Roe vector.
      uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
      vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
      wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
      havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! Compute the unit vector and store the area of the
! normal. Also compute the unit normal velocity of the face.
      area = SQRT(sx**2 + sy**2 + sz**2)
      IF (1.e-25_realType .LT. area) THEN
        max1 = area
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
        max1 = 1.e-25_realType
      END IF
      CALL PUSHREAL8(tmp)
      tmp = one/max1
      CALL PUSHREAL8(sx)
      sx = sx*tmp
      CALL PUSHREAL8(sy)
      sy = sy*tmp
      CALL PUSHREAL8(sz)
      sz = sz*tmp
      rface = sface*tmp
! Compute some dependent variables at the Roe
! average state.
      alphaavg = half*(uavg**2+vavg**2+wavg**2)
      IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
        a2avg = gm1*(havg-alphaavg) - gm53*kavg
        CALL PUSHINTEGER4(1)
      ELSE
        a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
        CALL PUSHINTEGER4(0)
      END IF
      aavg = SQRT(a2avg)
      unavg = uavg*sx + vavg*sy + wavg*sz
      ovaavg = one/aavg
      ova2avg = one/a2avg
! Set for a boundary the normal velocity to rFace, the
! normal velocity of the boundary.
      IF (por .EQ. boundflux) THEN
        unavg = rface
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (left&
&        (ivz)-right(ivz))*sz
      IF (x1 .GE. 0.) THEN
        abs1 = x1
        CALL PUSHINTEGER4(1)
      ELSE
        abs1 = -x1
        CALL PUSHINTEGER4(0)
      END IF
      x2 = SQRT(gammaface*left(irhoe)/left(irho)) - SQRT(gammaface*right&
&        (irhoe)/right(irho))
      IF (x2 .GE. 0.) THEN
        abs2 = x2
        CALL PUSHINTEGER4(1)
      ELSE
        abs2 = -x2
        CALL PUSHINTEGER4(0)
      END IF
! Compute the coefficient eta for the entropy correction.
! At the moment a 1D entropy correction is used, which
! removes expansion shocks. Although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! In other to do that a multi-dimensional entropy fix is
! needed, see Sanders et. al, JCP, vol. 145, 1998,
! pp. 511 - 537. Although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
      eta = half*(abs1+abs2)
      IF (unavg - rface + aavg .GE. 0.) THEN
        lam1 = unavg - rface + aavg
        CALL PUSHINTEGER4(1)
      ELSE
        lam1 = -(unavg-rface+aavg)
        CALL PUSHINTEGER4(0)
      END IF
      IF (unavg - rface - aavg .GE. 0.) THEN
        lam2 = unavg - rface - aavg
        CALL PUSHINTEGER4(1)
      ELSE
        lam2 = -(unavg-rface-aavg)
        CALL PUSHINTEGER4(0)
      END IF
      IF (unavg - rface .GE. 0.) THEN
        lam3 = unavg - rface
        CALL PUSHINTEGER4(1)
      ELSE
        lam3 = -(unavg-rface)
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(tmp)
! Apply the entropy correction to the eigenvalues.
      tmp = two*eta
      IF (lam1 .LT. tmp) THEN
        CALL PUSHREAL8(lam1)
        lam1 = eta + fourth*lam1*lam1/eta
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      IF (lam2 .LT. tmp) THEN
        CALL PUSHREAL8(lam2)
        lam2 = eta + fourth*lam2*lam2/eta
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      IF (lam3 .LT. tmp) THEN
        CALL PUSHREAL8(lam3)
        lam3 = eta + fourth*lam3*lam3/eta
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(lam1)
! Multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
      lam1 = lam1*area
      CALL PUSHREAL8(lam2)
      lam2 = lam2*area
      CALL PUSHREAL8(lam3)
      lam3 = lam3*area
! Some abbreviations, which occur quite often in the
! dissipation terms.
      abv1 = half*(lam1+lam2)
      abv2 = half*(lam1-lam2)
      abv3 = abv1 - lam3
      abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
      abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
      abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
      abv7 = abv2*abv4*ovaavg + abv3*abv5
! Compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porFlux. Note that porFlux is either
! 0.0 or 0.5*rFil.
      temp3b2 = -(porflux*fluxb(irhoe))
      fluxb(irhoe) = 0.0
      temp3b3 = -(porflux*fluxb(imz))
      fluxb(imz) = 0.0
      temp3b4 = -(porflux*fluxb(imy))
      fluxb(imy) = 0.0
      temp3b5 = -(porflux*fluxb(imx))
      fluxb(imx) = 0.0
      temp3b6 = -(porflux*fluxb(irho))
      abv6b = wavg*temp3b3 + uavg*temp3b5 + temp3b6 + vavg*temp3b4 + &
&        havg*temp3b2
      abv7b = sz*temp3b3 + sx*temp3b5 + sy*temp3b4 + unavg*temp3b2
      abv3b = ova2avg*abv4*abv6b + abv5*abv7b
      lam3b = drw*temp3b3 + dru*temp3b5 - abv3b + dr*temp3b6 + drv*&
&        temp3b4 + dre*temp3b2
      abv4b = ova2avg*abv3*abv6b + ovaavg*abv2*abv7b
      temp3b7 = gm1*abv4b
      dreb = temp3b7 + lam3*temp3b2
      havgb = abv6*temp3b2
      abv5b = ovaavg*abv2*abv6b + abv3*abv7b
      unavgb = abv7*temp3b2 - dr*abv5b
      drwb = sz*abv5b - wavg*temp3b7 + lam3*temp3b3
      wavgb = abv6*temp3b3 - drw*temp3b7
      szb = drw*abv5b + abv7*temp3b3
      drvb = sy*abv5b - vavg*temp3b7 + lam3*temp3b4
      vavgb = abv6*temp3b4 - drv*temp3b7
      syb = drv*abv5b + abv7*temp3b4
      drub = sx*abv5b - uavg*temp3b7 + lam3*temp3b5
      uavgb = abv6*temp3b5 - dru*temp3b7
      sxb = dru*abv5b + abv7*temp3b5
      drb = alphaavg*temp3b7 - unavg*abv5b + lam3*temp3b6
      fluxb(irho) = 0.0
      abv2b = ovaavg*abv5*abv6b + ovaavg*abv4*abv7b
      ovaavgb = abv2*abv5*abv6b + abv2*abv4*abv7b
      ova2avgb = abv3*abv4*abv6b
      alphaavgb = dr*temp3b7
      drkb = -(gm53*abv4b)
      abv1b = abv3b
      lam1b = half*abv1b + half*abv2b
      lam2b = half*abv1b - half*abv2b
      CALL POPREAL8(lam3)
      CALL POPREAL8(lam2)
      CALL POPREAL8(lam1)
      areab = lam2*lam2b + lam1*lam1b + lam3*lam3b
      lam3b = area*lam3b
      lam2b = area*lam2b
      lam1b = area*lam1b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        etab = 0.0
      ELSE
        CALL POPREAL8(lam3)
        temp3b1 = fourth*lam3b/eta
        etab = lam3b - lam3**2*temp3b1/eta
        lam3b = 2*lam3*temp3b1
      END IF
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(lam2)
        temp3b0 = fourth*lam2b/eta
        etab = etab + lam2b - lam2**2*temp3b0/eta
        lam2b = 2*lam2*temp3b0
      END IF
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(lam1)
        temp3b = fourth*lam1b/eta
        etab = etab + lam1b - lam1**2*temp3b/eta
        lam1b = 2*lam1*temp3b
      END IF
      CALL POPREAL8(tmp)
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        rfaceb = lam3b
        unavgb = unavgb - lam3b
      ELSE
        unavgb = unavgb + lam3b
        rfaceb = -lam3b
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        rfaceb = rfaceb + lam2b
        unavgb = unavgb - lam2b
        aavgb = lam2b
      ELSE
        unavgb = unavgb + lam2b
        rfaceb = rfaceb - lam2b
        aavgb = -lam2b
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        rfaceb = rfaceb + lam1b
        unavgb = unavgb - lam1b
        aavgb = aavgb - lam1b
      ELSE
        unavgb = unavgb + lam1b
        rfaceb = rfaceb - lam1b
        aavgb = aavgb + lam1b
      END IF
      abs1b = half*etab
      abs2b = half*etab
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x2b = -abs2b
      ELSE
        x2b = abs2b
      END IF
      temp2 = left(irhoe)/left(irho)
      IF (gammaface*temp2 .EQ. 0.0) THEN
        temp2b = 0.0
      ELSE
        temp2b = gammaface*x2b/(2.0*SQRT(gammaface*temp2)*left(irho))
      END IF
      temp1 = right(irhoe)/right(irho)
      IF (gammaface*temp1 .EQ. 0.0) THEN
        temp1b2 = 0.0
      ELSE
        temp1b2 = -(gammaface*x2b/(2.0*SQRT(gammaface*temp1)*right(irho)&
&          ))
      END IF
      leftb(irhoe) = leftb(irhoe) + temp2b
      leftb(irho) = leftb(irho) - temp2*temp2b
      rightb(irhoe) = rightb(irhoe) + temp1b2
      rightb(irho) = rightb(irho) - temp1*temp1b2
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x1b = -abs1b
      ELSE
        x1b = abs1b
      END IF
      leftb(ivx) = leftb(ivx) + sx*x1b
      rightb(ivx) = rightb(ivx) - sx*x1b
      sxb = sxb + (left(ivx)-right(ivx))*x1b
      leftb(ivy) = leftb(ivy) + sy*x1b
      rightb(ivy) = rightb(ivy) - sy*x1b
      syb = syb + (left(ivy)-right(ivy))*x1b
      leftb(ivz) = leftb(ivz) + sz*x1b
      rightb(ivz) = rightb(ivz) - sz*x1b
      szb = szb + (left(ivz)-right(ivz))*x1b
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        rfaceb = rfaceb + unavgb
        unavgb = 0.0
      END IF
      aavgb = aavgb - one*ovaavgb/aavg**2
      IF (a2avg .EQ. 0.0) THEN
        a2avgb = -(one*ova2avgb/a2avg**2)
      ELSE
        a2avgb = aavgb/(2.0*SQRT(a2avg)) - one*ova2avgb/a2avg**2
      END IF
      uavgb = uavgb + sx*unavgb
      sxb = sxb + uavg*unavgb
      vavgb = vavgb + sy*unavgb
      syb = syb + vavg*unavgb
      wavgb = wavgb + sz*unavgb
      szb = szb + wavg*unavgb
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        kavgb = gm53*a2avgb
        havgb = havgb - gm1*a2avgb
        alphaavgb = alphaavgb + gm1*a2avgb
      ELSE
        havgb = havgb + gm1*a2avgb
        alphaavgb = alphaavgb - gm1*a2avgb
        kavgb = -(gm53*a2avgb)
      END IF
      temp1b1 = half*alphaavgb
      uavgb = uavgb + 2*uavg*temp1b1
      vavgb = vavgb + 2*vavg*temp1b1
      wavgb = wavgb + 2*wavg*temp1b1
      CALL POPREAL8(sz)
      CALL POPREAL8(sy)
      CALL POPREAL8(sx)
      tmpb = sz*szb + sx*sxb + sy*syb + sface*rfaceb
      szb = tmp*szb
      syb = tmp*syb
      sxb = tmp*sxb
      CALL POPREAL8(tmp)
      max1b = -(one*tmpb/max1**2)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) areab = areab + max1b
      IF (sx**2 + sy**2 + sz**2 .EQ. 0.0) THEN
        temp1b = 0.0
      ELSE
        temp1b = areab/(2.0*SQRT(sx**2+sy**2+sz**2))
      END IF
      sxb = sxb + 2*sx*temp1b
      syb = syb + 2*sy*temp1b
      szb = szb + 2*sz*temp1b
      temp = (etr+right(irhoe))/z1r
      temp0 = (etl+left(irhoe))/z1l
      temp1b0 = tmp*havgb
      temp0b = temp1b0/z1l
      tempb1 = temp1b0/z1r
      tmpb = (z1l*left(ivz)+z1r*right(ivz))*wavgb + (z1l*left(ivx)+z1r*&
&        right(ivx))*uavgb + (z1l*left(ivy)+z1r*right(ivy))*vavgb + (&
&        temp0+temp)*havgb
      etlb = temp0b - dreb
      leftb(irhoe) = leftb(irhoe) + temp0b
      tempb2 = tmp*wavgb
      tempb3 = tmp*vavgb
      tempb4 = tmp*uavgb
      z1lb = left(ivz)*tempb2 + left(ivx)*tempb4 + left(ivy)*tempb3 - &
&        temp0*temp0b
      etrb = dreb + tempb1
      rightb(irhoe) = rightb(irhoe) + tempb1
      z1rb = right(ivz)*tempb2 + right(ivx)*tempb4 + right(ivy)*tempb3 -&
&       temp*tempb1
      leftb(ivz) = leftb(ivz) + z1l*tempb2
      rightb(ivz) = rightb(ivz) + z1r*tempb2
      leftb(ivy) = leftb(ivy) + z1l*tempb3
      rightb(ivy) = rightb(ivy) + z1r*tempb3
      leftb(ivx) = leftb(ivx) + z1l*tempb4
      rightb(ivx) = rightb(ivx) + z1r*tempb4
      rightb(irho) = rightb(irho) + right(ivz)*drwb
      rightb(ivz) = rightb(ivz) + right(irho)*drwb
      leftb(irho) = leftb(irho) - left(ivz)*drwb
      leftb(ivz) = leftb(ivz) - left(irho)*drwb
      rightb(irho) = rightb(irho) + right(ivy)*drvb
      rightb(ivy) = rightb(ivy) + right(irho)*drvb
      leftb(irho) = leftb(irho) - left(ivy)*drvb
      leftb(ivy) = leftb(ivy) - left(irho)*drvb
      rightb(irho) = rightb(irho) + right(ivx)*drub
      rightb(ivx) = rightb(ivx) + right(irho)*drub
      leftb(irho) = leftb(irho) - left(ivx)*drub
      leftb(ivx) = leftb(ivx) - left(irho)*drub
      rightb(irho) = rightb(irho) + drb
      leftb(irho) = leftb(irho) - drb
      etmpb(:) = 0.0
      etmpb(2) = etrb
      etmpb(1) = etmpb(1) + etlb
      CALL POPREAL8ARRAY(etmp, 2)
      ptmpb(:) = 0.0
      CALL ETOTARRAYADJ_B(rhotmp, rhotmpb, utmp, utmpb, vtmp, vtmpb, &
&                    wtmp, wtmpb, ptmp, ptmpb, ktmp, ktmpb, etmp, etmpb&
&                    , correctfork, 2)
      rightb(irhoe) = rightb(irhoe) + ptmpb(2)
      ptmpb(2) = 0.0
      leftb(irhoe) = leftb(irhoe) + ptmpb(1)
      rightb(ivz) = rightb(ivz) + wtmpb(2)
      wtmpb(2) = 0.0
      leftb(ivz) = leftb(ivz) + wtmpb(1)
      rightb(ivy) = rightb(ivy) + vtmpb(2)
      vtmpb(2) = 0.0
      leftb(ivy) = leftb(ivy) + vtmpb(1)
      rightb(ivx) = rightb(ivx) + utmpb(2)
      utmpb(2) = 0.0
      leftb(ivx) = leftb(ivx) + utmpb(1)
      rightb(irho) = rightb(irho) + rhotmpb(2)
      rhotmpb(2) = 0.0
      leftb(irho) = leftb(irho) + rhotmpb(1)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        tempb0 = tmp*kavgb
        tmpb = tmpb + (z1l*left(itu1)+z1r*right(itu1))*kavgb
        z1lb = z1lb + left(itu1)*tempb0
        leftb(itu1) = leftb(itu1) + z1l*tempb0
        z1rb = z1rb + right(itu1)*tempb0
        rightb(itu1) = rightb(itu1) + z1r*tempb0
        rightb(irho) = rightb(irho) + right(itu1)*drkb
        rightb(itu1) = rightb(itu1) + ktmpb(2) + right(irho)*drkb
        leftb(irho) = leftb(irho) - left(itu1)*drkb
        ktmpb(2) = 0.0
        leftb(itu1) = leftb(itu1) + ktmpb(1) - left(irho)*drkb
      END IF
      tempb = -(one*tmpb/(z1l+z1r)**2)
      z1lb = z1lb + tempb
      z1rb = z1rb + tempb
      IF (.NOT.right(irho) .EQ. 0.0) rightb(irho) = rightb(irho) + z1rb/&
&          (2.0*SQRT(right(irho)))
      IF (.NOT.left(irho) .EQ. 0.0) leftb(irho) = leftb(irho) + z1lb/(&
&          2.0*SQRT(left(irho)))
    CASE (turkel) 
      sxb = 0.0
      syb = 0.0
      szb = 0.0
    CASE (choimerkle) 
      sxb = 0.0
      syb = 0.0
      szb = 0.0
    CASE DEFAULT
      sxb = 0.0
      syb = 0.0
      szb = 0.0
    END SELECT
  CASE (vanleer) 
    sxb = 0.0
    syb = 0.0
    szb = 0.0
  CASE (ausmdv) 
    sxb = 0.0
    syb = 0.0
    szb = 0.0
  CASE DEFAULT
    sxb = 0.0
    syb = 0.0
    szb = 0.0
  END SELECT
!  rfilb = 0.0
END SUBROUTINE RIEMANNFLUXADJ_B
