   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of riemannfluxadj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: flux left right
   !                sface sx sy sz
   !   of linear combination of output variables: flux left right
   !                sface
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          riemannFluxAdj.f90                              *
   !      * Author:        Edwin van der Weide, C.A.(Sandy) Mader          *
   !      * Starting date: 04-25-2008                                      *
   !      * Last modified: 04-25-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
   &  , gammaface, correctfork, sx, sxb, sy, syb, sz, szb, sface, sfaceb, &
   &  finegrid)
   USE constants
   USE inputdiscretization
   USE iteration
   IMPLICIT NONE
   !print *,'riemanflux complete'
   LOGICAL, INTENT(IN) :: correctfork
   LOGICAL, INTENT(IN) :: finegrid
   REAL(KIND=REALTYPE) :: flux(*), fluxb(*)
   REAL(KIND=REALTYPE), DIMENSION(*), INTENT(IN) :: left
   REAL(KIND=REALTYPE) :: leftb(*), rightb(*)
   INTEGER(KIND=PORTYPE) :: por
   REAL(KIND=REALTYPE), DIMENSION(*), INTENT(IN) :: right
   REAL(KIND=REALTYPE) :: sface, sfaceb
   REAL(KIND=REALTYPE) :: gammaface, sx, sxb, sy, syb, sz, szb
   REAL(KIND=REALTYPE) :: abv1, abv1b, abv2, abv2b, abv3, abv3b, abv4, &
   &  abv4b, abv5, abv5b, abv6, abv6b, abv7, abv7b, temp3b7
   REAL(KIND=REALTYPE) :: area, areab, eta, etab, ova2avg, ova2avgb, &
   &  ovaavg, ovaavgb, temp1b
   INTEGER :: branch
   REAL(KIND=REALTYPE) :: dr, drb, dre, dreb, drk, drkb, dru, drub, drv, &
   &  drvb, drw, drwb
   REAL(KIND=REALTYPE) :: etmp(2), etmpb(2), ktmp(2), ktmpb(2), ptmp(2), &
   &  ptmpb(2)
   REAL(KIND=REALTYPE) :: etl, etlb, etr, etrb, temp, temp0, temp0b, &
   &  tempb, tempb1, tmp, tmpb, z1l, z1lb, z1r, z1rb
   REAL(KIND=REALTYPE) :: gm1, gm53
   REAL(KIND=REALTYPE) :: lam1, lam1b, lam2, lam2b, lam3, lam3b, temp3b, &
   &  temp3b0, temp3b1
   INTEGER(KIND=INTTYPE) :: limused, riemannused
   REAL(KIND=REALTYPE) :: max1, max1b
   REAL(KIND=REALTYPE) :: porflux, rface, rfaceb
   REAL(KIND=REALTYPE) :: abs1, abs1b, temp1, temp1b2, temp2, temp2b, x1&
   &  , x1b
   REAL(KIND=REALTYPE) :: temp3b2, temp3b3, temp3b4, temp3b5, temp3b6
   REAL(KIND=REALTYPE) :: a2avg, a2avgb, aavg, aavgb, alphaavg, alphaavgb&
   &  , temp1b1, unavg, unavgb
   REAL(KIND=REALTYPE) :: havg, havgb, kavg, kavgb, ravg, temp1b0, tempb0&
   &  , tempb2, tempb3, tempb4, uavg, uavgb, vavg, vavgb, wavg, wavgb
   REAL(KIND=REALTYPE) :: rhotmp(2), rhotmpb(2), utmp(2), utmpb(2), vtmp(&
   &  2), vtmpb(2), wtmp(2), wtmpb(2)
   REAL(KIND=REALTYPE) :: abs2, abs2b, x2, x2b
   INTRINSIC MAX, ABS, SQRT
   !
   !        ****************************************************************
   !        *                                                              *
   !        * riemannFlux computes the flux for the given face and left    *
   !        * and right states.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   !
   !        Subroutine arguments.
   !
   !
   !        Local variables.
   !
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   !print *,'adjflux2*****************************',half,rfil
   !stop
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) THEN
   porflux = zero
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Determine the riemann solver which must be used.
   !print *,'selecting riemann',riemann,riemannused,riemannCoarse,finegrid
   riemannused = riemanncoarse
   IF (finegrid) THEN
   riemannused = riemann
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Abbreviate some expressions in which gamma occurs.
   !print *,'some constantts',gammaface
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   !print *,'using roe solver'
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   z1l = SQRT(left(irho))
   z1r = SQRT(right(irho))
   tmp = one/(z1l+z1r)
   !print *,'tmp',one,z1l , z1r
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   !print *,'correcting for k'
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmp(1) = left(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   CALL PUSHINTEGER4(0)
   ELSE
   !print *,'not correcting for k'
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   CALL PUSHINTEGER4(1)
   END IF
   ! Compute the total energy of the left and right state.
   !print *,'calculating temp vaars'
   rhotmp(1) = left(irho)
   rhotmp(2) = right(irho)
   utmp(1) = left(ivx)
   utmp(2) = right(ivx)
   vtmp(1) = left(ivy)
   vtmp(2) = right(ivy)
   wtmp(1) = left(ivz)
   wtmp(2) = right(ivz)
   ptmp(1) = left(irhoe)
   ptmp(2) = right(irhoe)
   CALL PUSHREAL8ARRAY(etmp, 2)
   !                 call etotArrayAdj(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, &
   !                                Etmp, correctForK, 2_intType)
   CALL ETOTARRAYADJ(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
   &                  correctfork, 2)
   etl = etmp(1)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   dr = right(irho) - left(irho)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   !rAvg = fourth*(z1r + z1l)**2 deadend code!
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   !print *,'uavg',tmp,z1l,left(ivx),z1r,right(ivx)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   max1 = area
   CALL PUSHINTEGER4(1)
   ELSE
   max1 = 1.e-25_realType
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(tmp)
   tmp = one/max1
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   CALL PUSHINTEGER4(1)
   ELSE
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   CALL PUSHINTEGER4(0)
   END IF
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   !print *,'unavg',uAvg,sx,vAvg,sy,wAvg,sz
   ovaavg = one/aavg
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) THEN
   unavg = rface
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (left&
   &        (ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1 = x1
   CALL PUSHINTEGER4(1)
   ELSE
   abs1 = -x1
   CALL PUSHINTEGER4(0)
   END IF
   x2 = SQRT(gammaface*left(irhoe)/left(irho)) - SQRT(gammaface*right&
   &        (irhoe)/right(irho))
   IF (x2 .GE. 0.) THEN
   abs2 = x2
   CALL PUSHINTEGER4(1)
   ELSE
   abs2 = -x2
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1 = unavg - rface + aavg
   CALL PUSHINTEGER4(1)
   ELSE
   lam1 = -(unavg-rface+aavg)
   CALL PUSHINTEGER4(0)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2 = unavg - rface - aavg
   CALL PUSHINTEGER4(1)
   ELSE
   lam2 = -(unavg-rface-aavg)
   CALL PUSHINTEGER4(0)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3 = unavg - rface
   CALL PUSHINTEGER4(1)
   ELSE
   lam3 = -(unavg-rface)
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(tmp)
   !print *,'lam3',unAvg, rFace
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) THEN
   CALL PUSHREAL8(lam1)
   lam1 = eta + fourth*lam1*lam1/eta
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (lam2 .LT. tmp) THEN
   CALL PUSHREAL8(lam2)
   lam2 = eta + fourth*lam2*lam2/eta
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (lam3 .LT. tmp) THEN
   CALL PUSHREAL8(lam3)
   lam3 = eta + fourth*lam3*lam3/eta
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(lam1)
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   abv2 = half*(lam1-lam2)
   abv3 = abv1 - lam3
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   !print *,'abv6',abv3,abv4,ova2Avg,abv2,abv5,ovaAvg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   !print *,'inriemannend',-porFlux,lam3,dr, abv6
   temp3b2 = -(porflux*fluxb(irhoe))
   fluxb(irhoe) = 0.0
   temp3b3 = -(porflux*fluxb(imz))
   fluxb(imz) = 0.0
   temp3b4 = -(porflux*fluxb(imy))
   fluxb(imy) = 0.0
   temp3b5 = -(porflux*fluxb(imx))
   fluxb(imx) = 0.0
   temp3b6 = -(porflux*fluxb(irho))
   abv6b = temp3b6 + uavg*temp3b5 + vavg*temp3b4 + wavg*temp3b3 + &
   &        havg*temp3b2
   abv7b = sx*temp3b5 + sy*temp3b4 + sz*temp3b3 + unavg*temp3b2
   abv3b = ova2avg*abv4*abv6b + abv5*abv7b
   lam3b = dr*temp3b6 - abv3b + dru*temp3b5 + drv*temp3b4 + drw*&
   &        temp3b3 + dre*temp3b2
   abv4b = ova2avg*abv3*abv6b + ovaavg*abv2*abv7b
   temp3b7 = gm1*abv4b
   dreb = temp3b7 + lam3*temp3b2
   havgb = abv6*temp3b2
   abv5b = ovaavg*abv2*abv6b + abv3*abv7b
   unavgb = abv7*temp3b2 - dr*abv5b
   drwb = sz*abv5b - wavg*temp3b7 + lam3*temp3b3
   wavgb = abv6*temp3b3 - drw*temp3b7
   szb = drw*abv5b + abv7*temp3b3
   drvb = sy*abv5b - vavg*temp3b7 + lam3*temp3b4
   vavgb = abv6*temp3b4 - drv*temp3b7
   syb = drv*abv5b + abv7*temp3b4
   drub = sx*abv5b - uavg*temp3b7 + lam3*temp3b5
   uavgb = abv6*temp3b5 - dru*temp3b7
   sxb = dru*abv5b + abv7*temp3b5
   drb = alphaavg*temp3b7 - unavg*abv5b + lam3*temp3b6
   fluxb(irho) = 0.0
   abv2b = ovaavg*abv5*abv6b + ovaavg*abv4*abv7b
   ovaavgb = abv2*abv5*abv6b + abv2*abv4*abv7b
   ova2avgb = abv3*abv4*abv6b
   alphaavgb = dr*temp3b7
   drkb = -(gm53*abv4b)
   abv1b = abv3b
   lam1b = half*abv1b + half*abv2b
   lam2b = half*abv1b - half*abv2b
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   areab = lam1*lam1b + lam2*lam2b + lam3*lam3b
   lam3b = area*lam3b
   lam2b = area*lam2b
   lam1b = area*lam1b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   etab = 0.0
   ELSE
   CALL POPREAL8(lam3)
   temp3b1 = fourth*lam3b/eta
   etab = lam3b - lam3**2*temp3b1/eta
   lam3b = 2*lam3*temp3b1
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(lam2)
   temp3b0 = fourth*lam2b/eta
   etab = etab + lam2b - lam2**2*temp3b0/eta
   lam2b = 2*lam2*temp3b0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(lam1)
   temp3b = fourth*lam1b/eta
   etab = etab + lam1b - lam1**2*temp3b/eta
   lam1b = 2*lam1*temp3b
   END IF
   CALL POPREAL8(tmp)
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   rfaceb = lam3b
   unavgb = unavgb - lam3b
   ELSE
   unavgb = unavgb + lam3b
   rfaceb = -lam3b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   rfaceb = rfaceb + lam2b
   unavgb = unavgb - lam2b
   aavgb = lam2b
   ELSE
   unavgb = unavgb + lam2b
   rfaceb = rfaceb - lam2b
   aavgb = -lam2b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   rfaceb = rfaceb + lam1b
   unavgb = unavgb - lam1b
   aavgb = aavgb - lam1b
   ELSE
   unavgb = unavgb + lam1b
   rfaceb = rfaceb - lam1b
   aavgb = aavgb + lam1b
   END IF
   abs1b = half*etab
   abs2b = half*etab
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x2b = -abs2b
   ELSE
   x2b = abs2b
   END IF
   temp2 = left(irhoe)/left(irho)
   temp2b = gammaface*x2b/(2.0*SQRT(gammaface*temp2)*left(irho))
   temp1 = right(irhoe)/right(irho)
   temp1b2 = -(gammaface*x2b/(2.0*SQRT(gammaface*temp1)*right(irho)))
   leftb(irhoe) = leftb(irhoe) + temp2b
   leftb(irho) = leftb(irho) - temp2*temp2b
   rightb(irhoe) = rightb(irhoe) + temp1b2
   rightb(irho) = rightb(irho) - temp1*temp1b2
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x1b = -abs1b
   ELSE
   x1b = abs1b
   END IF
   leftb(ivx) = leftb(ivx) + sx*x1b
   rightb(ivx) = rightb(ivx) - sx*x1b
   sxb = sxb + (left(ivx)-right(ivx))*x1b
   leftb(ivy) = leftb(ivy) + sy*x1b
   rightb(ivy) = rightb(ivy) - sy*x1b
   syb = syb + (left(ivy)-right(ivy))*x1b
   leftb(ivz) = leftb(ivz) + sz*x1b
   rightb(ivz) = rightb(ivz) - sz*x1b
   szb = szb + (left(ivz)-right(ivz))*x1b
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   rfaceb = rfaceb + unavgb
   unavgb = 0.0
   END IF
   aavgb = aavgb - one*ovaavgb/aavg**2
   a2avgb = aavgb/(2.0*SQRT(a2avg)) - one*ova2avgb/a2avg**2
   uavgb = uavgb + sx*unavgb
   sxb = sxb + uavg*unavgb
   vavgb = vavgb + sy*unavgb
   syb = syb + vavg*unavgb
   wavgb = wavgb + sz*unavgb
   szb = szb + wavg*unavgb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   kavgb = gm53*a2avgb
   havgb = havgb - gm1*a2avgb
   alphaavgb = alphaavgb + gm1*a2avgb
   ELSE
   havgb = havgb + gm1*a2avgb
   alphaavgb = alphaavgb - gm1*a2avgb
   kavgb = -(gm53*a2avgb)
   END IF
   temp1b1 = half*alphaavgb
   uavgb = uavgb + 2*uavg*temp1b1
   vavgb = vavgb + 2*vavg*temp1b1
   wavgb = wavgb + 2*wavg*temp1b1
   sfaceb = sfaceb + tmp*rfaceb
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tmpb = sx*sxb + sy*syb + sz*szb + sface*rfaceb
   szb = tmp*szb
   syb = tmp*syb
   sxb = tmp*sxb
   CALL POPREAL8(tmp)
   max1b = -(one*tmpb/max1**2)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) areab = areab + max1b
   temp1b = areab/(2.0*SQRT(sx**2+sy**2+sz**2))
   sxb = sxb + 2*sx*temp1b
   syb = syb + 2*sy*temp1b
   szb = szb + 2*sz*temp1b
   temp = (etr+right(irhoe))/z1r
   temp0 = (etl+left(irhoe))/z1l
   temp1b0 = tmp*havgb
   temp0b = temp1b0/z1l
   tempb1 = temp1b0/z1r
   tmpb = (z1l*left(ivx)+z1r*right(ivx))*uavgb + (z1l*left(ivy)+z1r*&
   &        right(ivy))*vavgb + (z1l*left(ivz)+z1r*right(ivz))*wavgb + (&
   &        temp0+temp)*havgb
   etlb = temp0b - dreb
   leftb(irhoe) = leftb(irhoe) + temp0b
   tempb2 = tmp*wavgb
   tempb3 = tmp*vavgb
   tempb4 = tmp*uavgb
   z1lb = left(ivx)*tempb4 + left(ivy)*tempb3 + left(ivz)*tempb2 - &
   &        temp0*temp0b
   etrb = dreb + tempb1
   rightb(irhoe) = rightb(irhoe) + tempb1
   z1rb = right(ivx)*tempb4 + right(ivy)*tempb3 + right(ivz)*tempb2 -&
   &       temp*tempb1
   leftb(ivz) = leftb(ivz) + z1l*tempb2
   rightb(ivz) = rightb(ivz) + z1r*tempb2
   leftb(ivy) = leftb(ivy) + z1l*tempb3
   rightb(ivy) = rightb(ivy) + z1r*tempb3
   leftb(ivx) = leftb(ivx) + z1l*tempb4
   rightb(ivx) = rightb(ivx) + z1r*tempb4
   rightb(irho) = rightb(irho) + right(ivz)*drwb
   rightb(ivz) = rightb(ivz) + right(irho)*drwb
   leftb(irho) = leftb(irho) - left(ivz)*drwb
   leftb(ivz) = leftb(ivz) - left(irho)*drwb
   rightb(irho) = rightb(irho) + right(ivy)*drvb
   rightb(ivy) = rightb(ivy) + right(irho)*drvb
   leftb(irho) = leftb(irho) - left(ivy)*drvb
   leftb(ivy) = leftb(ivy) - left(irho)*drvb
   rightb(irho) = rightb(irho) + right(ivx)*drub
   rightb(ivx) = rightb(ivx) + right(irho)*drub
   leftb(irho) = leftb(irho) - left(ivx)*drub
   leftb(ivx) = leftb(ivx) - left(irho)*drub
   rightb(irho) = rightb(irho) + drb
   leftb(irho) = leftb(irho) - drb
   etmpb(1:2) = 0.0
   etmpb(2) = etrb
   etmpb(1) = etmpb(1) + etlb
   CALL POPREAL8ARRAY(etmp, 2)
   ptmpb(:) = 0.0
   CALL ETOTARRAYADJ_B(rhotmp, rhotmpb, utmp, utmpb, vtmp, vtmpb, &
   &                    wtmp, wtmpb, ptmp, ptmpb, ktmp, ktmpb, etmp, etmpb&
   &                    , correctfork, 2)
   rightb(irhoe) = rightb(irhoe) + ptmpb(2)
   ptmpb(2) = 0.0
   leftb(irhoe) = leftb(irhoe) + ptmpb(1)
   rightb(ivz) = rightb(ivz) + wtmpb(2)
   wtmpb(2) = 0.0
   leftb(ivz) = leftb(ivz) + wtmpb(1)
   rightb(ivy) = rightb(ivy) + vtmpb(2)
   vtmpb(2) = 0.0
   leftb(ivy) = leftb(ivy) + vtmpb(1)
   rightb(ivx) = rightb(ivx) + utmpb(2)
   utmpb(2) = 0.0
   leftb(ivx) = leftb(ivx) + utmpb(1)
   rightb(irho) = rightb(irho) + rhotmpb(2)
   rhotmpb(2) = 0.0
   leftb(irho) = leftb(irho) + rhotmpb(1)
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   tempb0 = tmp*kavgb
   tmpb = tmpb + (z1l*left(itu1)+z1r*right(itu1))*kavgb
   z1lb = z1lb + left(itu1)*tempb0
   leftb(itu1) = leftb(itu1) + z1l*tempb0
   z1rb = z1rb + right(itu1)*tempb0
   rightb(itu1) = rightb(itu1) + z1r*tempb0
   rightb(irho) = rightb(irho) + right(itu1)*drkb
   rightb(itu1) = rightb(itu1) + ktmpb(2) + right(irho)*drkb
   leftb(irho) = leftb(irho) - left(itu1)*drkb
   ktmpb(2) = 0.0
   leftb(itu1) = leftb(itu1) + ktmpb(1) - left(irho)*drkb
   END IF
   tempb = -(one*tmpb/(z1l+z1r)**2)
   z1lb = z1lb + tempb
   z1rb = z1rb + tempb
   rightb(irho) = rightb(irho) + z1rb/(2.0*SQRT(right(irho)))
   leftb(irho) = leftb(irho) + z1lb/(2.0*SQRT(left(irho)))
   CASE (turkel) 
   sxb = 0.0
   syb = 0.0
   szb = 0.0
   CASE (choimerkle) 
   sxb = 0.0
   syb = 0.0
   szb = 0.0
   CASE DEFAULT
   sxb = 0.0
   syb = 0.0
   szb = 0.0
   END SELECT
   CASE (vanleer) 
   sxb = 0.0
   syb = 0.0
   szb = 0.0
   CASE (ausmdv) 
   sxb = 0.0
   syb = 0.0
   szb = 0.0
   CASE DEFAULT
   sxb = 0.0
   syb = 0.0
   szb = 0.0
   END SELECT
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END SUBROUTINE RIEMANNFLUXADJ_B
