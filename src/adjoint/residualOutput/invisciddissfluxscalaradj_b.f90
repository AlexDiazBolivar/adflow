!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of invisciddissfluxscalaradj in reverse (adjoint) mode:
!   gradient, with respect to input variables: padj radkadj radjadj
!                dwadj wadj radiadj
!   of linear combination of output variables: dwadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          inviscidDissFluxScalarAdj.f90                   *
!      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
!      * Starting date: 06-10-2009                                      *
!      * Last modified: 06-10-2009                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INVISCIDDISSFLUXSCALARADJ_B(wadj, wadjb, padj, padjb, dwadj, &
&  dwadjb, radiadj, radiadjb, radjadj, radjadjb, radkadj, radkadjb, &
&  icell, jcell, kcell)
  USE blockpointers
  USE cgnsgrid
  USE constants
  USE flowvarrefstate
  USE inputdiscretization
  USE inputphysics
  USE iteration
  IMPLICIT NONE
!!$       do k=2,kl
!!$         do j=2,jl
!!$           rhoi           = one/w(0,j,k,irho)
!!$           w(0,j,k,ivx)   = w(0,j,k,ivx)*rhoi
!!$           w(0,j,k,ivy)   = w(0,j,k,ivy)*rhoi
!!$           w(0,j,k,ivz)   = w(0,j,k,ivz)*rhoi
!!$           w(0,j,k,irhoE) = w(0,j,k,irhoE) - p(0,j,k)
!!$
!!$           rhoi           = one/w(1,j,k,irho)
!!$           w(1,j,k,ivx)   = w(1,j,k,ivx)*rhoi
!!$           w(1,j,k,ivy)   = w(1,j,k,ivy)*rhoi
!!$           w(1,j,k,ivz)   = w(1,j,k,ivz)*rhoi
!!$           w(1,j,k,irhoE) = w(1,j,k,irhoE) - p(1,j,k)
!!$
!!$           rhoi            = one/w(ie,j,k,irho)
!!$           w(ie,j,k,ivx)   = w(ie,j,k,ivx)*rhoi
!!$           w(ie,j,k,ivy)   = w(ie,j,k,ivy)*rhoi
!!$           w(ie,j,k,ivz)   = w(ie,j,k,ivz)*rhoi
!!$           w(ie,j,k,irhoE) = w(ie,j,k,irhoE) - p(ie,j,k)
!!$
!!$           rhoi            = one/w(ib,j,k,irho)
!!$           w(ib,j,k,ivx)   = w(ib,j,k,ivx)*rhoi
!!$           w(ib,j,k,ivy)   = w(ib,j,k,ivy)*rhoi
!!$           w(ib,j,k,ivz)   = w(ib,j,k,ivz)*rhoi
!!$           w(ib,j,k,irhoE) = w(ib,j,k,irhoE) - p(ib,j,k)
!!$         enddo
!!$       enddo
!!$
!!$       do k=2,kl
!!$         do i=2,il
!!$           rhoi           = one/w(i,0,k,irho)
!!$           w(i,0,k,ivx)   = w(i,0,k,ivx)*rhoi
!!$           w(i,0,k,ivy)   = w(i,0,k,ivy)*rhoi
!!$           w(i,0,k,ivz)   = w(i,0,k,ivz)*rhoi
!!$           w(i,0,k,irhoE) = w(i,0,k,irhoE) - p(i,0,k)
!!$
!!$           rhoi           = one/w(i,1,k,irho)
!!$           w(i,1,k,ivx)   = w(i,1,k,ivx)*rhoi
!!$           w(i,1,k,ivy)   = w(i,1,k,ivy)*rhoi
!!$           w(i,1,k,ivz)   = w(i,1,k,ivz)*rhoi
!!$           w(i,1,k,irhoE) = w(i,1,k,irhoE) - p(i,1,k)
!!$
!!$           rhoi            = one/w(i,je,k,irho)
!!$           w(i,je,k,ivx)   = w(i,je,k,ivx)*rhoi
!!$           w(i,je,k,ivy)   = w(i,je,k,ivy)*rhoi
!!$           w(i,je,k,ivz)   = w(i,je,k,ivz)*rhoi
!!$           w(i,je,k,irhoE) = w(i,je,k,irhoE) - p(i,je,k)
!!$
!!$           rhoi            = one/w(i,jb,k,irho)
!!$           w(i,jb,k,ivx)   = w(i,jb,k,ivx)*rhoi
!!$           w(i,jb,k,ivy)   = w(i,jb,k,ivy)*rhoi
!!$           w(i,jb,k,ivz)   = w(i,jb,k,ivz)*rhoi
!!$           w(i,jb,k,irhoE) = w(i,jb,k,irhoE) - p(i,jb,k)
!!$         enddo
!!$       enddo
  REAL(KIND=REALTYPE) :: dwadj(nw), dwadjb(nw)
  INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2)
  REAL(KIND=REALTYPE) :: radiadj(-1:1, -1:1, -1:1), radiadjb(-1:1, -1:1&
&  , -1:1), radjadj(-1:1, -1:1, -1:1), radjadjb(-1:1, -1:1, -1:1), &
&  radkadj(-1:1, -1:1, -1:1), radkadjb(-1:1, -1:1, -1:1)
  REAL(KIND=REALTYPE) :: wadj(-2:2, -2:2, -2:2, nw), wadjb(-2:2, -2:2, -&
&  2:2, nw)
  REAL(KIND=REALTYPE), PARAMETER :: dssmax=0.25_realType
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: ddw, ddwb, dss1, dss1b, dss2, dss2b, fs, fsb, &
&  temp1b0, temp1b1, temp1b2, temp1b3, temp1b4, temp3b0, temp3b1, &
&  temp3b2, temp3b3, temp3b4, temp5b0, temp5b1, temp5b2, temp5b3, &
&  temp5b4
  REAL(KIND=REALTYPE) :: fact
  INTEGER(KIND=INTTYPE) :: i, ind, j, k
  INTEGER(KIND=INTTYPE) :: ii, jj, kk
  REAL(KIND=REALTYPE) :: dis2, dis2b, dis4, dis4b, ppor, rrad, rradb
  REAL(KIND=REALTYPE) :: fis2, fis4, sfil
  REAL(KIND=REALTYPE) :: rhoi, sslim, temp, temp0, temp0b0, temp1, &
&  temp1b5, temp2, temp2b0, temp3, temp3b5, temp4, temp4b0, tempb
  REAL(KIND=REALTYPE) :: tmp, tmp0, tmp0b, tmp1, tmp1b, tmpb
  REAL(KIND=REALTYPE) :: ss(-2:2, -2:2, -2:2), ssb(-2:2, -2:2, -2:2), &
&  temp0b, temp1b, temp2b, temp3b, temp4b, temp5b, x1, x1b, x2, x2b, x3&
&  , x3b, x4, x4b, x5, x5b, x6, x6b
  REAL(KIND=REALTYPE) :: min1, min1b, min2, min2b, min3, min3b, y1, y1b&
&  , y2, y2b, y3, y3b
  INTRINSIC MAX, ABS, MIN
!
!      ******************************************************************
!      *                                                                *
!      * inviscidDissFluxScalar computes the scalar artificial          *
!      * dissipation, see AIAA paper 81-1259, for a given block.        *
!      * Therefore it is assumed that the pointers in  blockPointers    *
!      * already point to the correct block.                            *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments
!
!
!      Local parameter.
!
!
!      Local variables.
!
!real(kind=realType), dimension(0:ib,0:jb,0:kb) :: ss
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Check if rFil == 0. If so, the dissipative flux needs not to
! be computed.
  IF (rfil .EQ. zero) THEN
    padjb(-2:2, -2:2, -2:2) = 0.0
    radkadjb(-1:1, -1:1, -1:1) = 0.0
    radjadjb(-1:1, -1:1, -1:1) = 0.0
    wadjb(-2:2, -2:2, -2:2, 1:nw) = 0.0
    radiadjb(-1:1, -1:1, -1:1) = 0.0
  ELSE
!!$           ! Viscous case. Pressure switch is based on the entropy.
!!$           ! Also set the value of sslim. To be fully consistent this
!!$           ! must have the dimension of entropy and it is therefore
!!$           ! set to a fraction of the free stream value.
!!$
!!$           sslim = 0.001_realType*pInfCorr/(rhoInf**gammaInf)
!!$
!!$           ! Store the entropy in ss. Only fill the entries used in
!!$           ! the discretization, i.e. ignore the corner halo's.
!!$
!!$           do k=0,kb
!!$             do j=2,jl
!!$               do i=2,il
!!$                 ss(i,j,k) = p(i,j,k)/(w(i,j,k,irho)**gamma(i,j,k))
!!$               enddo
!!$             enddo
!!$           enddo
!!$
!!$           do k=2,kl
!!$             do j=2,jl
!!$               ss(0, j,k) = p(0, j,k)/(w(0, j,k,irho)**gamma(0, j,k))
!!$               ss(1, j,k) = p(1, j,k)/(w(1, j,k,irho)**gamma(1, j,k))
!!$               ss(ie,j,k) = p(ie,j,k)/(w(ie,j,k,irho)**gamma(ie,j,k))
!!$               ss(ib,j,k) = p(ib,j,k)/(w(ib,j,k,irho)**gamma(ib,j,k))
!!$             enddo
!!$           enddo
!!$
!!$           do k=2,kl
!!$             do i=2,il
!!$               ss(i,0, k) = p(i,0, k)/(w(i,0, k,irho)**gamma(i,0, k))
!!$               ss(i,1, k) = p(i,1, k)/(w(i,1, k,irho)**gamma(i,1, k))
!!$               ss(i,je,k) = p(i,je,k)/(w(i,je,k,irho)**gamma(i,je,k))
!!$               ss(i,jb,k) = p(i,jb,k)/(w(i,jb,k,irho)**gamma(i,jb,k))
!!$             enddo
!!$           enddo
! Determine the variables used to compute the switch.
! For the inviscid case this is the pressure; for the viscous
! case it is the entropy.
    SELECT CASE  (equations) 
    CASE (eulerequations) 
! Inviscid case. Pressure switch is based on the pressure.
! Also set the value of sslim. To be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
      sslim = 0.001_realType*pinfcorr
! Copy the pressure in ss. Only fill the entries used in
! the discretization, i.e. ignore the corner halo's.
!do we need to ignore the corners in the ADjoint?... leave in for now...
!0,kb
      DO k=-2,2
!2,jl
        DO j=-2,2
!2,il
          DO i=-2,2
            ss(i, j, k) = padj(i, j, k)
          END DO
        END DO
      END DO
      CALL PUSHINTEGER4(1)
    CASE DEFAULT
      CALL PUSHINTEGER4(0)
    END SELECT
! Set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
! Replace the total energy by rho times the total enthalpy.
! In this way the numerical solution is total enthalpy preserving
! for the steady Euler equations. Also replace the velocities by
! the momentum. Only done for the entries used in the
! discretization, i.e. ignore the corner halo's.
!0,kb
    DO k=-2,2
!2,jl
      DO j=-2,2
!2,il
        DO i=-2,2
          tmp = wadj(i, j, k, irho)*wadj(i, j, k, ivx)
          CALL PUSHREAL8(wadj(i, j, k, ivx))
          wadj(i, j, k, ivx) = tmp
          tmp0 = wadj(i, j, k, irho)*wadj(i, j, k, ivy)
          CALL PUSHREAL8(wadj(i, j, k, ivy))
          wadj(i, j, k, ivy) = tmp0
          tmp1 = wadj(i, j, k, irho)*wadj(i, j, k, ivz)
          CALL PUSHREAL8(wadj(i, j, k, ivz))
          wadj(i, j, k, ivz) = tmp1
          CALL PUSHREAL8(wadj(i, j, k, irhoe))
          wadj(i, j, k, irhoe) = wadj(i, j, k, irhoe) + padj(i, j, k)
        END DO
      END DO
    END DO
!!$       do k=2,kl
!!$         do j=2,jl
!!$           w(0,j,k,ivx)   = w(0,j,k,irho)*w(0,j,k,ivx)
!!$           w(0,j,k,ivy)   = w(0,j,k,irho)*w(0,j,k,ivy)
!!$           w(0,j,k,ivz)   = w(0,j,k,irho)*w(0,j,k,ivz)
!!$           w(0,j,k,irhoE) = w(0,j,k,irhoE) + p(0,j,k)
!!$
!!$           w(1,j,k,ivx)   = w(1,j,k,irho)*w(1,j,k,ivx)
!!$           w(1,j,k,ivy)   = w(1,j,k,irho)*w(1,j,k,ivy)
!!$           w(1,j,k,ivz)   = w(1,j,k,irho)*w(1,j,k,ivz)
!!$           w(1,j,k,irhoE) = w(1,j,k,irhoE) + p(1,j,k)
!!$
!!$           w(ie,j,k,ivx)   = w(ie,j,k,irho)*w(ie,j,k,ivx)
!!$           w(ie,j,k,ivy)   = w(ie,j,k,irho)*w(ie,j,k,ivy)
!!$           w(ie,j,k,ivz)   = w(ie,j,k,irho)*w(ie,j,k,ivz)
!!$           w(ie,j,k,irhoE) = w(ie,j,k,irhoE) + p(ie,j,k)
!!$
!!$           w(ib,j,k,ivx)   = w(ib,j,k,irho)*w(ib,j,k,ivx)
!!$           w(ib,j,k,ivy)   = w(ib,j,k,irho)*w(ib,j,k,ivy)
!!$           w(ib,j,k,ivz)   = w(ib,j,k,irho)*w(ib,j,k,ivz)
!!$           w(ib,j,k,irhoE) = w(ib,j,k,irhoE) + p(ib,j,k)
!!$         enddo
!!$       enddo
!!$       do k=2,kl
!!$         do i=2,il
!!$           w(i,0,k,ivx)   = w(i,0,k,irho)*w(i,0,k,ivx)
!!$           w(i,0,k,ivy)   = w(i,0,k,irho)*w(i,0,k,ivy)
!!$           w(i,0,k,ivz)   = w(i,0,k,irho)*w(i,0,k,ivz)
!!$           w(i,0,k,irhoE) = w(i,0,k,irhoE) + p(i,0,k)
!!$
!!$           w(i,1,k,ivx)   = w(i,1,k,irho)*w(i,1,k,ivx)
!!$           w(i,1,k,ivy)   = w(i,1,k,irho)*w(i,1,k,ivy)
!!$           w(i,1,k,ivz)   = w(i,1,k,irho)*w(i,1,k,ivz)
!!$           w(i,1,k,irhoE) = w(i,1,k,irhoE) + p(i,1,k)
!!$
!!$           w(i,je,k,ivx)   = w(i,je,k,irho)*w(i,je,k,ivx)
!!$           w(i,je,k,ivy)   = w(i,je,k,irho)*w(i,je,k,ivy)
!!$           w(i,je,k,ivz)   = w(i,je,k,irho)*w(i,je,k,ivz)
!!$           w(i,je,k,irhoE) = w(i,je,k,irhoE) + p(i,je,k)
!!$
!!$           w(i,jb,k,ivx)   = w(i,jb,k,irho)*w(i,jb,k,ivx)
!!$           w(i,jb,k,ivy)   = w(i,jb,k,irho)*w(i,jb,k,ivy)
!!$           w(i,jb,k,ivz)   = w(i,jb,k,irho)*w(i,jb,k,ivz)
!!$           w(i,jb,k,irhoE) = w(i,jb,k,irhoE) + p(i,jb,k)
!!$         enddo
!!$       enddo
!Following method in the upwind scheme, take the residual onto dwAdj instead 
!of a separate fw. If it needs to be switched back, fw is dissiptive, dw is
!inviscid...
!!$       ! Initialize the dissipative residual to a certain times,
!!$       ! possibly zero, the previously stored value. Owned cells
!!$       ! only, because the halo values do not matter.
!!$
!!$!       do k=2,kl
!!$!         do j=2,jl
!!$!           do i=2,il
!!$             fw(irho)  = sfil*fw(irho)
!!$             fw(imx)   = sfil*fw(imx)
!!$             fw(imy)   = sfil*fw(imy)
!!$             fw(imz)   = sfil*fw(imz)
!!$             fw(irhoE) = sfil*fw(irhoE)
!!$ !          enddo
!!$ !        enddo
!!$ !      enddo
!
!      ******************************************************************
!      *                                                                *
!      * Dissipative fluxes in the i-direction.                         *
!      *                                                                *
!      ******************************************************************
! 
!set some indices for use later
    i = icell - 1
    j = jcell
    k = kcell
    fact = one
!do k=2,kl
!  do j=2,jl
! Compute the pressure sensor in the first cell, which
! is a halo cell.
!!dss1 = abs((ss(2,j,k) - two*ss(1,j,k) + ss(0,j,k)) &
!!     /     (ss(2,j,k) + two*ss(1,j,k) + ss(0,j,k) + sslim))
! Loop in i-direction.
    DO ii=-1,0
      x1 = (ss(ii+1, 0, 0)-two*ss(ii, 0, 0)+ss(ii-1, 0, 0))/(ss(ii+1, 0&
&        , 0)+two*ss(ii, 0, 0)+ss(ii-1, 0, 0)+sslim)
      IF (x1 .GE. 0.) THEN
        dss1 = x1
        CALL PUSHINTEGER4(1)
      ELSE
        dss1 = -x1
        CALL PUSHINTEGER4(0)
      END IF
      x2 = (ss(ii+2, 0, 0)-two*ss(ii+1, 0, 0)+ss(ii, 0, 0))/(ss(ii+2, 0&
&        , 0)+two*ss(ii+1, 0, 0)+ss(ii, 0, 0)+sslim)
      IF (x2 .GE. 0.) THEN
        dss2 = x2
        CALL PUSHINTEGER4(1)
      ELSE
        dss2 = -x2
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(ppor)
!print *,'dss2',dss2
! Compute the dissipation coefficients for this face.
      ppor = zero
      IF (pori(i, j, k) .EQ. normalflux) THEN
        ppor = half
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(rrad)
!rrad = ppor*(radI(i,j,k) + radI(i+1,j,k))
      rrad = ppor*(radiadj(ii, 0, 0)+radiadj(ii+1, 0, 0))
      IF (dss1 .LT. dss2) THEN
        y1 = dss2
        CALL PUSHINTEGER4(1)
      ELSE
        y1 = dss1
        CALL PUSHINTEGER4(0)
      END IF
      IF (dssmax .GT. y1) THEN
        CALL PUSHREAL8(min1)
        min1 = y1
        CALL PUSHINTEGER4(0)
      ELSE
        CALL PUSHREAL8(min1)
        min1 = dssmax
        CALL PUSHINTEGER4(1)
      END IF
      CALL PUSHREAL8(dis2)
!print *,'radI',radIAdj(ii,0,0),radI(icell+ii,jcell,kcell),icell,jcell,kcell,radIAdj(ii+1,0,0),radI(icell+ii+1,jcell,kcell)
      dis2 = fis2*rrad*min1
!dis4 = dim(fis4*rrad, dis2)
      IF (fis4*rrad - dis2 .GT. 0.0) THEN
        CALL PUSHREAL8(dis4)
        dis4 = fis4*rrad - dis2
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHREAL8(dis4)
        dis4 = 0.0
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(ddw)
! Compute and scatter the dissipative flux.
! Density. Store it in the mass flow of the
! appropriate sliding mesh interface.
      ddw = wadj(ii+1, 0, 0, irho) - wadj(ii, 0, 0, irho)
      CALL PUSHREAL8(ddw)
!fw(i+1,j,k,irho) = fw(i+1,j,k,irho) + fs
!fw(i,j,k,irho)   = fw(i,j,k,irho)   - fs
! X-momentum.
      ddw = wadj(ii+1, 0, 0, ivx) - wadj(ii, 0, 0, ivx)
      CALL PUSHREAL8(ddw)
!fw(i+1,j,k,imx) = fw(i+1,j,k,imx) + fs
!fw(i,j,k,imx)   = fw(i,j,k,imx)   - fs
! Y-momentum.
      ddw = wadj(ii+1, 0, 0, ivy) - wadj(ii, 0, 0, ivy)
      CALL PUSHREAL8(ddw)
!fw(i+1,j,k,imy) = fw(i+1,j,k,imy) + fs
!fw(i,j,k,imy)   = fw(i,j,k,imy)   - fs
! Z-momentum.
      ddw = wadj(ii+1, 0, 0, ivz) - wadj(ii, 0, 0, ivz)
      CALL PUSHREAL8(ddw)
!fw(i+1,j,k,imz) = fw(i+1,j,k,imz) + fs
!fw(i,j,k,imz)   = fw(i,j,k,imz)   - fs
! Energy.
      ddw = wadj(ii+1, 0, 0, irhoe) - wadj(ii, 0, 0, irhoe)
!fw(i+1,j,k,irhoE) = fw(i+1,j,k,irhoE) + fs
!fw(i,j,k,irhoE)   = fw(i,j,k,irhoE)   - fs
! Update i and set fact to 1 for the second face.
      i = i + 1
      CALL PUSHREAL8(fact)
      fact = -one
    END DO
!!! Set dss1 to dss2 for the next face.
!!
!!dss1 = dss2
!         enddo
!       enddo
!
!      ******************************************************************
!      *                                                                *
!      * Dissipative fluxes in the j-direction.                         *
!      *                                                                *
!      ******************************************************************
!
! do k=2,kl
!   do i=2,il
    i = icell
    j = jcell - 1
    k = kcell
    fact = one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO jj=-1,0
      x3 = (ss(0, jj+1, 0)-two*ss(0, jj, 0)+ss(0, jj-1, 0))/(ss(0, jj+1&
&        , 0)+two*ss(0, jj, 0)+ss(0, jj-1, 0)+sslim)
      IF (x3 .GE. 0.) THEN
        dss1 = x3
        CALL PUSHINTEGER4(1)
      ELSE
        dss1 = -x3
        CALL PUSHINTEGER4(0)
      END IF
      x4 = (ss(0, jj+2, 0)-two*ss(0, jj+1, 0)+ss(0, jj, 0))/(ss(0, jj+2&
&        , 0)+two*ss(0, jj+1, 0)+ss(0, jj, 0)+sslim)
      IF (x4 .GE. 0.) THEN
        dss2 = x4
        CALL PUSHINTEGER4(1)
      ELSE
        dss2 = -x4
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(ppor)
! Compute the dissipation coefficients for this face.
      ppor = zero
      IF (porj(i, j, k) .EQ. normalflux) THEN
        ppor = half
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(rrad)
!rrad = ppor*(radJ(i,j,k) + radJ(i,j+1,k))
      rrad = ppor*(radjadj(0, jj, 0)+radjadj(0, jj+1, 0))
      IF (dss1 .LT. dss2) THEN
        y2 = dss2
        CALL PUSHINTEGER4(1)
      ELSE
        y2 = dss1
        CALL PUSHINTEGER4(0)
      END IF
      IF (dssmax .GT. y2) THEN
        CALL PUSHREAL8(min2)
        min2 = y2
        CALL PUSHINTEGER4(0)
      ELSE
        CALL PUSHREAL8(min2)
        min2 = dssmax
        CALL PUSHINTEGER4(1)
      END IF
      CALL PUSHREAL8(dis2)
      dis2 = fis2*rrad*min2
!dis4 = dim(fis4*rrad, dis2)
      IF (fis4*rrad - dis2 .GT. 0.0) THEN
        CALL PUSHREAL8(dis4)
        dis4 = fis4*rrad - dis2
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHREAL8(dis4)
        dis4 = 0.0
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(ddw)
! Compute and scatter the dissipative flux.
! Density. Store it in the mass flow of the
! appropriate sliding mesh interface.
      ddw = wadj(0, jj+1, 0, irho) - wadj(0, jj, 0, irho)
      CALL PUSHREAL8(ddw)
!fw(i,j+1,k,irho) = fw(i,j+1,k,irho) + fs
!fw(i,j,k,irho)   = fw(i,j,k,irho)   - fs
! X-momentum.
      ddw = wadj(0, jj+1, 0, ivx) - wadj(0, jj, 0, ivx)
      CALL PUSHREAL8(ddw)
!fw(i,j+1,k,imx) = fw(i,j+1,k,imx) + fs
!fw(i,j,k,imx)   = fw(i,j,k,imx)   - fs
! Y-momentum.
      ddw = wadj(0, jj+1, 0, ivy) - wadj(0, jj, 0, ivy)
      CALL PUSHREAL8(ddw)
!fw(i,j+1,k,imy) = fw(i,j+1,k,imy) + fs
!fw(i,j,k,imy)   = fw(i,j,k,imy)   - fs
! Z-momentum.
      ddw = wadj(0, jj+1, 0, ivz) - wadj(0, jj, 0, ivz)
      CALL PUSHREAL8(ddw)
!fw(i,j+1,k,imz) = fw(i,j+1,k,imz) + fs
!fw(i,j,k,imz)   = fw(i,j,k,imz)   - fs
! Energy.
      ddw = wadj(0, jj+1, 0, irhoe) - wadj(0, jj, 0, irhoe)
!fw(i,j+1,k,irhoE) = fw(i,j+1,k,irhoE) + fs
!fw(i,j,k,irhoE)   = fw(i,j,k,irhoE)   - fs
! Update j and set fact to 1 for the second face.
      j = j + 1
      CALL PUSHREAL8(fact)
      fact = -one
    END DO
!!! Set dss1 to dss2 for the next face.
!!
!!dss1 = dss2
!enddo
!enddo
!
!      ******************************************************************
!      *                                                                *
!      * Dissipative fluxes in the k-direction.                         *
!      *                                                                *
!      ******************************************************************
!    
! Fluxes in k-direction.
    i = icell
    j = jcell
    k = kcell - 1
    fact = one
!       do j=2,jl
!         do i=2,il
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO kk=-1,0
      x5 = (ss(0, 0, kk+1)-two*ss(0, 0, kk)+ss(0, 0, kk-1))/(ss(0, 0, kk&
&        +1)+two*ss(0, 0, kk)+ss(0, 0, kk-1)+sslim)
      IF (x5 .GE. 0.) THEN
        dss1 = x5
        CALL PUSHINTEGER4(1)
      ELSE
        dss1 = -x5
        CALL PUSHINTEGER4(0)
      END IF
      x6 = (ss(0, 0, kk+2)-two*ss(0, 0, kk+1)+ss(0, 0, kk))/(ss(0, 0, kk&
&        +2)+two*ss(0, 0, kk+1)+ss(0, 0, kk)+sslim)
      IF (x6 .GE. 0.) THEN
        dss2 = x6
        CALL PUSHINTEGER4(1)
      ELSE
        dss2 = -x6
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(ppor)
! Compute the dissipation coefficients for this face.
      ppor = zero
      IF (pork(i, j, k) .EQ. normalflux) THEN
        ppor = half
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(rrad)
!rrad = ppor*(radK(i,j,k) + radK(i,j,k+1))
      rrad = ppor*(radkadj(0, 0, kk)+radkadj(0, 0, kk+1))
      IF (dss1 .LT. dss2) THEN
        y3 = dss2
        CALL PUSHINTEGER4(1)
      ELSE
        y3 = dss1
        CALL PUSHINTEGER4(0)
      END IF
      IF (dssmax .GT. y3) THEN
        CALL PUSHREAL8(min3)
        min3 = y3
        CALL PUSHINTEGER4(0)
      ELSE
        CALL PUSHREAL8(min3)
        min3 = dssmax
        CALL PUSHINTEGER4(1)
      END IF
      CALL PUSHREAL8(dis2)
      dis2 = fis2*rrad*min3
!dis4 = dim(fis4*rrad, dis2)
      IF (fis4*rrad - dis2 .GT. 0.0) THEN
        CALL PUSHREAL8(dis4)
        dis4 = fis4*rrad - dis2
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHREAL8(dis4)
        dis4 = 0.0
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(ddw)
! Compute and scatter the dissipative flux.
! Density. Store it in the mass flow of the
! appropriate sliding mesh interface.
      ddw = wadj(0, 0, kk+1, irho) - wadj(0, 0, kk, irho)
      CALL PUSHREAL8(ddw)
!fw(i,j,k+1,irho) = fw(i,j,k+1,irho) + fs
!fw(i,j,k,irho)   = fw(i,j,k,irho)   - fs
! X-momentum.
      ddw = wadj(0, 0, kk+1, ivx) - wadj(0, 0, kk, ivx)
      CALL PUSHREAL8(ddw)
!fw(i,j,k+1,imx) = fw(i,j,k+1,imx) + fs
!fw(i,j,k,imx)   = fw(i,j,k,imx)   - fs
! Y-momentum.
      ddw = wadj(0, 0, kk+1, ivy) - wadj(0, 0, kk, ivy)
      CALL PUSHREAL8(ddw)
!fw(i,j,k+1,imy) = fw(i,j,k+1,imy) + fs
!fw(i,j,k,imy)   = fw(i,j,k,imy)   - fs
! Z-momentum.
      ddw = wadj(0, 0, kk+1, ivz) - wadj(0, 0, kk, ivz)
      CALL PUSHREAL8(ddw)
!fw(i,j,k+1,imz) = fw(i,j,k+1,imz) + fs
!fw(i,j,k,imz)   = fw(i,j,k,imz)   - fs
! Energy.
      ddw = wadj(0, 0, kk+1, irhoe) - wadj(0, 0, kk, irhoe)
!fw(i,j,k+1,irhoE) = fw(i,j,k+1,irhoE) + fs
!fw(i,j,k,irhoE)   = fw(i,j,k,irhoE)   - fs
! Update k and set fact to 1 for the second face.
      k = k + 1
      CALL PUSHREAL8(fact)
      fact = -one
    END DO
    radkadjb(-1:1, -1:1, -1:1) = 0.0
    wadjb(-2:2, -2:2, -2:2, 1:nw) = 0.0
    ssb(-2:2, -2:2, -2:2) = 0.0
    DO kk=0,-1,-1
      CALL POPREAL8(fact)
      fsb = fact*dwadjb(irhoe)
      temp5b0 = -(dis4*fsb)
      dis2b = ddw*fsb
      ddwb = dis2*fsb - three*temp5b0
      dis4b = -((wadj(0, 0, kk+2, irhoe)-wadj(0, 0, kk-1, irhoe)-three*&
&        ddw)*fsb)
      wadjb(0, 0, kk+2, irhoe) = wadjb(0, 0, kk+2, irhoe) + temp5b0
      wadjb(0, 0, kk-1, irhoe) = wadjb(0, 0, kk-1, irhoe) - temp5b0
      CALL POPREAL8(ddw)
      wadjb(0, 0, kk+1, irhoe) = wadjb(0, 0, kk+1, irhoe) + ddwb
      wadjb(0, 0, kk, irhoe) = wadjb(0, 0, kk, irhoe) - ddwb
      fsb = fact*dwadjb(imz)
      temp5b1 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp5b1
      dis4b = dis4b - (wadj(0, 0, kk+2, ivz)-wadj(0, 0, kk-1, ivz)-three&
&        *ddw)*fsb
      wadjb(0, 0, kk+2, ivz) = wadjb(0, 0, kk+2, ivz) + temp5b1
      wadjb(0, 0, kk-1, ivz) = wadjb(0, 0, kk-1, ivz) - temp5b1
      CALL POPREAL8(ddw)
      wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + ddwb
      wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) - ddwb
      fsb = fact*dwadjb(imy)
      temp5b2 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp5b2
      dis4b = dis4b - (wadj(0, 0, kk+2, ivy)-wadj(0, 0, kk-1, ivy)-three&
&        *ddw)*fsb
      wadjb(0, 0, kk+2, ivy) = wadjb(0, 0, kk+2, ivy) + temp5b2
      wadjb(0, 0, kk-1, ivy) = wadjb(0, 0, kk-1, ivy) - temp5b2
      CALL POPREAL8(ddw)
      wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + ddwb
      wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) - ddwb
      fsb = fact*dwadjb(imx)
      temp5b3 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp5b3
      dis4b = dis4b - (wadj(0, 0, kk+2, ivx)-wadj(0, 0, kk-1, ivx)-three&
&        *ddw)*fsb
      wadjb(0, 0, kk+2, ivx) = wadjb(0, 0, kk+2, ivx) + temp5b3
      wadjb(0, 0, kk-1, ivx) = wadjb(0, 0, kk-1, ivx) - temp5b3
      CALL POPREAL8(ddw)
      wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + ddwb
      wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) - ddwb
      fsb = fact*dwadjb(irho)
      temp5b4 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp5b4
      dis4b = dis4b - (wadj(0, 0, kk+2, irho)-wadj(0, 0, kk-1, irho)-&
&        three*ddw)*fsb
      wadjb(0, 0, kk+2, irho) = wadjb(0, 0, kk+2, irho) + temp5b4
      wadjb(0, 0, kk-1, irho) = wadjb(0, 0, kk-1, irho) - temp5b4
      CALL POPREAL8(ddw)
      wadjb(0, 0, kk+1, irho) = wadjb(0, 0, kk+1, irho) + ddwb
      wadjb(0, 0, kk, irho) = wadjb(0, 0, kk, irho) - ddwb
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPREAL8(dis4)
        rradb = 0.0
      ELSE
        CALL POPREAL8(dis4)
        rradb = fis4*dis4b
        dis2b = dis2b - dis4b
      END IF
      CALL POPREAL8(dis2)
      rradb = rradb + fis2*min3*dis2b
      min3b = fis2*rrad*dis2b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPREAL8(min3)
        y3b = min3b
      ELSE
        CALL POPREAL8(min3)
        y3b = 0.0
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        dss1b = y3b
        dss2b = 0.0
      ELSE
        dss2b = y3b
        dss1b = 0.0
      END IF
      CALL POPREAL8(rrad)
      radkadjb(0, 0, kk) = radkadjb(0, 0, kk) + ppor*rradb
      radkadjb(0, 0, kk+1) = radkadjb(0, 0, kk+1) + ppor*rradb
      CALL POPINTEGER4(branch)
      CALL POPREAL8(ppor)
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x6b = -dss2b
      ELSE
        x6b = dss2b
      END IF
      temp4 = sslim + ss(0, 0, kk+2) + two*ss(0, 0, kk+1) + ss(0, 0, kk)
      temp5b = x6b/temp4
      temp4b0 = -((ss(0, 0, kk+2)-two*ss(0, 0, kk+1)+ss(0, 0, kk))*&
&        temp5b/temp4)
      ssb(0, 0, kk+2) = ssb(0, 0, kk+2) + temp4b0 + temp5b
      ssb(0, 0, kk+1) = ssb(0, 0, kk+1) + two*temp4b0 - two*temp5b
      ssb(0, 0, kk) = ssb(0, 0, kk) + temp4b0 + temp5b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x5b = -dss1b
      ELSE
        x5b = dss1b
      END IF
      temp3 = sslim + ss(0, 0, kk+1) + two*ss(0, 0, kk) + ss(0, 0, kk-1)
      temp4b = x5b/temp3
      temp3b5 = -((ss(0, 0, kk+1)-two*ss(0, 0, kk)+ss(0, 0, kk-1))*&
&        temp4b/temp3)
      ssb(0, 0, kk+1) = ssb(0, 0, kk+1) + temp3b5 + temp4b
      ssb(0, 0, kk) = ssb(0, 0, kk) + two*temp3b5 - two*temp4b
      ssb(0, 0, kk-1) = ssb(0, 0, kk-1) + temp3b5 + temp4b
    END DO
    radjadjb(-1:1, -1:1, -1:1) = 0.0
    DO jj=0,-1,-1
      CALL POPREAL8(fact)
      fsb = fact*dwadjb(irhoe)
      temp3b0 = -(dis4*fsb)
      dis2b = ddw*fsb
      ddwb = dis2*fsb - three*temp3b0
      dis4b = -((wadj(0, jj+2, 0, irhoe)-wadj(0, jj-1, 0, irhoe)-three*&
&        ddw)*fsb)
      wadjb(0, jj+2, 0, irhoe) = wadjb(0, jj+2, 0, irhoe) + temp3b0
      wadjb(0, jj-1, 0, irhoe) = wadjb(0, jj-1, 0, irhoe) - temp3b0
      CALL POPREAL8(ddw)
      wadjb(0, jj+1, 0, irhoe) = wadjb(0, jj+1, 0, irhoe) + ddwb
      wadjb(0, jj, 0, irhoe) = wadjb(0, jj, 0, irhoe) - ddwb
      fsb = fact*dwadjb(imz)
      temp3b1 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp3b1
      dis4b = dis4b - (wadj(0, jj+2, 0, ivz)-wadj(0, jj-1, 0, ivz)-three&
&        *ddw)*fsb
      wadjb(0, jj+2, 0, ivz) = wadjb(0, jj+2, 0, ivz) + temp3b1
      wadjb(0, jj-1, 0, ivz) = wadjb(0, jj-1, 0, ivz) - temp3b1
      CALL POPREAL8(ddw)
      wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + ddwb
      wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) - ddwb
      fsb = fact*dwadjb(imy)
      temp3b2 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp3b2
      dis4b = dis4b - (wadj(0, jj+2, 0, ivy)-wadj(0, jj-1, 0, ivy)-three&
&        *ddw)*fsb
      wadjb(0, jj+2, 0, ivy) = wadjb(0, jj+2, 0, ivy) + temp3b2
      wadjb(0, jj-1, 0, ivy) = wadjb(0, jj-1, 0, ivy) - temp3b2
      CALL POPREAL8(ddw)
      wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + ddwb
      wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) - ddwb
      fsb = fact*dwadjb(imx)
      temp3b3 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp3b3
      dis4b = dis4b - (wadj(0, jj+2, 0, ivx)-wadj(0, jj-1, 0, ivx)-three&
&        *ddw)*fsb
      wadjb(0, jj+2, 0, ivx) = wadjb(0, jj+2, 0, ivx) + temp3b3
      wadjb(0, jj-1, 0, ivx) = wadjb(0, jj-1, 0, ivx) - temp3b3
      CALL POPREAL8(ddw)
      wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + ddwb
      wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) - ddwb
      fsb = fact*dwadjb(irho)
      temp3b4 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp3b4
      dis4b = dis4b - (wadj(0, jj+2, 0, irho)-wadj(0, jj-1, 0, irho)-&
&        three*ddw)*fsb
      wadjb(0, jj+2, 0, irho) = wadjb(0, jj+2, 0, irho) + temp3b4
      wadjb(0, jj-1, 0, irho) = wadjb(0, jj-1, 0, irho) - temp3b4
      CALL POPREAL8(ddw)
      wadjb(0, jj+1, 0, irho) = wadjb(0, jj+1, 0, irho) + ddwb
      wadjb(0, jj, 0, irho) = wadjb(0, jj, 0, irho) - ddwb
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPREAL8(dis4)
        rradb = 0.0
      ELSE
        CALL POPREAL8(dis4)
        rradb = fis4*dis4b
        dis2b = dis2b - dis4b
      END IF
      CALL POPREAL8(dis2)
      rradb = rradb + fis2*min2*dis2b
      min2b = fis2*rrad*dis2b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPREAL8(min2)
        y2b = min2b
      ELSE
        CALL POPREAL8(min2)
        y2b = 0.0
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        dss1b = y2b
        dss2b = 0.0
      ELSE
        dss2b = y2b
        dss1b = 0.0
      END IF
      CALL POPREAL8(rrad)
      radjadjb(0, jj, 0) = radjadjb(0, jj, 0) + ppor*rradb
      radjadjb(0, jj+1, 0) = radjadjb(0, jj+1, 0) + ppor*rradb
      CALL POPINTEGER4(branch)
      CALL POPREAL8(ppor)
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x4b = -dss2b
      ELSE
        x4b = dss2b
      END IF
      temp2 = sslim + ss(0, jj+2, 0) + two*ss(0, jj+1, 0) + ss(0, jj, 0)
      temp3b = x4b/temp2
      temp2b0 = -((ss(0, jj+2, 0)-two*ss(0, jj+1, 0)+ss(0, jj, 0))*&
&        temp3b/temp2)
      ssb(0, jj+2, 0) = ssb(0, jj+2, 0) + temp2b0 + temp3b
      ssb(0, jj+1, 0) = ssb(0, jj+1, 0) + two*temp2b0 - two*temp3b
      ssb(0, jj, 0) = ssb(0, jj, 0) + temp2b0 + temp3b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x3b = -dss1b
      ELSE
        x3b = dss1b
      END IF
      temp1 = sslim + ss(0, jj+1, 0) + two*ss(0, jj, 0) + ss(0, jj-1, 0)
      temp2b = x3b/temp1
      temp1b5 = -((ss(0, jj+1, 0)-two*ss(0, jj, 0)+ss(0, jj-1, 0))*&
&        temp2b/temp1)
      ssb(0, jj+1, 0) = ssb(0, jj+1, 0) + temp1b5 + temp2b
      ssb(0, jj, 0) = ssb(0, jj, 0) + two*temp1b5 - two*temp2b
      ssb(0, jj-1, 0) = ssb(0, jj-1, 0) + temp1b5 + temp2b
    END DO
    radiadjb(-1:1, -1:1, -1:1) = 0.0
    DO ii=0,-1,-1
      CALL POPREAL8(fact)
      fsb = fact*dwadjb(irhoe)
      temp1b0 = -(dis4*fsb)
      dis2b = ddw*fsb
      ddwb = dis2*fsb - three*temp1b0
      dis4b = -((wadj(ii+2, 0, 0, irhoe)-wadj(ii-1, 0, 0, irhoe)-three*&
&        ddw)*fsb)
      wadjb(ii+2, 0, 0, irhoe) = wadjb(ii+2, 0, 0, irhoe) + temp1b0
      wadjb(ii-1, 0, 0, irhoe) = wadjb(ii-1, 0, 0, irhoe) - temp1b0
      CALL POPREAL8(ddw)
      wadjb(ii+1, 0, 0, irhoe) = wadjb(ii+1, 0, 0, irhoe) + ddwb
      wadjb(ii, 0, 0, irhoe) = wadjb(ii, 0, 0, irhoe) - ddwb
      fsb = fact*dwadjb(imz)
      temp1b1 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp1b1
      dis4b = dis4b - (wadj(ii+2, 0, 0, ivz)-wadj(ii-1, 0, 0, ivz)-three&
&        *ddw)*fsb
      wadjb(ii+2, 0, 0, ivz) = wadjb(ii+2, 0, 0, ivz) + temp1b1
      wadjb(ii-1, 0, 0, ivz) = wadjb(ii-1, 0, 0, ivz) - temp1b1
      CALL POPREAL8(ddw)
      wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + ddwb
      wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) - ddwb
      fsb = fact*dwadjb(imy)
      temp1b2 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp1b2
      dis4b = dis4b - (wadj(ii+2, 0, 0, ivy)-wadj(ii-1, 0, 0, ivy)-three&
&        *ddw)*fsb
      wadjb(ii+2, 0, 0, ivy) = wadjb(ii+2, 0, 0, ivy) + temp1b2
      wadjb(ii-1, 0, 0, ivy) = wadjb(ii-1, 0, 0, ivy) - temp1b2
      CALL POPREAL8(ddw)
      wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + ddwb
      wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) - ddwb
      fsb = fact*dwadjb(imx)
      temp1b3 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp1b3
      dis4b = dis4b - (wadj(ii+2, 0, 0, ivx)-wadj(ii-1, 0, 0, ivx)-three&
&        *ddw)*fsb
      wadjb(ii+2, 0, 0, ivx) = wadjb(ii+2, 0, 0, ivx) + temp1b3
      wadjb(ii-1, 0, 0, ivx) = wadjb(ii-1, 0, 0, ivx) - temp1b3
      CALL POPREAL8(ddw)
      wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + ddwb
      wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) - ddwb
      fsb = fact*dwadjb(irho)
      temp1b4 = -(dis4*fsb)
      dis2b = dis2b + ddw*fsb
      ddwb = dis2*fsb - three*temp1b4
      dis4b = dis4b - (wadj(ii+2, 0, 0, irho)-wadj(ii-1, 0, 0, irho)-&
&        three*ddw)*fsb
      wadjb(ii+2, 0, 0, irho) = wadjb(ii+2, 0, 0, irho) + temp1b4
      wadjb(ii-1, 0, 0, irho) = wadjb(ii-1, 0, 0, irho) - temp1b4
      CALL POPREAL8(ddw)
      wadjb(ii+1, 0, 0, irho) = wadjb(ii+1, 0, 0, irho) + ddwb
      wadjb(ii, 0, 0, irho) = wadjb(ii, 0, 0, irho) - ddwb
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPREAL8(dis4)
        rradb = 0.0
      ELSE
        CALL POPREAL8(dis4)
        rradb = fis4*dis4b
        dis2b = dis2b - dis4b
      END IF
      CALL POPREAL8(dis2)
      rradb = rradb + fis2*min1*dis2b
      min1b = fis2*rrad*dis2b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        CALL POPREAL8(min1)
        y1b = min1b
      ELSE
        CALL POPREAL8(min1)
        y1b = 0.0
      END IF
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        dss1b = y1b
        dss2b = 0.0
      ELSE
        dss2b = y1b
        dss1b = 0.0
      END IF
      CALL POPREAL8(rrad)
      radiadjb(ii, 0, 0) = radiadjb(ii, 0, 0) + ppor*rradb
      radiadjb(ii+1, 0, 0) = radiadjb(ii+1, 0, 0) + ppor*rradb
      CALL POPINTEGER4(branch)
      CALL POPREAL8(ppor)
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x2b = -dss2b
      ELSE
        x2b = dss2b
      END IF
      temp0 = sslim + ss(ii+2, 0, 0) + two*ss(ii+1, 0, 0) + ss(ii, 0, 0)
      temp1b = x2b/temp0
      temp0b0 = -((ss(ii+2, 0, 0)-two*ss(ii+1, 0, 0)+ss(ii, 0, 0))*&
&        temp1b/temp0)
      ssb(ii+2, 0, 0) = ssb(ii+2, 0, 0) + temp0b0 + temp1b
      ssb(ii+1, 0, 0) = ssb(ii+1, 0, 0) + two*temp0b0 - two*temp1b
      ssb(ii, 0, 0) = ssb(ii, 0, 0) + temp0b0 + temp1b
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        x1b = -dss1b
      ELSE
        x1b = dss1b
      END IF
      temp = sslim + ss(ii+1, 0, 0) + two*ss(ii, 0, 0) + ss(ii-1, 0, 0)
      temp0b = x1b/temp
      tempb = -((ss(ii+1, 0, 0)-two*ss(ii, 0, 0)+ss(ii-1, 0, 0))*temp0b/&
&        temp)
      ssb(ii+1, 0, 0) = ssb(ii+1, 0, 0) + tempb + temp0b
      ssb(ii, 0, 0) = ssb(ii, 0, 0) + two*tempb - two*temp0b
      ssb(ii-1, 0, 0) = ssb(ii-1, 0, 0) + tempb + temp0b
    END DO
    padjb(-2:2, -2:2, -2:2) = 0.0
    DO k=2,-2,-1
      DO j=2,-2,-1
        DO i=2,-2,-1
          CALL POPREAL8(wadj(i, j, k, irhoe))
          padjb(i, j, k) = padjb(i, j, k) + wadjb(i, j, k, irhoe)
          CALL POPREAL8(wadj(i, j, k, ivz))
          tmp1b = wadjb(i, j, k, ivz)
          wadjb(i, j, k, ivz) = 0.0
          wadjb(i, j, k, irho) = wadjb(i, j, k, irho) + wadj(i, j, k, &
&            ivz)*tmp1b
          wadjb(i, j, k, ivz) = wadjb(i, j, k, ivz) + wadj(i, j, k, irho&
&            )*tmp1b
          CALL POPREAL8(wadj(i, j, k, ivy))
          tmp0b = wadjb(i, j, k, ivy)
          wadjb(i, j, k, ivy) = 0.0
          wadjb(i, j, k, irho) = wadjb(i, j, k, irho) + wadj(i, j, k, &
&            ivy)*tmp0b
          wadjb(i, j, k, ivy) = wadjb(i, j, k, ivy) + wadj(i, j, k, irho&
&            )*tmp0b
          CALL POPREAL8(wadj(i, j, k, ivx))
          tmpb = wadjb(i, j, k, ivx)
          wadjb(i, j, k, ivx) = 0.0
          wadjb(i, j, k, irho) = wadjb(i, j, k, irho) + wadj(i, j, k, &
&            ivx)*tmpb
          wadjb(i, j, k, ivx) = wadjb(i, j, k, ivx) + wadj(i, j, k, irho&
&            )*tmpb
        END DO
      END DO
    END DO
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      DO k=2,-2,-1
        DO j=2,-2,-1
          DO i=2,-2,-1
            padjb(i, j, k) = padjb(i, j, k) + ssb(i, j, k)
            ssb(i, j, k) = 0.0
          END DO
        END DO
      END DO
    END IF
  END IF
END SUBROUTINE INVISCIDDISSFLUXSCALARADJ_B
