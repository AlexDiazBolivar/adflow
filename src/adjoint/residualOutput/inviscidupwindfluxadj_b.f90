!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 2.2.4 (r2308) - 03/04/2008 10:03
!  
!  Differentiation of inviscidupwindfluxadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: gammaconstant padj
!                dwadj wadj skadj sjadj siadj
!   of linear combination of output variables: dwadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          inviscidUpwindFluxAdj.f90                       *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi,C.A.(Sandy)Mader                   *
!      * Starting date: 03-20-2006                                      *
!      * Last modified: 04-25-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INVISCIDUPWINDFLUXADJ_B(wadj, wadjb, padj, padjb, dwadj, &
&  dwadjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, icell, jcell, &
&  kcell, finegrid)
  USE blockpointers
  USE inputphysics
  USE inputdiscretization
  USE flowvarrefstate
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * inviscidUpwindFluxAdj computes the artificial dissipation part *
!      * the Euler fluxes by means of an approximate solution of the 1D *
!      * Riemann problem on the face. The fluxes are computed for the   *
!      * given cell of the block to which the variables in              *
!      * blockPointers currently point to.                              *
!      *                                                                *
!      ******************************************************************
!
! sI,sJ,sK
! limiter, firstOrder
!
!      Subroutine arguments.
!
  INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw) :: wadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw) :: wadjb
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2) :: padj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2) :: padjb
  REAL(KIND=REALTYPE), DIMENSION(nw) :: dwadj
  REAL(KIND=REALTYPE), DIMENSION(nw) :: dwadjb
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadj, sjadj, &
&  skadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadjb, sjadjb&
&  , skadjb
!
!      Local variables.
!
  INTEGER(KIND=PORTYPE) :: por
  INTEGER(KIND=INTTYPE) :: nwint
  INTEGER(KIND=INTTYPE) :: i, j, k, ii, jj, kk
  REAL(KIND=REALTYPE) :: sx, sy, sz, omk, opk, gammaface, gammaface2
  REAL(KIND=REALTYPE) :: sxb, syb, szb
  REAL(KIND=REALTYPE) :: factminmod, sface, fact
  REAL(KIND=REALTYPE), DIMENSION(nw) :: left, right
  REAL(KIND=REALTYPE), DIMENSION(nw) :: leftb, rightb
  REAL(KIND=REALTYPE), DIMENSION(nw) :: du1, du2, du3
  REAL(KIND=REALTYPE), DIMENSION(nw) :: du1b, du2b, du3b
  REAL(KIND=REALTYPE), DIMENSION(nwf) :: flux
  REAL(KIND=REALTYPE), DIMENSION(nwf) :: fluxb
  LOGICAL :: firstorderk, correctfork, finegrid
  INTEGER :: branch
  INTRINSIC MAX
  REAL(realType) :: max1
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
  correctfork = kpresent
  IF (1.e-10_realType .LT. one - kappacoef) THEN
    max1 = one - kappacoef
  ELSE
    max1 = 1.e-10_realType
  END IF
! Compute the factor used in the minmod limiter.
  factminmod = (three-kappacoef)/max1
! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
  omk = fourth*(one-kappacoef)
  opk = fourth*(one+kappacoef)
! Initialize sFace to zero. This value will be used if the
! block is not moving.
  sface = zero
! Set the number of variables to be interpolated depending
! whether or not a k-equation is present. If a k-equation is
! present also set the logical firstOrderK. This indicates
! whether or not only a first order approximation is to be used
! for the turbulent kinetic energy.
  IF (correctfork) THEN
    IF (orderturb .EQ. firstorder) THEN
      nwint = nwf
      firstorderk = .true.
    ELSE
      nwint = itu1
      firstorderk = .false.
    END IF
  ELSE
    nwint = nwf
    firstorderk = .false.
  END IF
!
!      ******************************************************************
!      *                                                                *
!      * Flux computation. A distinction is made between first and      *
!      * second order schemes to avoid the overhead for the first order *
!      * scheme.                                                        *
!      *                                                                *
!      ******************************************************************
!
  IF (limiter .EQ. firstorder) THEN
!
!        ****************************************************************
!        *                                                              *
!        * First order reconstruction. The states in the cells are      *
!        * constant. The left and right states are constructed easily.  *
!        *                                                              *
!        ****************************************************************
!
! Fluxes in the i-direction.
    i = icell - 1
    j = jcell
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO ii=-1,0
      CALL PUSHREAL8(sx)
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = siadj(ii, 0, 0, 1)
      CALL PUSHREAL8(sy)
      sy = siadj(ii, 0, 0, 2)
      CALL PUSHREAL8(sz)
      sz = siadj(ii, 0, 0, 3)
      CALL PUSHINTEGER4(por)
      por = pori(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacei(i, j, k)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(left(irho))
! Determine the left and right state.
      left(irho) = wadj(ii, 0, 0, irho)
      CALL PUSHREAL8(left(ivx))
      left(ivx) = wadj(ii, 0, 0, ivx)
      CALL PUSHREAL8(left(ivy))
      left(ivy) = wadj(ii, 0, 0, ivy)
      CALL PUSHREAL8(left(ivz))
      left(ivz) = wadj(ii, 0, 0, ivz)
      CALL PUSHREAL8(left(irhoe))
      left(irhoe) = padj(ii, 0, 0)
      IF (correctfork) THEN
        CALL PUSHREAL8(left(itu1))
        left(itu1) = wadj(ii, 0, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(right(irho))
      right(irho) = wadj(ii+1, 0, 0, irho)
      CALL PUSHREAL8(right(ivx))
      right(ivx) = wadj(ii+1, 0, 0, ivx)
      CALL PUSHREAL8(right(ivy))
      right(ivy) = wadj(ii+1, 0, 0, ivy)
      CALL PUSHREAL8(right(ivz))
      right(ivz) = wadj(ii+1, 0, 0, ivz)
      CALL PUSHREAL8(right(irhoe))
      right(irhoe) = padj(ii+1, 0, 0)
      IF (correctfork) THEN
        CALL PUSHREAL8(right(itu1))
        right(itu1) = wadj(ii+1, 0, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
!print *,'gammaface',gammaface,gammaface2
! Compute the dissipative flux across the interface
! and them to dwAdj.
!           call riemannFluxAdj(left,right,flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
! Update i and set fact to 1 for the second face.
      i = i + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in j-direction.
    i = icell
    j = jcell - 1
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO jj=-1,0
      CALL PUSHREAL8(sx)
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = sjadj(0, jj, 0, 1)
      CALL PUSHREAL8(sy)
      sy = sjadj(0, jj, 0, 2)
      CALL PUSHREAL8(sz)
      sz = sjadj(0, jj, 0, 3)
      CALL PUSHINTEGER4(por)
      por = porj(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacej(i, j, k)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(left(irho))
! Determine the left and right state.
      left(irho) = wadj(0, jj, 0, irho)
      CALL PUSHREAL8(left(ivx))
      left(ivx) = wadj(0, jj, 0, ivx)
      CALL PUSHREAL8(left(ivy))
      left(ivy) = wadj(0, jj, 0, ivy)
      CALL PUSHREAL8(left(ivz))
      left(ivz) = wadj(0, jj, 0, ivz)
      CALL PUSHREAL8(left(irhoe))
      left(irhoe) = padj(0, jj, 0)
      IF (correctfork) THEN
        CALL PUSHREAL8(left(itu1))
        left(itu1) = wadj(0, jj, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(right(irho))
      right(irho) = wadj(0, jj+1, 0, irho)
      CALL PUSHREAL8(right(ivx))
      right(ivx) = wadj(0, jj+1, 0, ivx)
      CALL PUSHREAL8(right(ivy))
      right(ivy) = wadj(0, jj+1, 0, ivy)
      CALL PUSHREAL8(right(ivz))
      right(ivz) = wadj(0, jj+1, 0, ivz)
      CALL PUSHREAL8(right(irhoe))
      right(irhoe) = padj(0, jj+1, 0)
      IF (correctfork) THEN
        CALL PUSHREAL8(right(itu1))
        right(itu1) = wadj(0, jj+1, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
! Compute the dissipative flux across the interface
! and them to dwAdj.
!           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
! Update j and set fact to 1 for the second face.
      j = j + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in k-direction.
    i = icell
    j = jcell
    k = kcell - 1
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO kk=-1,0
      CALL PUSHREAL8(sx)
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = skadj(0, 0, kk, 1)
      CALL PUSHREAL8(sy)
      sy = skadj(0, 0, kk, 2)
      CALL PUSHREAL8(sz)
      sz = skadj(0, 0, kk, 3)
      CALL PUSHINTEGER4(por)
      por = pork(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacek(i, j, k)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(left(irho))
! Determine the left and right state.
      left(irho) = wadj(0, 0, kk, irho)
      CALL PUSHREAL8(left(ivx))
      left(ivx) = wadj(0, 0, kk, ivx)
      CALL PUSHREAL8(left(ivy))
      left(ivy) = wadj(0, 0, kk, ivy)
      CALL PUSHREAL8(left(ivz))
      left(ivz) = wadj(0, 0, kk, ivz)
      CALL PUSHREAL8(left(irhoe))
      left(irhoe) = padj(0, 0, kk)
      IF (correctfork) THEN
        CALL PUSHREAL8(left(itu1))
        left(itu1) = wadj(0, 0, kk, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(right(irho))
      right(irho) = wadj(0, 0, kk+1, irho)
      CALL PUSHREAL8(right(ivx))
      right(ivx) = wadj(0, 0, kk+1, ivx)
      CALL PUSHREAL8(right(ivy))
      right(ivy) = wadj(0, 0, kk+1, ivy)
      CALL PUSHREAL8(right(ivz))
      right(ivz) = wadj(0, 0, kk+1, ivz)
      CALL PUSHREAL8(right(irhoe))
      right(irhoe) = padj(0, 0, kk+1)
      IF (correctfork) THEN
        CALL PUSHREAL8(right(itu1))
        right(itu1) = wadj(0, 0, kk+1, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
! Compute the dissipative flux across the interface
! and them to dwAdj.
!call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
! Update k and set fact to 1 for the second face.
      k = k + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
    padjb(-2:2, -2:2, -2:2) = 0.0
    wadjb(-2:2, -2:2, -2:2, :) = 0.0
    skadjb(-2:2, -2:2, -2:2, :) = 0.0
    fluxb(:) = 0.0
    leftb(:) = 0.0
    rightb(:) = 0.0
    DO kk=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(right(itu1))
        wadjb(0, 0, kk+1, itu1) = wadjb(0, 0, kk+1, itu1) + rightb(itu1)
        rightb(itu1) = 0.0
      END IF
      CALL POPREAL8(right(irhoe))
      padjb(0, 0, kk+1) = padjb(0, 0, kk+1) + rightb(irhoe)
      rightb(irhoe) = 0.0
      CALL POPREAL8(right(ivz))
      wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + rightb(ivz)
      rightb(ivz) = 0.0
      CALL POPREAL8(right(ivy))
      wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + rightb(ivy)
      rightb(ivy) = 0.0
      CALL POPREAL8(right(ivx))
      wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + rightb(ivx)
      rightb(ivx) = 0.0
      CALL POPREAL8(right(irho))
      wadjb(0, 0, kk+1, irho) = wadjb(0, 0, kk+1, irho) + rightb(irho)
      rightb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(left(itu1))
        wadjb(0, 0, kk, itu1) = wadjb(0, 0, kk, itu1) + leftb(itu1)
        leftb(itu1) = 0.0
      END IF
      CALL POPREAL8(left(irhoe))
      padjb(0, 0, kk) = padjb(0, 0, kk) + leftb(irhoe)
      leftb(irhoe) = 0.0
      CALL POPREAL8(left(ivz))
      wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) + leftb(ivz)
      leftb(ivz) = 0.0
      CALL POPREAL8(left(ivy))
      wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) + leftb(ivy)
      leftb(ivy) = 0.0
      CALL POPREAL8(left(ivx))
      wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) + leftb(ivx)
      leftb(ivx) = 0.0
      CALL POPREAL8(left(irho))
      wadjb(0, 0, kk, irho) = wadjb(0, 0, kk, irho) + leftb(irho)
      leftb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPREAL8(sface)
      CALL POPINTEGER4(por)
      CALL POPREAL8(sz)
      skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + szb
      CALL POPREAL8(sy)
      skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + syb
      CALL POPREAL8(sx)
      skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + sxb
    END DO
    sjadjb(-2:2, -2:2, -2:2, :) = 0.0
    DO jj=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(right(itu1))
        wadjb(0, jj+1, 0, itu1) = wadjb(0, jj+1, 0, itu1) + rightb(itu1)
        rightb(itu1) = 0.0
      END IF
      CALL POPREAL8(right(irhoe))
      padjb(0, jj+1, 0) = padjb(0, jj+1, 0) + rightb(irhoe)
      rightb(irhoe) = 0.0
      CALL POPREAL8(right(ivz))
      wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + rightb(ivz)
      rightb(ivz) = 0.0
      CALL POPREAL8(right(ivy))
      wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + rightb(ivy)
      rightb(ivy) = 0.0
      CALL POPREAL8(right(ivx))
      wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + rightb(ivx)
      rightb(ivx) = 0.0
      CALL POPREAL8(right(irho))
      wadjb(0, jj+1, 0, irho) = wadjb(0, jj+1, 0, irho) + rightb(irho)
      rightb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(left(itu1))
        wadjb(0, jj, 0, itu1) = wadjb(0, jj, 0, itu1) + leftb(itu1)
        leftb(itu1) = 0.0
      END IF
      CALL POPREAL8(left(irhoe))
      padjb(0, jj, 0) = padjb(0, jj, 0) + leftb(irhoe)
      leftb(irhoe) = 0.0
      CALL POPREAL8(left(ivz))
      wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) + leftb(ivz)
      leftb(ivz) = 0.0
      CALL POPREAL8(left(ivy))
      wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) + leftb(ivy)
      leftb(ivy) = 0.0
      CALL POPREAL8(left(ivx))
      wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) + leftb(ivx)
      leftb(ivx) = 0.0
      CALL POPREAL8(left(irho))
      wadjb(0, jj, 0, irho) = wadjb(0, jj, 0, irho) + leftb(irho)
      leftb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPREAL8(sface)
      CALL POPINTEGER4(por)
      CALL POPREAL8(sz)
      sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + szb
      CALL POPREAL8(sy)
      sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + syb
      CALL POPREAL8(sx)
      sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + sxb
    END DO
    siadjb(-2:2, -2:2, -2:2, :) = 0.0
    DO ii=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(right(itu1))
        wadjb(ii+1, 0, 0, itu1) = wadjb(ii+1, 0, 0, itu1) + rightb(itu1)
        rightb(itu1) = 0.0
      END IF
      CALL POPREAL8(right(irhoe))
      padjb(ii+1, 0, 0) = padjb(ii+1, 0, 0) + rightb(irhoe)
      rightb(irhoe) = 0.0
      CALL POPREAL8(right(ivz))
      wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + rightb(ivz)
      rightb(ivz) = 0.0
      CALL POPREAL8(right(ivy))
      wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + rightb(ivy)
      rightb(ivy) = 0.0
      CALL POPREAL8(right(ivx))
      wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + rightb(ivx)
      rightb(ivx) = 0.0
      CALL POPREAL8(right(irho))
      wadjb(ii+1, 0, 0, irho) = wadjb(ii+1, 0, 0, irho) + rightb(irho)
      rightb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(left(itu1))
        wadjb(ii, 0, 0, itu1) = wadjb(ii, 0, 0, itu1) + leftb(itu1)
        leftb(itu1) = 0.0
      END IF
      CALL POPREAL8(left(irhoe))
      padjb(ii, 0, 0) = padjb(ii, 0, 0) + leftb(irhoe)
      leftb(irhoe) = 0.0
      CALL POPREAL8(left(ivz))
      wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) + leftb(ivz)
      leftb(ivz) = 0.0
      CALL POPREAL8(left(ivy))
      wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) + leftb(ivy)
      leftb(ivy) = 0.0
      CALL POPREAL8(left(ivx))
      wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) + leftb(ivx)
      leftb(ivx) = 0.0
      CALL POPREAL8(left(irho))
      wadjb(ii, 0, 0, irho) = wadjb(ii, 0, 0, irho) + leftb(irho)
      leftb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPREAL8(sface)
      CALL POPINTEGER4(por)
      CALL POPREAL8(sz)
      siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + szb
      CALL POPREAL8(sy)
      siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + syb
      CALL POPREAL8(sx)
      siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + sxb
    END DO
  ELSE
!      ==================================================================
!PRINT *,'limiter',limiter
!      ==================================================================
!
!        ****************************************************************
!        *                                                              *
!        * Second order reconstruction of the left and right state.     *
!        * The three differences used in the, possibly nonlinear,       *
!        * interpolation are constructed here; the actual left and      *
!        * right states, or at least the differences from the first     *
!        * order interpolation, are computed in the subroutine          *
!        * leftRightState.                                              *
!        *                                                              *
!        ****************************************************************
!
! Fluxes in the i-direction.
    i = icell - 1
    j = jcell
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO ii=-1,0
      CALL PUSHREAL8(du1(irho))
! Store the three differences used in the interpolation
! in du1, du2, du3.
      du1(irho) = wadj(ii, 0, 0, irho) - wadj(ii-1, 0, 0, irho)
      CALL PUSHREAL8(du2(irho))
      du2(irho) = wadj(ii+1, 0, 0, irho) - wadj(ii, 0, 0, irho)
      CALL PUSHREAL8(du3(irho))
      du3(irho) = wadj(ii+2, 0, 0, irho) - wadj(ii+1, 0, 0, irho)
      CALL PUSHREAL8(du1(ivx))
      du1(ivx) = wadj(ii, 0, 0, ivx) - wadj(ii-1, 0, 0, ivx)
      CALL PUSHREAL8(du2(ivx))
      du2(ivx) = wadj(ii+1, 0, 0, ivx) - wadj(ii, 0, 0, ivx)
      CALL PUSHREAL8(du3(ivx))
      du3(ivx) = wadj(ii+2, 0, 0, ivx) - wadj(ii+1, 0, 0, ivx)
      CALL PUSHREAL8(du1(ivy))
      du1(ivy) = wadj(ii, 0, 0, ivy) - wadj(ii-1, 0, 0, ivy)
      CALL PUSHREAL8(du2(ivy))
      du2(ivy) = wadj(ii+1, 0, 0, ivy) - wadj(ii, 0, 0, ivy)
      CALL PUSHREAL8(du3(ivy))
      du3(ivy) = wadj(ii+2, 0, 0, ivy) - wadj(ii+1, 0, 0, ivy)
      CALL PUSHREAL8(du1(ivz))
      du1(ivz) = wadj(ii, 0, 0, ivz) - wadj(ii-1, 0, 0, ivz)
      CALL PUSHREAL8(du2(ivz))
      du2(ivz) = wadj(ii+1, 0, 0, ivz) - wadj(ii, 0, 0, ivz)
      CALL PUSHREAL8(du3(ivz))
      du3(ivz) = wadj(ii+2, 0, 0, ivz) - wadj(ii+1, 0, 0, ivz)
      CALL PUSHREAL8(du1(irhoe))
      du1(irhoe) = padj(ii, 0, 0) - padj(ii-1, 0, 0)
      CALL PUSHREAL8(du2(irhoe))
      du2(irhoe) = padj(ii+1, 0, 0) - padj(ii, 0, 0)
      CALL PUSHREAL8(du3(irhoe))
      du3(irhoe) = padj(ii+2, 0, 0) - padj(ii+1, 0, 0)
!!$           print *,'pAdj',p(i,  j,k) - p(i-1,j,k),pAdj(ii,  0,0) - pAdj(ii-1,0,0),p(i,  j,k),p(i-1,j,k),pAdj(ii,  0,0), pAdj(i
!i-1,0,0),p(i,  j,k) -pAdj(ii,  0,0),p(i,  j,k) - p(i-1,j,k)-(pAdj(ii,  0,0) - pAdj(ii-1,0,0))
      IF (correctfork) THEN
        CALL PUSHREAL8(du1(itu1))
        du1(itu1) = wadj(ii, 0, 0, itu1) - wadj(ii-1, 0, 0, itu1)
        CALL PUSHREAL8(du2(itu1))
        du2(itu1) = wadj(ii+1, 0, 0, itu1) - wadj(ii, 0, 0, itu1)
        CALL PUSHREAL8(du3(itu1))
        du3(itu1) = wadj(ii+2, 0, 0, itu1) - wadj(ii+1, 0, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8ARRAY(right, nw)
      CALL PUSHREAL8ARRAY(left, nw)
! Compute the differences from the first order scheme.
      CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
&                       , factminmod, firstorderk)
!print *,'leftrightadj',left,right,icell,jcell,kcell
! Add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
      left(irho) = left(irho) + wadj(ii, 0, 0, irho)
      left(ivx) = left(ivx) + wadj(ii, 0, 0, ivx)
      left(ivy) = left(ivy) + wadj(ii, 0, 0, ivy)
      left(ivz) = left(ivz) + wadj(ii, 0, 0, ivz)
      left(irhoe) = left(irhoe) + padj(ii, 0, 0)
      right(irho) = right(irho) + wadj(ii+1, 0, 0, irho)
      right(ivx) = right(ivx) + wadj(ii+1, 0, 0, ivx)
      right(ivy) = right(ivy) + wadj(ii+1, 0, 0, ivy)
      right(ivz) = right(ivz) + wadj(ii+1, 0, 0, ivz)
      right(irhoe) = right(irhoe) + padj(ii+1, 0, 0)
      IF (correctfork) THEN
        left(itu1) = left(itu1) + wadj(ii, 0, 0, itu1)
        right(itu1) = right(itu1) + wadj(ii+1, 0, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(sx)
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = siadj(ii, 0, 0, 1)
      CALL PUSHREAL8(sy)
      sy = siadj(ii, 0, 0, 2)
      CALL PUSHREAL8(sz)
      sz = siadj(ii, 0, 0, 3)
      CALL PUSHINTEGER4(por)
      por = pori(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacei(i, j, k)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
!print *,'gammaface',gammaface,gammaface2
! Compute the dissipative flux across the interface
! and them to dwAdj.
!print *,'leftrightadj',left,right
!           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
!print *,'fluxadj',flux,icell,jcell,kcell
! Update i and set fact to 1 for the second face.
      i = i + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in the j-direction.
    i = icell
    j = jcell - 1
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO jj=-1,0
      CALL PUSHREAL8(du1(irho))
! Store the three differences used in the interpolation
! in du1, du2, du3.
      du1(irho) = wadj(0, jj, 0, irho) - wadj(0, jj-1, 0, irho)
      CALL PUSHREAL8(du2(irho))
      du2(irho) = wadj(0, jj+1, 0, irho) - wadj(0, jj, 0, irho)
      CALL PUSHREAL8(du3(irho))
      du3(irho) = wadj(0, jj+2, 0, irho) - wadj(0, jj+1, 0, irho)
      CALL PUSHREAL8(du1(ivx))
      du1(ivx) = wadj(0, jj, 0, ivx) - wadj(0, jj-1, 0, ivx)
      CALL PUSHREAL8(du2(ivx))
      du2(ivx) = wadj(0, jj+1, 0, ivx) - wadj(0, jj, 0, ivx)
      CALL PUSHREAL8(du3(ivx))
      du3(ivx) = wadj(0, jj+2, 0, ivx) - wadj(0, jj+1, 0, ivx)
      CALL PUSHREAL8(du1(ivy))
      du1(ivy) = wadj(0, jj, 0, ivy) - wadj(0, jj-1, 0, ivy)
      CALL PUSHREAL8(du2(ivy))
      du2(ivy) = wadj(0, jj+1, 0, ivy) - wadj(0, jj, 0, ivy)
      CALL PUSHREAL8(du3(ivy))
      du3(ivy) = wadj(0, jj+2, 0, ivy) - wadj(0, jj+1, 0, ivy)
      CALL PUSHREAL8(du1(ivz))
      du1(ivz) = wadj(0, jj, 0, ivz) - wadj(0, jj-1, 0, ivz)
      CALL PUSHREAL8(du2(ivz))
      du2(ivz) = wadj(0, jj+1, 0, ivz) - wadj(0, jj, 0, ivz)
      CALL PUSHREAL8(du3(ivz))
      du3(ivz) = wadj(0, jj+2, 0, ivz) - wadj(0, jj+1, 0, ivz)
      CALL PUSHREAL8(du1(irhoe))
      du1(irhoe) = padj(0, jj, 0) - padj(0, jj-1, 0)
      CALL PUSHREAL8(du2(irhoe))
      du2(irhoe) = padj(0, jj+1, 0) - padj(0, jj, 0)
      CALL PUSHREAL8(du3(irhoe))
      du3(irhoe) = padj(0, jj+2, 0) - padj(0, jj+1, 0)
      IF (correctfork) THEN
        CALL PUSHREAL8(du1(itu1))
        du1(itu1) = wadj(0, jj, 0, itu1) - wadj(0, jj-1, 0, itu1)
        CALL PUSHREAL8(du2(itu1))
        du2(itu1) = wadj(0, jj+1, 0, itu1) - wadj(0, jj, 0, itu1)
        CALL PUSHREAL8(du3(itu1))
        du3(itu1) = wadj(0, jj+2, 0, itu1) - wadj(0, jj+1, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8ARRAY(right, nw)
      CALL PUSHREAL8ARRAY(left, nw)
! Compute the differences from the first order scheme.
      CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
&                       , factminmod, firstorderk)
! Add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
      left(irho) = left(irho) + wadj(0, jj, 0, irho)
      left(ivx) = left(ivx) + wadj(0, jj, 0, ivx)
      left(ivy) = left(ivy) + wadj(0, jj, 0, ivy)
      left(ivz) = left(ivz) + wadj(0, jj, 0, ivz)
      left(irhoe) = left(irhoe) + padj(0, jj, 0)
      right(irho) = right(irho) + wadj(0, jj+1, 0, irho)
      right(ivx) = right(ivx) + wadj(0, jj+1, 0, ivx)
      right(ivy) = right(ivy) + wadj(0, jj+1, 0, ivy)
      right(ivz) = right(ivz) + wadj(0, jj+1, 0, ivz)
      right(irhoe) = right(irhoe) + padj(0, jj+1, 0)
      IF (correctfork) THEN
        left(itu1) = left(itu1) + wadj(0, jj, 0, itu1)
        right(itu1) = right(itu1) + wadj(0, jj+1, 0, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(sx)
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = sjadj(0, jj, 0, 1)
      CALL PUSHREAL8(sy)
      sy = sjadj(0, jj, 0, 2)
      CALL PUSHREAL8(sz)
      sz = sjadj(0, jj, 0, 3)
      CALL PUSHINTEGER4(por)
      por = porj(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacej(i, j, k)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
! Compute the dissipative flux across the interface
! and them to dwAdj.
!call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
! Update j and set fact to 1 for the second face.
      j = j + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in the k-direction.
    i = icell
    j = jcell
    k = kcell - 1
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO kk=-1,0
      CALL PUSHREAL8(du1(irho))
! Store the three differences used in the interpolation
! in du1, du2, du3.
      du1(irho) = wadj(0, 0, kk, irho) - wadj(0, 0, kk-1, irho)
      CALL PUSHREAL8(du2(irho))
      du2(irho) = wadj(0, 0, kk+1, irho) - wadj(0, 0, kk, irho)
      CALL PUSHREAL8(du3(irho))
      du3(irho) = wadj(0, 0, kk+2, irho) - wadj(0, 0, kk+1, irho)
      CALL PUSHREAL8(du1(ivx))
      du1(ivx) = wadj(0, 0, kk, ivx) - wadj(0, 0, kk-1, ivx)
      CALL PUSHREAL8(du2(ivx))
      du2(ivx) = wadj(0, 0, kk+1, ivx) - wadj(0, 0, kk, ivx)
      CALL PUSHREAL8(du3(ivx))
      du3(ivx) = wadj(0, 0, kk+2, ivx) - wadj(0, 0, kk+1, ivx)
      CALL PUSHREAL8(du1(ivy))
      du1(ivy) = wadj(0, 0, kk, ivy) - wadj(0, 0, kk-1, ivy)
      CALL PUSHREAL8(du2(ivy))
      du2(ivy) = wadj(0, 0, kk+1, ivy) - wadj(0, 0, kk, ivy)
      CALL PUSHREAL8(du3(ivy))
      du3(ivy) = wadj(0, 0, kk+2, ivy) - wadj(0, 0, kk+1, ivy)
      CALL PUSHREAL8(du1(ivz))
      du1(ivz) = wadj(0, 0, kk, ivz) - wadj(0, 0, kk-1, ivz)
      CALL PUSHREAL8(du2(ivz))
      du2(ivz) = wadj(0, 0, kk+1, ivz) - wadj(0, 0, kk, ivz)
      CALL PUSHREAL8(du3(ivz))
      du3(ivz) = wadj(0, 0, kk+2, ivz) - wadj(0, 0, kk+1, ivz)
      CALL PUSHREAL8(du1(irhoe))
      du1(irhoe) = padj(0, 0, kk) - padj(0, 0, kk-1)
      CALL PUSHREAL8(du2(irhoe))
      du2(irhoe) = padj(0, 0, kk+1) - padj(0, 0, kk)
      CALL PUSHREAL8(du3(irhoe))
      du3(irhoe) = padj(0, 0, kk+2) - padj(0, 0, kk+1)
      IF (correctfork) THEN
        CALL PUSHREAL8(du1(itu1))
        du1(itu1) = wadj(0, 0, kk, itu1) - wadj(0, 0, kk-1, itu1)
        CALL PUSHREAL8(du2(itu1))
        du2(itu1) = wadj(0, 0, kk+1, itu1) - wadj(0, 0, kk, itu1)
        CALL PUSHREAL8(du3(itu1))
        du3(itu1) = wadj(0, 0, kk+2, itu1) - wadj(0, 0, kk+1, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8ARRAY(right, nw)
      CALL PUSHREAL8ARRAY(left, nw)
! Compute the differences from the first order scheme.
      CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
&                       , factminmod, firstorderk)
! Add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
      left(irho) = left(irho) + wadj(0, 0, kk, irho)
      left(ivx) = left(ivx) + wadj(0, 0, kk, ivx)
      left(ivy) = left(ivy) + wadj(0, 0, kk, ivy)
      left(ivz) = left(ivz) + wadj(0, 0, kk, ivz)
      left(irhoe) = left(irhoe) + padj(0, 0, kk)
      right(irho) = right(irho) + wadj(0, 0, kk+1, irho)
      right(ivx) = right(ivx) + wadj(0, 0, kk+1, ivx)
      right(ivy) = right(ivy) + wadj(0, 0, kk+1, ivy)
      right(ivz) = right(ivz) + wadj(0, 0, kk+1, ivz)
      right(irhoe) = right(irhoe) + padj(0, 0, kk+1)
      IF (correctfork) THEN
        left(itu1) = left(itu1) + wadj(0, 0, kk, itu1)
        right(itu1) = right(itu1) + wadj(0, 0, kk+1, itu1)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(sx)
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = skadj(0, 0, kk, 1)
      CALL PUSHREAL8(sy)
      sy = skadj(0, 0, kk, 2)
      CALL PUSHREAL8(sz)
      sz = skadj(0, 0, kk, 3)
      CALL PUSHINTEGER4(por)
      por = pork(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacek(i, j, k)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
! Compute the dissipative flux across the interface
! and them to dwAdj.
!           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
! Update k and set fact to 1 for the second face.
      k = k + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
    padjb(-2:2, -2:2, -2:2) = 0.0
    wadjb(-2:2, -2:2, -2:2, :) = 0.0
    skadjb(-2:2, -2:2, -2:2, :) = 0.0
    fluxb(:) = 0.0
    leftb(:) = 0.0
    rightb(:) = 0.0
    du1b(:) = 0.0
    du2b(:) = 0.0
    du3b(:) = 0.0
    DO kk=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPREAL8(sface)
      CALL POPINTEGER4(por)
      CALL POPREAL8(sz)
      skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + szb
      CALL POPREAL8(sy)
      skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + syb
      CALL POPREAL8(sx)
      skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + sxb
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        wadjb(0, 0, kk+1, itu1) = wadjb(0, 0, kk+1, itu1) + rightb(itu1)
        wadjb(0, 0, kk, itu1) = wadjb(0, 0, kk, itu1) + leftb(itu1)
      END IF
      padjb(0, 0, kk+1) = padjb(0, 0, kk+1) + rightb(irhoe)
      wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + rightb(ivz)
      wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + rightb(ivy)
      wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + rightb(ivx)
      wadjb(0, 0, kk+1, irho) = wadjb(0, 0, kk+1, irho) + rightb(irho)
      padjb(0, 0, kk) = padjb(0, 0, kk) + leftb(irhoe)
      wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) + leftb(ivz)
      wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) + leftb(ivy)
      wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) + leftb(ivx)
      wadjb(0, 0, kk, irho) = wadjb(0, 0, kk, irho) + leftb(irho)
      CALL POPREAL8ARRAY(left, nw)
      CALL POPREAL8ARRAY(right, nw)
      CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
&                         leftb, right, rightb, nwint, omk, opk, &
&                         factminmod, firstorderk)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(du3(itu1))
        wadjb(0, 0, kk+2, itu1) = wadjb(0, 0, kk+2, itu1) + du3b(itu1)
        wadjb(0, 0, kk+1, itu1) = wadjb(0, 0, kk+1, itu1) + du2b(itu1) -&
&         du3b(itu1)
        du3b(itu1) = 0.0
        CALL POPREAL8(du2(itu1))
        wadjb(0, 0, kk, itu1) = wadjb(0, 0, kk, itu1) + du1b(itu1) - &
&          du2b(itu1)
        du2b(itu1) = 0.0
        CALL POPREAL8(du1(itu1))
        wadjb(0, 0, kk-1, itu1) = wadjb(0, 0, kk-1, itu1) - du1b(itu1)
        du1b(itu1) = 0.0
      END IF
      CALL POPREAL8(du3(irhoe))
      padjb(0, 0, kk+2) = padjb(0, 0, kk+2) + du3b(irhoe)
      padjb(0, 0, kk+1) = padjb(0, 0, kk+1) + du2b(irhoe) - du3b(irhoe)
      du3b(irhoe) = 0.0
      CALL POPREAL8(du2(irhoe))
      padjb(0, 0, kk) = padjb(0, 0, kk) + du1b(irhoe) - du2b(irhoe)
      du2b(irhoe) = 0.0
      CALL POPREAL8(du1(irhoe))
      padjb(0, 0, kk-1) = padjb(0, 0, kk-1) - du1b(irhoe)
      du1b(irhoe) = 0.0
      CALL POPREAL8(du3(ivz))
      wadjb(0, 0, kk+2, ivz) = wadjb(0, 0, kk+2, ivz) + du3b(ivz)
      wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + du2b(ivz) - du3b&
&        (ivz)
      du3b(ivz) = 0.0
      CALL POPREAL8(du2(ivz))
      wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) + du1b(ivz) - du2b(ivz&
&        )
      du2b(ivz) = 0.0
      CALL POPREAL8(du1(ivz))
      wadjb(0, 0, kk-1, ivz) = wadjb(0, 0, kk-1, ivz) - du1b(ivz)
      du1b(ivz) = 0.0
      CALL POPREAL8(du3(ivy))
      wadjb(0, 0, kk+2, ivy) = wadjb(0, 0, kk+2, ivy) + du3b(ivy)
      wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + du2b(ivy) - du3b&
&        (ivy)
      du3b(ivy) = 0.0
      CALL POPREAL8(du2(ivy))
      wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) + du1b(ivy) - du2b(ivy&
&        )
      du2b(ivy) = 0.0
      CALL POPREAL8(du1(ivy))
      wadjb(0, 0, kk-1, ivy) = wadjb(0, 0, kk-1, ivy) - du1b(ivy)
      du1b(ivy) = 0.0
      CALL POPREAL8(du3(ivx))
      wadjb(0, 0, kk+2, ivx) = wadjb(0, 0, kk+2, ivx) + du3b(ivx)
      wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + du2b(ivx) - du3b&
&        (ivx)
      du3b(ivx) = 0.0
      CALL POPREAL8(du2(ivx))
      wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) + du1b(ivx) - du2b(ivx&
&        )
      du2b(ivx) = 0.0
      CALL POPREAL8(du1(ivx))
      wadjb(0, 0, kk-1, ivx) = wadjb(0, 0, kk-1, ivx) - du1b(ivx)
      du1b(ivx) = 0.0
      CALL POPREAL8(du3(irho))
      wadjb(0, 0, kk+2, irho) = wadjb(0, 0, kk+2, irho) + du3b(irho)
      wadjb(0, 0, kk+1, irho) = wadjb(0, 0, kk+1, irho) + du2b(irho) - &
&        du3b(irho)
      du3b(irho) = 0.0
      CALL POPREAL8(du2(irho))
      wadjb(0, 0, kk, irho) = wadjb(0, 0, kk, irho) + du1b(irho) - du2b(&
&        irho)
      du2b(irho) = 0.0
      CALL POPREAL8(du1(irho))
      wadjb(0, 0, kk-1, irho) = wadjb(0, 0, kk-1, irho) - du1b(irho)
      du1b(irho) = 0.0
    END DO
    sjadjb(-2:2, -2:2, -2:2, :) = 0.0
    DO jj=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPREAL8(sface)
      CALL POPINTEGER4(por)
      CALL POPREAL8(sz)
      sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + szb
      CALL POPREAL8(sy)
      sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + syb
      CALL POPREAL8(sx)
      sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + sxb
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        wadjb(0, jj+1, 0, itu1) = wadjb(0, jj+1, 0, itu1) + rightb(itu1)
        wadjb(0, jj, 0, itu1) = wadjb(0, jj, 0, itu1) + leftb(itu1)
      END IF
      padjb(0, jj+1, 0) = padjb(0, jj+1, 0) + rightb(irhoe)
      wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + rightb(ivz)
      wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + rightb(ivy)
      wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + rightb(ivx)
      wadjb(0, jj+1, 0, irho) = wadjb(0, jj+1, 0, irho) + rightb(irho)
      padjb(0, jj, 0) = padjb(0, jj, 0) + leftb(irhoe)
      wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) + leftb(ivz)
      wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) + leftb(ivy)
      wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) + leftb(ivx)
      wadjb(0, jj, 0, irho) = wadjb(0, jj, 0, irho) + leftb(irho)
      CALL POPREAL8ARRAY(left, nw)
      CALL POPREAL8ARRAY(right, nw)
      CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
&                         leftb, right, rightb, nwint, omk, opk, &
&                         factminmod, firstorderk)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(du3(itu1))
        wadjb(0, jj+2, 0, itu1) = wadjb(0, jj+2, 0, itu1) + du3b(itu1)
        wadjb(0, jj+1, 0, itu1) = wadjb(0, jj+1, 0, itu1) + du2b(itu1) -&
&         du3b(itu1)
        du3b(itu1) = 0.0
        CALL POPREAL8(du2(itu1))
        wadjb(0, jj, 0, itu1) = wadjb(0, jj, 0, itu1) + du1b(itu1) - &
&          du2b(itu1)
        du2b(itu1) = 0.0
        CALL POPREAL8(du1(itu1))
        wadjb(0, jj-1, 0, itu1) = wadjb(0, jj-1, 0, itu1) - du1b(itu1)
        du1b(itu1) = 0.0
      END IF
      CALL POPREAL8(du3(irhoe))
      padjb(0, jj+2, 0) = padjb(0, jj+2, 0) + du3b(irhoe)
      padjb(0, jj+1, 0) = padjb(0, jj+1, 0) + du2b(irhoe) - du3b(irhoe)
      du3b(irhoe) = 0.0
      CALL POPREAL8(du2(irhoe))
      padjb(0, jj, 0) = padjb(0, jj, 0) + du1b(irhoe) - du2b(irhoe)
      du2b(irhoe) = 0.0
      CALL POPREAL8(du1(irhoe))
      padjb(0, jj-1, 0) = padjb(0, jj-1, 0) - du1b(irhoe)
      du1b(irhoe) = 0.0
      CALL POPREAL8(du3(ivz))
      wadjb(0, jj+2, 0, ivz) = wadjb(0, jj+2, 0, ivz) + du3b(ivz)
      wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + du2b(ivz) - du3b&
&        (ivz)
      du3b(ivz) = 0.0
      CALL POPREAL8(du2(ivz))
      wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) + du1b(ivz) - du2b(ivz&
&        )
      du2b(ivz) = 0.0
      CALL POPREAL8(du1(ivz))
      wadjb(0, jj-1, 0, ivz) = wadjb(0, jj-1, 0, ivz) - du1b(ivz)
      du1b(ivz) = 0.0
      CALL POPREAL8(du3(ivy))
      wadjb(0, jj+2, 0, ivy) = wadjb(0, jj+2, 0, ivy) + du3b(ivy)
      wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + du2b(ivy) - du3b&
&        (ivy)
      du3b(ivy) = 0.0
      CALL POPREAL8(du2(ivy))
      wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) + du1b(ivy) - du2b(ivy&
&        )
      du2b(ivy) = 0.0
      CALL POPREAL8(du1(ivy))
      wadjb(0, jj-1, 0, ivy) = wadjb(0, jj-1, 0, ivy) - du1b(ivy)
      du1b(ivy) = 0.0
      CALL POPREAL8(du3(ivx))
      wadjb(0, jj+2, 0, ivx) = wadjb(0, jj+2, 0, ivx) + du3b(ivx)
      wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + du2b(ivx) - du3b&
&        (ivx)
      du3b(ivx) = 0.0
      CALL POPREAL8(du2(ivx))
      wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) + du1b(ivx) - du2b(ivx&
&        )
      du2b(ivx) = 0.0
      CALL POPREAL8(du1(ivx))
      wadjb(0, jj-1, 0, ivx) = wadjb(0, jj-1, 0, ivx) - du1b(ivx)
      du1b(ivx) = 0.0
      CALL POPREAL8(du3(irho))
      wadjb(0, jj+2, 0, irho) = wadjb(0, jj+2, 0, irho) + du3b(irho)
      wadjb(0, jj+1, 0, irho) = wadjb(0, jj+1, 0, irho) + du2b(irho) - &
&        du3b(irho)
      du3b(irho) = 0.0
      CALL POPREAL8(du2(irho))
      wadjb(0, jj, 0, irho) = wadjb(0, jj, 0, irho) + du1b(irho) - du2b(&
&        irho)
      du2b(irho) = 0.0
      CALL POPREAL8(du1(irho))
      wadjb(0, jj-1, 0, irho) = wadjb(0, jj-1, 0, irho) - du1b(irho)
      du1b(irho) = 0.0
    END DO
    siadjb(-2:2, -2:2, -2:2, :) = 0.0
    DO ii=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPREAL8(sface)
      CALL POPINTEGER4(por)
      CALL POPREAL8(sz)
      siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + szb
      CALL POPREAL8(sy)
      siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + syb
      CALL POPREAL8(sx)
      siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + sxb
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        wadjb(ii+1, 0, 0, itu1) = wadjb(ii+1, 0, 0, itu1) + rightb(itu1)
        wadjb(ii, 0, 0, itu1) = wadjb(ii, 0, 0, itu1) + leftb(itu1)
      END IF
      padjb(ii+1, 0, 0) = padjb(ii+1, 0, 0) + rightb(irhoe)
      wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + rightb(ivz)
      wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + rightb(ivy)
      wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + rightb(ivx)
      wadjb(ii+1, 0, 0, irho) = wadjb(ii+1, 0, 0, irho) + rightb(irho)
      padjb(ii, 0, 0) = padjb(ii, 0, 0) + leftb(irhoe)
      wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) + leftb(ivz)
      wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) + leftb(ivy)
      wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) + leftb(ivx)
      wadjb(ii, 0, 0, irho) = wadjb(ii, 0, 0, irho) + leftb(irho)
      CALL POPREAL8ARRAY(left, nw)
      CALL POPREAL8ARRAY(right, nw)
      CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
&                         leftb, right, rightb, nwint, omk, opk, &
&                         factminmod, firstorderk)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(du3(itu1))
        wadjb(ii+2, 0, 0, itu1) = wadjb(ii+2, 0, 0, itu1) + du3b(itu1)
        wadjb(ii+1, 0, 0, itu1) = wadjb(ii+1, 0, 0, itu1) + du2b(itu1) -&
&         du3b(itu1)
        du3b(itu1) = 0.0
        CALL POPREAL8(du2(itu1))
        wadjb(ii, 0, 0, itu1) = wadjb(ii, 0, 0, itu1) + du1b(itu1) - &
&          du2b(itu1)
        du2b(itu1) = 0.0
        CALL POPREAL8(du1(itu1))
        wadjb(ii-1, 0, 0, itu1) = wadjb(ii-1, 0, 0, itu1) - du1b(itu1)
        du1b(itu1) = 0.0
      END IF
      CALL POPREAL8(du3(irhoe))
      padjb(ii+2, 0, 0) = padjb(ii+2, 0, 0) + du3b(irhoe)
      padjb(ii+1, 0, 0) = padjb(ii+1, 0, 0) + du2b(irhoe) - du3b(irhoe)
      du3b(irhoe) = 0.0
      CALL POPREAL8(du2(irhoe))
      padjb(ii, 0, 0) = padjb(ii, 0, 0) + du1b(irhoe) - du2b(irhoe)
      du2b(irhoe) = 0.0
      CALL POPREAL8(du1(irhoe))
      padjb(ii-1, 0, 0) = padjb(ii-1, 0, 0) - du1b(irhoe)
      du1b(irhoe) = 0.0
      CALL POPREAL8(du3(ivz))
      wadjb(ii+2, 0, 0, ivz) = wadjb(ii+2, 0, 0, ivz) + du3b(ivz)
      wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + du2b(ivz) - du3b&
&        (ivz)
      du3b(ivz) = 0.0
      CALL POPREAL8(du2(ivz))
      wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) + du1b(ivz) - du2b(ivz&
&        )
      du2b(ivz) = 0.0
      CALL POPREAL8(du1(ivz))
      wadjb(ii-1, 0, 0, ivz) = wadjb(ii-1, 0, 0, ivz) - du1b(ivz)
      du1b(ivz) = 0.0
      CALL POPREAL8(du3(ivy))
      wadjb(ii+2, 0, 0, ivy) = wadjb(ii+2, 0, 0, ivy) + du3b(ivy)
      wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + du2b(ivy) - du3b&
&        (ivy)
      du3b(ivy) = 0.0
      CALL POPREAL8(du2(ivy))
      wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) + du1b(ivy) - du2b(ivy&
&        )
      du2b(ivy) = 0.0
      CALL POPREAL8(du1(ivy))
      wadjb(ii-1, 0, 0, ivy) = wadjb(ii-1, 0, 0, ivy) - du1b(ivy)
      du1b(ivy) = 0.0
      CALL POPREAL8(du3(ivx))
      wadjb(ii+2, 0, 0, ivx) = wadjb(ii+2, 0, 0, ivx) + du3b(ivx)
      wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + du2b(ivx) - du3b&
&        (ivx)
      du3b(ivx) = 0.0
      CALL POPREAL8(du2(ivx))
      wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) + du1b(ivx) - du2b(ivx&
&        )
      du2b(ivx) = 0.0
      CALL POPREAL8(du1(ivx))
      wadjb(ii-1, 0, 0, ivx) = wadjb(ii-1, 0, 0, ivx) - du1b(ivx)
      du1b(ivx) = 0.0
      CALL POPREAL8(du3(irho))
      wadjb(ii+2, 0, 0, irho) = wadjb(ii+2, 0, 0, irho) + du3b(irho)
      wadjb(ii+1, 0, 0, irho) = wadjb(ii+1, 0, 0, irho) + du2b(irho) - &
&        du3b(irho)
      du3b(irho) = 0.0
      CALL POPREAL8(du2(irho))
      wadjb(ii, 0, 0, irho) = wadjb(ii, 0, 0, irho) + du1b(irho) - du2b(&
&        irho)
      du2b(irho) = 0.0
      CALL POPREAL8(du1(irho))
      wadjb(ii-1, 0, 0, irho) = wadjb(ii-1, 0, 0, irho) - du1b(irho)
      du1b(irho) = 0.0
    END DO
  END IF
!  gammaconstantb = 0.0
END SUBROUTINE INVISCIDUPWINDFLUXADJ_B
