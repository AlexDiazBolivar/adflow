!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of residualadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: rotrateadj voladj
!                padj wadj sfacekadj skadj sfacejadj sjadj sfaceiadj
!                siadj kappacoef
!   of linear combination of output variables: dwadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          residual.f90                                    *
!      * Author:        C.A.(Sandy) Mader                               *
!      * Starting date: 04-21-2008                                      *
!      * Last modified: 04-28-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE RESIDUALADJ_B(wadj, wadjb, padj, padjb, siadj, siadjb, sjadj&
&  , sjadjb, skadj, skadjb, voladj, voladjb, normadj, sfaceiadj, &
&  sfaceiadjb, sfacejadj, sfacejadjb, sfacekadj, sfacekadjb, dwadj, &
&  dwadjb, icell, jcell, kcell, rotrateadj, rotrateadjb, correctfork)
  USE blockpointers
  USE cgnsgrid
  USE flowvarrefstate
  USE inputdiscretization
  USE inputiteration
  USE inputtimespectral
  USE iteration
  IMPLICIT NONE
!* real(iblank(iCell,jCell,kCell), realType)
  LOGICAL, INTENT(IN) :: correctfork
  REAL(KIND=REALTYPE) :: dwadj(nw), dwadjb(nw)
  INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
  REAL(KIND=REALTYPE) :: normadj(nbocos, -2:2, -2:2, 3)
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2)
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotrateadj
  REAL(KIND=REALTYPE) :: rotrateadjb(3)
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: &
&  sfaceiadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: &
&  sfacejadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: &
&  sfacekadj
  REAL(KIND=REALTYPE) :: sfaceiadjb(-2:2, -2:2, -2:2), sfacejadjb(-2:2, &
&  -2:2, -2:2), sfacekadjb(-2:2, -2:2, -2:2)
  REAL(KIND=REALTYPE) :: siadj(-3:2, -3:2, -3:2, 3), siadjb(-3:2, -3:2, &
&  -3:2, 3), sjadj(-3:2, -3:2, -3:2, 3), sjadjb(-3:2, -3:2, -3:2, 3), &
&  skadj(-3:2, -3:2, -3:2, 3), skadjb(-3:2, -3:2, -3:2, 3)
  REAL(KIND=REALTYPE) :: voladj(0:0, 0:0, 0:0), voladjb(0:0, 0:0, 0:0)
  REAL(KIND=REALTYPE) :: wadj(-2:2, -2:2, -2:2, nw), wadjb(-2:2, -2:2, -&
&  2:2, nw)
  INTEGER :: branch
  INTEGER(KIND=INTTYPE) :: discr, nn, sps
  REAL(KIND=REALTYPE) :: dwadj2(nw)
  LOGICAL :: finegrid
  REAL(KIND=REALTYPE) :: fwadj(nw)
  INTEGER(KIND=INTTYPE) :: i, j, k, l
! Initialize the local arrays to monitor the massflows to zero.
! Set the value of the discretization, depending on the grid level,
! and the logical fineGrid, which indicates whether or not this
! is the finest grid level of the current mg cycle.
  discr = spacediscrcoarse
  IF (currentlevel .EQ. 1) THEN
    discr = spacediscr
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  finegrid = .false.
  IF (currentlevel .EQ. groundlevel) THEN
    finegrid = .true.
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
!moved outside...
!!$
!!$       ! Loop over the number of spectral solutions and local
!!$       ! number of blocks.
!!$
!!$       spectralLoop: do sps=1,nTimeIntervalsSpectral
!!$         domainLoop: do nn=1,nDom
!!$
!!$           ! Set the pointers to this block and compute the central
!!$           ! inviscid flux.
!!$
!!$           call setPointers(nn, currentLevel, sps)
!********************
!print *,'before central',wAdj(:,:,:,irho)!
  CALL INVISCIDCENTRALFLUXADJ(wadj, padj, dwadj, siadj, sjadj, skadj, &
&                        voladj, sfaceiadj, sfacejadj, sfacekadj, &
&                        rotrateadj, icell, jcell, kcell)
!print *,'After inviscid upwind',dwAdj
!               call inviscidUpwindFluxAdj2(wAdj,  pAdj,  dwAdj2, &
!                                        iCell, jCell, kCell,finegrid)
!!$               call inviscidUpwindFluxAdj2(w(icell-2:icell+2,jcell-2:jcell+2,kcell-2:kcell+2,:), p(icell-2:icell+2,jcell-2:jce
!ll+2,kcell-2:kcell+2),  dwAdj2, &
!!$                                        iCell, jCell, kCell,finegrid)
!!$               
!!$               fw(:,:,:,:) = 0.0
!!$
!!$               call inviscidUpwindFlux(fineGrid)
!!$               do l=1,nwf
!!$                  do k=2,kl
!!$                     do j=2,jl
!!$                        do i=2,il
!!$                           dw(i,j,k,l) = (dw(i,j,k,l) + fw(i,j,k,l)) &
!!$                                * real(iblank(i,j,k), realType)
!!$                        enddo
!!$                     enddo
!!$                  enddo
!!$               enddo
!!$               do i = 1,nw
!!$                  !if (abs(dwAdj(i)-dwAdj2(i))>0.0) then
!!$                  if (abs(dwAdj(i)-fw(icell,jcell,kcell,i))>0.0) then
!!$                  !if (1.0>0.0) then
!!$                     print *,abs(dwAdj(i)-fw(icell,jcell,kcell,i)),'dwadjup',dwAdj(i),'up2',dwAdj2(i),i,icell,jcell,kcell,fw(i
!cell,jcell,kcell,i)
!!$                  endif
!!$               enddo
!print *,'after inviscid central',dwadj
! Compute the artificial dissipation fluxes.
! This depends on the parameter discr.
  SELECT CASE  (discr) 
  CASE (upwind) 
!!$             case (dissScalar) ! Standard scalar dissipation scheme.
!!$               if( fineGrid ) then
!!$                 call inviscidDissFluxScalarAdj()
!!$               else
!!$                  call terminate("residualAdj", &
!!$                        "ADjoint does not function on coarse grid level")
!!$                  !call inviscidDissFluxScalarCoarse
!!$               endif
!===========================================================
!!$             case (dissMatrix) ! Matrix dissipation scheme.
!!$
!!$               if( fineGrid ) then
!!$                 call inviscidDissFluxMatrixAdj()
!!$               else
!!$                 call terminate("residualAdj", &
!!$                        "ADjoint does not function on coarse grid level")
!!$                 !call inviscidDissFluxMatrixCoarse
!!$               endif
!===========================================================
!!$             case (dissCusp) ! Cusp dissipation scheme.
!!$
!!$               if( fineGrid ) then
!!$                 call inviscidDissFluxCuspAdj()
!!$               else
!!$                 call terminate("residualAdj", &
!!$                        "ADjoint does not function on coarse grid level")
!!$                 !call inviscidDissFluxCuspCoarse
!!$               endif
!===========================================================
! Dissipation via an upwind scheme.
!print *,'before upwind',wAdj(:,:,:,irho)!,  pAdj,  dwAdj, &
! siAdj, sjAdj, skAdj, &
! sFaceIAdj,sFaceJAdj,sFaceKAdj,&
! iCell, jCell, kCell,finegrid
    CALL INVISCIDUPWINDFLUXADJ(wadj, padj, dwadj, siadj, sjadj, skadj, &
&                         sfaceiadj, sfacejadj, sfacekadj, icell, jcell&
&                         , kcell, finegrid)
    CALL PUSHINTEGER4(1)
  CASE DEFAULT
    CALL PUSHINTEGER4(0)
  END SELECT
  l = 0
  CALL POPINTEGER4(branch)
  IF (branch .LT. 1) THEN
    padjb(-2:2, -2:2, -2:2) = 0.0
    wadjb(-2:2, -2:2, -2:2, 1:nw) = 0.0
    sfacekadjb(-2:2, -2:2, -2:2) = 0.0
    skadjb(-3:2, -3:2, -3:2, 1:3) = 0.0
    sfacejadjb(-2:2, -2:2, -2:2) = 0.0
    sjadjb(-3:2, -3:2, -3:2, 1:3) = 0.0
    sfaceiadjb(-2:2, -2:2, -2:2) = 0.0
    siadjb(-3:2, -3:2, -3:2, 1:3) = 0.0
  ELSE
    CALL INVISCIDUPWINDFLUXADJ_B(wadj, wadjb, padj, padjb, dwadj, dwadjb&
&                           , siadj, siadjb, sjadj, sjadjb, skadj, &
&                           skadjb, sfaceiadj, sfaceiadjb, sfacejadj, &
&                           sfacejadjb, sfacekadj, sfacekadjb, icell, &
&                           jcell, kcell, finegrid)
  END IF
  CALL INVISCIDCENTRALFLUXADJ_B(wadj, wadjb, padj, padjb, dwadj, dwadjb&
&                          , siadj, siadjb, sjadj, sjadjb, skadj, skadjb&
&                          , voladj, voladjb, sfaceiadj, sfaceiadjb, &
&                          sfacejadj, sfacejadjb, sfacekadj, sfacekadjb&
&                          , rotrateadj, rotrateadjb, icell, jcell, &
&                          kcell)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
 ! kappacoefb = 0.0
END SUBROUTINE RESIDUALADJ_B
