!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of computeradjoint in reverse (adjoint) mode:
!   gradient, with respect to input variables: rotrateadj machadj
!                alphaadj xadj dwadj wadj betaadj
!   of linear combination of output variables: dwadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          computeRAdj.f90                                 *
!      * Author:        C.A.(Sandy) Mader                               *
!      * Starting date: 02-01-2008                                      *
!      * Last modified: 04-23-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, dwadj, dwadjb, &
&  alphaadj, alphaadjb, betaadj, betaadjb, machadj, machadjb, &
&  machcoefadj, icell, jcell, kcell, nn, sps, correctfork, secondhalo, &
&  prefadj, rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, &
&  rotrateadj, rotrateadjb, rotcenteradj, murefadj, timerefadj, &
&  pinfcorradj, liftindex)
  USE blockpointers
  USE flowvarrefstate
  IMPLICIT NONE
!stop
  REAL(KIND=REALTYPE) :: alphaadj, alphaadjb, betaadj, betaadjb
  LOGICAL :: correctfork, secondhalo
  REAL(KIND=REALTYPE) :: dwadj(nw), dwadjb(nw)
  INTEGER(KIND=INTTYPE), INTENT(IN) :: icell
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jcell
  INTEGER(KIND=INTTYPE), INTENT(IN) :: kcell
  INTEGER(KIND=INTTYPE) :: liftindex
  REAL(KIND=REALTYPE) :: machadj, machadjb, machcoefadj, pinfcorradj
  REAL(KIND=REALTYPE) :: murefadj, timerefadj
  INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
  REAL(KIND=REALTYPE) :: pinfdimadj, rhoinfdimadj
  REAL(KIND=REALTYPE) :: pinfadj, rhoinfadj
  REAL(KIND=REALTYPE) :: prefadj, rhorefadj
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotcenteradj
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotrateadj
  REAL(KIND=REALTYPE) :: rotrateadjb(3)
  INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw), INTENT(IN) :: &
&  wadj
  REAL(KIND=REALTYPE) :: wadjb(-2:2, -2:2, -2:2, nw)
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3), INTENT(IN) :: &
&  xadj
  REAL(KIND=REALTYPE) :: xadjb(-3:2, -3:2, -3:2, 3)
  REAL(KIND=REALTYPE) :: dragdirectionadj(3)
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, kk
  INTEGER(KIND=INTTYPE) :: iend, istart, jend, jstart, kend, kstart
  REAL(KIND=REALTYPE) :: liftdirectionadj(3)
  REAL(KIND=REALTYPE) :: normadj(nbocos, -2:2, -2:2, 3), normadjb(nbocos&
&  , -2:2, -2:2, 3)
  REAL(KIND=REALTYPE) :: padj(-2:2, -2:2, -2:2), padjb(-2:2, -2:2, -2:2)
  REAL(KIND=REALTYPE) :: rfaceadj(nbocos, -2:2, -2:2), rfaceadjb(nbocos&
&  , -2:2, -2:2)
  REAL(KIND=REALTYPE) :: sadj(-2:2, -2:2, -2:2, 3), sadjb(-2:2, -2:2, -2&
&  :2, 3)
  REAL(KIND=REALTYPE) :: sfaceiadj(-2:2, -2:2, -2:2), sfaceiadjb(-2:2, -&
&  2:2, -2:2), sfacejadj(-2:2, -2:2, -2:2), sfacejadjb(-2:2, -2:2, -2:2)&
&  , sfacekadj(-2:2, -2:2, -2:2), sfacekadjb(-2:2, -2:2, -2:2)
  REAL(KIND=REALTYPE) :: siadj(-3:2, -3:2, -3:2, 3), siadjb(-3:2, -3:2, &
&  -3:2, 3), sjadj(-3:2, -3:2, -3:2, 3), sjadjb(-3:2, -3:2, -3:2, 3), &
&  skadj(-3:2, -3:2, -3:2, 3), skadjb(-3:2, -3:2, -3:2, 3)
  REAL(KIND=REALTYPE) :: pinfcorradjb, uinfadj, uinfadjb
  LOGICAL :: useoldcoor=.false.
  REAL(KIND=REALTYPE) :: veldirfreestreamadj(3), veldirfreestreamadjb(3)
  REAL(KIND=REALTYPE) :: voladj, voladjb
  REAL(KIND=REALTYPE) :: winfadj(nw), winfadjb(nw)
!      Set Use Modules
!      Set Passed in Variables
!      Set Local Variables
!variables for test loops
!  real(kind=realType), dimension(-2:2,-2:2,-2:2,3) :: siAdj, sjAdj, skAdj
! *************************************************************************
!      Begin Execution
! *************************************************************************
!print *,'in computeRadj',wadj(:,:,:,irho)!
!      call the initialization routines to calculate the effect of Mach and alpha
  CALL ADJUSTINFLOWANGLEADJ(alphaadj, betaadj, veldirfreestreamadj, &
&                      liftdirectionadj, dragdirectionadj, liftindex)
  CALL PUSHREAL8ARRAY(veldirfreestreamadj, 3)
  CALL CHECKINPUTPARAMADJ(veldirfreestreamadj, liftdirectionadj, &
&                    dragdirectionadj, machadj, machcoefadj)
  CALL PUSHREAL8(gammainf)
  CALL PUSHREAL8(rhorefadj)
  CALL PUSHREAL8(prefadj)
  CALL REFERENCESTATEADJ(machadj, machcoefadj, uinfadj, prefadj, &
&                   rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, &
&                   pinfadj, murefadj, timerefadj)
  CALL PUSHREAL8ARRAY(winfadj, nw)
!call referenceStateAdj(velDirFreestreamAdj,liftDirectionAdj,&
!     dragDirectionAdj, Machadj, MachCoefAdj,uInfAdj,prefAdj,&
!     rhorefAdj, pinfdimAdj, rhoinfdimAdj, rhoinfAdj, pinfAdj,&
!     murefAdj, timerefAdj)
!(velDirFreestreamAdj,liftDirectionAdj,&
!     dragDirectionAdj, Machadj, MachCoefAdj,uInfAdj)
  CALL SETFLOWINFINITYSTATEADJ(veldirfreestreamadj, liftdirectionadj, &
&                         dragdirectionadj, machadj, machcoefadj, &
&                         uinfadj, winfadj, prefadj, rhorefadj, &
&                         pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, &
&                         murefadj, timerefadj, pinfcorradj)
!      Call the metric routines to generate the areas, volumes and surface normals for the stencil.
  CALL METRICADJ(xadj, siadj, sjadj, skadj, voladj, normadj, icell, &
&           jcell, kcell)
!call the gridVelocities function to get the cell center ,face center and boundary mesh velocities.
!first two arguments needed for time spectral.just set to initial values for the current steady case...
!print *,'grid velocities'
  CALL GRIDVELOCITIESFINELEVELADJ(.false., zero, sps, xadj, siadj, sjadj&
&                            , skadj, rotcenteradj, rotrateadj, sadj, &
&                            sfaceiadj, sfacejadj, sfacekadj, icell, &
&                            jcell, kcell)
!print *,'normalVelocities'
  CALL NORMALVELOCITIESALLLEVELSADJ(sps, icell, jcell, kcell, sfaceiadj&
&                              , sfacejadj, sfacekadj, siadj, sjadj, &
&                              skadj, rfaceadj)
!needed for uSlip in Viscous Calculations
!call slipVelocitiesFineLevel(.false., t, mm)
!      Mimic the Residual calculation in the main code
!Compute the Pressure in the stencil based on the current 
!States
!print *,'Calling computepressure',wadj(:,:,:,irho)!
! replace with Compute Pressure Adjoint!
  CALL COMPUTEPRESSUREADJ(wadj, padj)
  CALL PUSHBOOLEAN(secondhalo)
  CALL PUSHREAL8ARRAY(padj, 5**3)
  CALL PUSHREAL8ARRAY(wadj, 5**3*nw)
! Apply all boundary conditions to stencil.
! In case of a full mg mode, and a segegated turbulent solver,
! first call the turbulent boundary conditions, such that the
! turbulent kinetic energy is properly initialized in the halo's.
!###! Ignore Viscous for now
!###!       if(turbSegregated .and. (.not. corrections)) &
!###!         call applyAllTurbBCAdj(secondHalo)
! Apply all boundary conditions of the mean flow.
! print *,'applying bcs'
!******************************************
  CALL APPLYALLBCADJ(winfadj, pinfcorradj, wadj, padj, sadj, siadj, &
&               sjadj, skadj, voladj, normadj, rfaceadj, icell, jcell, &
&               kcell, secondhalo)
!!#Shouldn't need this section for derivatives...
!!$       ! In case this routine is called in full mg mode call the mean
!!$       ! flow boundary conditions again such that the normal momentum
!!$       ! boundary condition is treated correctly.
!!$
!!$       if(.not. corrections) call applyAllBCAdj(wAdj, pAdj, &
!!$                              siAdj, sjAdj, skAdj, volAdj, normAdj, &
!!$                              iCell, jCell, kCell,secondHalo)
!Leave out State exchanges for now. If there are discrepancies 
!Later, this may be a source...
!!$       ! Exchange the solution. Either whalo1 or whalo2
!!$       ! must be called.
!!$
!!$       if( secondHalo ) then
!!$         call whalo2(currentLevel, 1_intType, nVarInt, .true., &
!!$                     .true., .true.)
!!$       else
!!$         call whalo1(currentLevel, 1_intType, nVarInt, .true., &
!!$                     .true., .true.)
!!$       endif
!Again this should not be required, so leave out for now...
! For full multigrid mode the bleeds must be determined, the
! boundary conditions must be applied one more time and the
! solution must be exchanged again.
!!$       if(.not. corrections) then
!!$         call BCDataMassBleedOutflowAdj(.true., .true.)
!!$         call applyAllBCAdj(secondHalo)
!!$
!!$       !Leave out State exchanges for now. If there are discrepancies 
!!$       !Later, this may be a source...
!!$!         if( secondHalo ) then
!!$!           call whalo2(currentLevel, 1_intType, nVarInt, .true., &
!!$!                       .true., .true.)
!!$!         else
!!!$           call whalo1(currentLevel, 1_intType, nVarInt, .true., &
!!!$                       .true., .true.)
!!!$         endif
!!$       endif
!!$
!!$
!!$
!!$       ! Reset the values of rkStage and currentLevel, such that
!!$       ! they correspond to a new iteration.
!!$
!!$       rkStage = 0
!!$       currentLevel = groundLevel
!!$
!!$       ! Compute the latest values of the skin friction velocity.
!!$       ! The currently stored values are of the previous iteration.
!!$
!!$       call computeUtauAdj
!!$
!!$       ! Apply an iteration to the turbulent transport equations in
!!$       ! case these must be solved segregatedly.
!!$
!!$       if( turbSegregated ) call turbSolveSegregatedAdj
!!$
!!$       ! Compute the time step.
!!$
!!$       call timeStepAdj(.false.)
!!$
!!$       ! Compute the residual of the new solution on the ground level.
!!$
!!$       if( turbCoupled ) then
!!$         call initresAdj(nt1MG, nMGVar)
!!$         call turbResidualAdj
!!$       endif
!!$
!print *,'calculating residuals'
!call initresAdj(1_intType, nwf,sps,dwAdj)
  CALL INITRESADJ(1, nwf, sps, dwadj)
  CALL RESIDUALADJ_B(wadj, wadjb, padj, padjb, siadj, siadjb, sjadj, &
&               sjadjb, skadj, skadjb, voladj, voladjb, normadj, &
&               sfaceiadj, sfaceiadjb, sfacejadj, sfacejadjb, sfacekadj&
&               , sfacekadjb, dwadj, dwadjb, icell, jcell, kcell, &
&               rotrateadj, rotrateadjb, correctfork)
  CALL POPREAL8ARRAY(wadj, 5**3*nw)
  CALL POPREAL8ARRAY(padj, 5**3)
  CALL POPBOOLEAN(secondhalo)
  CALL APPLYALLBCADJ_B(winfadj, winfadjb, pinfcorradj, pinfcorradjb, &
&                 wadj, wadjb, padj, padjb, sadj, sadjb, siadj, siadjb, &
&                 sjadj, sjadjb, skadj, skadjb, voladj, normadj, &
&                 normadjb, rfaceadj, rfaceadjb, icell, jcell, kcell, &
&                 secondhalo)
  CALL COMPUTEPRESSUREADJ_B(wadj, wadjb, padj, padjb)
  CALL NORMALVELOCITIESALLLEVELSADJ_B(sps, icell, jcell, kcell, &
&                                sfaceiadj, sfaceiadjb, sfacejadj, &
&                                sfacejadjb, sfacekadj, sfacekadjb, &
&                                siadj, siadjb, sjadj, sjadjb, skadj, &
&                                skadjb, rfaceadj, rfaceadjb)
  CALL GRIDVELOCITIESFINELEVELADJ_B(.false., zero, sps, xadj, xadjb, &
&                              siadj, siadjb, sjadj, sjadjb, skadj, &
&                              skadjb, rotcenteradj, rotrateadj, &
&                              rotrateadjb, sadj, sadjb, sfaceiadj, &
&                              sfaceiadjb, sfacejadj, sfacejadjb, &
&                              sfacekadj, sfacekadjb, icell, jcell, &
&                              kcell)
  CALL METRICADJ_B(xadj, xadjb, siadj, siadjb, sjadj, sjadjb, skadj, &
&             skadjb, voladj, voladjb, normadj, normadjb, icell, jcell, &
&             kcell)
  CALL POPREAL8ARRAY(winfadj, nw)
  CALL SETFLOWINFINITYSTATEADJ_B(veldirfreestreamadj, &
&                           veldirfreestreamadjb, liftdirectionadj, &
&                           dragdirectionadj, machadj, machcoefadj, &
&                           uinfadj, uinfadjb, winfadj, winfadjb, &
&                           prefadj, rhorefadj, pinfdimadj, rhoinfdimadj&
&                           , rhoinfadj, pinfadj, murefadj, timerefadj, &
&                           pinfcorradj, pinfcorradjb)
  CALL POPREAL8(prefadj)
  CALL POPREAL8(rhorefadj)
  CALL POPREAL8(gammainf)
  CALL REFERENCESTATEADJ_B(machadj, machadjb, machcoefadj, uinfadj, &
&                     uinfadjb, prefadj, rhorefadj, pinfdimadj, &
&                     rhoinfdimadj, rhoinfadj, pinfadj, murefadj, &
&                     timerefadj)
  CALL POPREAL8ARRAY(veldirfreestreamadj, 3)
  CALL CHECKINPUTPARAMADJ_B(veldirfreestreamadj, veldirfreestreamadjb, &
&                      liftdirectionadj, dragdirectionadj, machadj, &
&                      machcoefadj)
  CALL ADJUSTINFLOWANGLEADJ_B(alphaadj, alphaadjb, betaadj, betaadjb, &
&                        veldirfreestreamadj, veldirfreestreamadjb, &
&                        liftdirectionadj, dragdirectionadj, liftindex)
  dwadjb(1:nw) = 0.0
END SUBROUTINE COMPUTERADJOINT_B
