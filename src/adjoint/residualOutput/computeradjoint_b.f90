!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 2.2.4 (r2308) - 03/04/2008 10:03
!  
!  Differentiation of computeradjoint in reverse (adjoint) mode:
!   gradient, with respect to input variables: machadj alphaadj
!                xadj dwadj wadj betaadj
!   of linear combination of output variables: dwadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          computeRAdj.f90                                 *
!      * Author:        C.A.(Sandy) Mader                               *
!      * Starting date: 02-01-2008                                      *
!      * Last modified: 04-23-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, dwadj, dwadjb, &
&  alphaadj, alphaadjb, betaadj, betaadjb, machadj, machadjb, &
&  machcoefadj, icell, jcell, kcell, nn, sps, correctfork, secondhalo, &
&  prefadj, rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, &
&  murefadj, timerefadj, pinfcorradj, liftindex)
  USE blockpointers
  USE flowvarrefstate
  IMPLICIT NONE
!      Set Use Modules
!      Set Passed in Variables
  INTEGER(KIND=INTTYPE), INTENT(IN) :: icell, jcell, kcell, nn, sps
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw) :: wadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw) :: wadjb
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3) :: xadj
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3) :: xadjb
  REAL(KIND=REALTYPE), DIMENSION(nw) :: dwadj
  REAL(KIND=REALTYPE), DIMENSION(nw) :: dwadjb
  LOGICAL :: secondhalo, correctfork
!      Set Local Variables
!variables for test loops
  INTEGER(KIND=INTTYPE) :: i, j, k, ii, jj, kk, liftindex
  INTEGER(KIND=INTTYPE) :: istart, iend, jstart, jend, kstart, kend
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2) :: padj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2) :: padjb
  REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, 3) :: normadj
  REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, 3) :: normadjb
  REAL(KIND=REALTYPE) :: voladj
  REAL(KIND=REALTYPE) :: voladjb
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadj, sjadj, &
&  skadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadjb, sjadjb&
&  , skadjb
  REAL(KIND=REALTYPE), DIMENSION(3) :: veldirfreestreamadj
  REAL(KIND=REALTYPE), DIMENSION(3) :: veldirfreestreamadjb
  REAL(KIND=REALTYPE), DIMENSION(3) :: liftdirectionadj
  REAL(KIND=REALTYPE), DIMENSION(3) :: dragdirectionadj
  REAL(KIND=REALTYPE) :: machadj, machcoefadj, uinfadj, pinfcorradj
  REAL(KIND=REALTYPE) :: machadjb, uinfadjb, pinfcorradjb
  REAL(KIND=REALTYPE), DIMENSION(nw) :: winfadj
  REAL(KIND=REALTYPE), DIMENSION(nw) :: winfadjb
  REAL(KIND=REALTYPE) :: prefadj, rhorefadj
  REAL(KIND=REALTYPE) :: pinfdimadj, rhoinfdimadj
  REAL(KIND=REALTYPE) :: rhoinfadj, pinfadj
  REAL(KIND=REALTYPE) :: murefadj, timerefadj
  REAL(KIND=REALTYPE) :: alphaadj, betaadj
  REAL(KIND=REALTYPE) :: alphaadjb, betaadjb
! *************************************************************************
!      Begin Execution
! *************************************************************************
!      call the initialization routines to calculate the effect of Mach and alpha
  CALL ADJUSTINFLOWANGLEADJ(alphaadj, betaadj, veldirfreestreamadj, &
&                      liftdirectionadj, dragdirectionadj, liftindex)
  CALL PUSHREAL8ARRAY(veldirfreestreamadj, 3)
  CALL CHECKINPUTPARAMADJ(veldirfreestreamadj, liftdirectionadj, &
&                    dragdirectionadj, machadj, machcoefadj)
  CALL PUSHREAL8(rhorefadj)
  CALL PUSHREAL8(prefadj)
  CALL REFERENCESTATEADJ(machadj, machcoefadj, uinfadj, prefadj, &
&                   rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, &
&                   pinfadj, murefadj, timerefadj)
  CALL PUSHREAL8ARRAY(winfadj, nw)
!call referenceStateAdj(velDirFreestreamAdj,liftDirectionAdj,&
!     dragDirectionAdj, Machadj, MachCoefAdj,uInfAdj,prefAdj,&
!     rhorefAdj, pinfdimAdj, rhoinfdimAdj, rhoinfAdj, pinfAdj,&
!     murefAdj, timerefAdj)
!(velDirFreestreamAdj,liftDirectionAdj,&
!     dragDirectionAdj, Machadj, MachCoefAdj,uInfAdj)
  CALL SETFLOWINFINITYSTATEADJ(veldirfreestreamadj, liftdirectionadj, &
&                         dragdirectionadj, machadj, machcoefadj, &
&                         uinfadj, winfadj, prefadj, rhorefadj, &
&                         pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, &
&                         murefadj, timerefadj, pinfcorradj)
!      Call the metric routines to generate the areas, volumes and surface normals for the stencil.
  CALL METRICADJ(xadj, siadj, sjadj, skadj, voladj, normadj, icell, &
&           jcell, kcell)
!      Mimic the Residual calculation in the main code
!Compute the Pressure in the stencil based on the current 
!States
! replace with Compute Pressure Adjoint!
  CALL COMPUTEPRESSUREADJ(wadj, padj)
  CALL PUSHBOOLEAN(secondhalo)
  CALL PUSHREAL8ARRAY(padj, 5**3)
  CALL PUSHREAL8ARRAY(wadj, 5**3*nw)
! Apply all boundary conditions to stencil.
! In case of a full mg mode, and a segegated turbulent solver,
! first call the turbulent boundary conditions, such that the
! turbulent kinetic energy is properly initialized in the halo's.
!###! Ignore Viscous for now
!###!       if(turbSegregated .and. (.not. corrections)) &
!###!         call applyAllTurbBCAdj(secondHalo)
! Apply all boundary conditions of the mean flow.
!******************************************
  CALL APPLYALLBCADJ(winfadj, pinfcorradj, wadj, padj, siadj, sjadj, &
&               skadj, voladj, normadj, icell, jcell, kcell, secondhalo)
!!#Shouldn't need this section for derivatives...
!!$       ! In case this routine is called in full mg mode call the mean
!!$       ! flow boundary conditions again such that the normal momentum
!!$       ! boundary condition is treated correctly.
!!$
!!$       if(.not. corrections) call applyAllBCAdj(wAdj, pAdj, &
!!$                              siAdj, sjAdj, skAdj, volAdj, normAdj, &
!!$                              iCell, jCell, kCell,secondHalo)
!Leave out State exchanges for now. If there are discrepancies 
!Later, this may be a source...
!!$       ! Exchange the solution. Either whalo1 or whalo2
!!$       ! must be called.
!!$
!!$       if( secondHalo ) then
!!$         call whalo2(currentLevel, 1_intType, nVarInt, .true., &
!!$                     .true., .true.)
!!$       else
!!$         call whalo1(currentLevel, 1_intType, nVarInt, .true., &
!!$                     .true., .true.)
!!$       endif
!Again this shou;d not be required, so leave out for now...
! For full multigrid mode the bleeds must be determined, the
! boundary conditions must be applied one more time and the
! solution must be exchanged again.
!!$       if(.not. corrections) then
!!$         call BCDataMassBleedOutflowAdj(.true., .true.)
!!$         call applyAllBCAdj(secondHalo)
!!$
!!$       !Leave out State exchanges for now. If there are discrepancies 
!!$       !Later, this may be a source...
!!$!         if( secondHalo ) then
!!$!           call whalo2(currentLevel, 1_intType, nVarInt, .true., &
!!$!                       .true., .true.)
!!$!         else
!!!$           call whalo1(currentLevel, 1_intType, nVarInt, .true., &
!!!$                       .true., .true.)
!!!$         endif
!!$       endif
!!$
!!$
!!$
!!$       ! Reset the values of rkStage and currentLevel, such that
!!$       ! they correspond to a new iteration.
!!$
!!$       rkStage = 0
!!$       currentLevel = groundLevel
!!$
!!$       ! Compute the latest values of the skin friction velocity.
!!$       ! The currently stored values are of the previous iteration.
!!$
!!$       call computeUtauAdj
!!$
!!$       ! Apply an iteration to the turbulent transport equations in
!!$       ! case these must be solved segregatedly.
!!$
!!$       if( turbSegregated ) call turbSolveSegregatedAdj
!!$
!!$       ! Compute the time step.
!!$
!!$       call timeStepAdj(.false.)
!!$
!!$       ! Compute the residual of the new solution on the ground level.
!!$
!!$       if( turbCoupled ) then
!!$         call initresAdj(nt1MG, nMGVar)
!!$         call turbResidualAdj
!!$       endif
!!$
!call initresAdj(1_intType, nwf,sps,dwAdj)
  CALL RESIDUALADJ_B(wadj, wadjb, padj, padjb, siadj, siadjb, sjadj, &
&               sjadjb, skadj, skadjb, voladj, voladjb, normadj, dwadj, &
&               dwadjb, icell, jcell, kcell, correctfork)
  CALL INITRESADJ_B(1, nwf, sps, dwadj, dwadjb)
  CALL POPREAL8ARRAY(wadj, 5**3*nw)
  CALL POPREAL8ARRAY(padj, 5**3)
  CALL POPBOOLEAN(secondhalo)
  CALL APPLYALLBCADJ_B(winfadj, winfadjb, pinfcorradj, pinfcorradjb, &
&                 wadj, wadjb, padj, padjb, siadj, siadjb, sjadj, sjadjb&
&                 , skadj, skadjb, voladj, normadj, normadjb, icell, &
&                 jcell, kcell, secondhalo)
  CALL COMPUTEPRESSUREADJ_B(wadj, wadjb, padj, padjb)
  CALL METRICADJ_B(xadj, xadjb, siadj, siadjb, sjadj, sjadjb, skadj, &
&             skadjb, voladj, voladjb, normadj, normadjb, icell, jcell, &
&             kcell)
  CALL POPREAL8ARRAY(winfadj, nw)
  CALL SETFLOWINFINITYSTATEADJ_B(veldirfreestreamadj, &
&                           veldirfreestreamadjb, liftdirectionadj, &
&                           dragdirectionadj, machadj, machcoefadj, &
&                           uinfadj, uinfadjb, winfadj, winfadjb, &
&                           prefadj, rhorefadj, pinfdimadj, rhoinfdimadj&
&                           , rhoinfadj, pinfadj, murefadj, timerefadj, &
&                           pinfcorradj, pinfcorradjb)
  CALL POPREAL8(prefadj)
  CALL POPREAL8(rhorefadj)
  CALL REFERENCESTATEADJ_B(machadj, machadjb, machcoefadj, uinfadj, &
&                     uinfadjb, prefadj, rhorefadj, pinfdimadj, &
&                     rhoinfdimadj, rhoinfadj, pinfadj, murefadj, &
&                     timerefadj)
  CALL POPREAL8ARRAY(veldirfreestreamadj, 3)
  CALL CHECKINPUTPARAMADJ_B(veldirfreestreamadj, veldirfreestreamadjb, &
&                      liftdirectionadj, dragdirectionadj, machadj, &
&                      machcoefadj)
  CALL ADJUSTINFLOWANGLEADJ_B(alphaadj, alphaadjb, betaadj, betaadjb, &
&                        veldirfreestreamadj, veldirfreestreamadjb, &
&                        liftdirectionadj, dragdirectionadj, liftindex)
END SUBROUTINE COMPUTERADJOINT_B
