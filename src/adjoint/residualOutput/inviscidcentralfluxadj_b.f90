!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 2.2.4 (r2308) - 03/04/2008 10:03
!  
!  Differentiation of inviscidcentralfluxadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: voladj padj dwadj
!                wadj skadj sjadj siadj
!   of linear combination of output variables: padj dwadj wadj
!                skadj sjadj siadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          inviscidCentralFluxAdj.f90                      *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi                                    *
!      * Starting date: 11-21-2007                                      *
!      * Last modified: 12-17-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INVISCIDCENTRALFLUXADJ_B(wadj, wadjb, padj, padjb, dwadj, &
&  dwadjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, voladj, voladjb&
&  , icell, jcell, kcell)
  USE cgnsgrid
  USE blockpointers
  USE inputphysics
  USE flowvarrefstate
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * inviscidCentralFluxAdj computes the Euler fluxes using a       *
!      * central discretization for the cell iCell, jCell, kCell of the *
!      * block to which the variables in blockPointers currently point  *
!      * to.                                                            *
!      *                                                                *
!      ******************************************************************
!
! sFaceI,sFaceJ,sFaceK,sI,sJ,sK,blockismoving,addgridvelocities
! vol, nbkGlobal
! constants (irho, ivx, ivy, imx,..), timeRef
! equationMode, steady
!
!
!      Subroutine arguments
!
  INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw) :: wadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw) :: wadjb
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2) :: padj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2) :: padjb
  REAL(KIND=REALTYPE), DIMENSION(nw) :: dwadj
  REAL(KIND=REALTYPE), DIMENSION(nw) :: dwadjb
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadj, sjadj, &
&  skadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3) :: siadjb, sjadjb&
&  , skadjb
  REAL(KIND=REALTYPE), DIMENSION(0:0, 0:0, 0:0) :: voladj
  REAL(KIND=REALTYPE), DIMENSION(0:0, 0:0, 0:0) :: voladjb
!
!      Local variables.
!
  INTEGER(KIND=INTTYPE) :: i, j, k, ii, jj, kk
  REAL(KIND=REALTYPE) :: qsp, qsm, rqsp, rqsm, porvel, porflux
  REAL(KIND=REALTYPE) :: qspb, qsmb, rqspb, rqsmb
  REAL(KIND=REALTYPE) :: pa, fs, sface, vnp, vnm, fact
  REAL(KIND=REALTYPE) :: pab, fsb, vnpb, vnmb
  REAL(KIND=REALTYPE) :: wx, wy, wz, rvol
  REAL(KIND=REALTYPE) :: rvolb
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: tempb1
  REAL(KIND=REALTYPE) :: tempb0
  REAL(KIND=REALTYPE) :: tempb
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Initialize sFace to zero. This value will be used if the
! block is not moving.
  sface = 0.0
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the i-direction.                           *
!      *                                                                *
!      ******************************************************************
!
  i = icell - 1
  j = jcell
  k = kcell
  fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
  DO ii=-1,0
! Set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
    IF (addgridvelocities) sface = sfacei(i, j, k)
    CALL PUSHREAL8(vnp)
! Compute the normal velocities of the left and right state.
    vnp = wadj(ii+1, 0, 0, ivx)*siadj(ii, 0, 0, 1) + wadj(ii+1, 0, 0, &
&      ivy)*siadj(ii, 0, 0, 2) + wadj(ii+1, 0, 0, ivz)*siadj(ii, 0, 0, 3&
&      )
    CALL PUSHREAL8(vnm)
    vnm = wadj(ii, 0, 0, ivx)*siadj(ii, 0, 0, 1) + wadj(ii, 0, 0, ivy)*&
&      siadj(ii, 0, 0, 2) + wadj(ii, 0, 0, ivz)*siadj(ii, 0, 0, 3)
    CALL PUSHREAL8(porvel)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
    porvel = one
    CALL PUSHREAL8(porflux)
    porflux = half
    IF (pori(i, j, k) .EQ. noflux) porflux = 0.0
    IF (pori(i, j, k) .EQ. boundflux) THEN
      porvel = 0.0
      vnp = sface
      vnm = sface
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
! Incorporate porFlux in porVel.
    porvel = porvel*porflux
    CALL PUSHREAL8(qsp)
! Compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
    qsp = (vnp-sface)*porvel
    CALL PUSHREAL8(qsm)
    qsm = (vnm-sface)*porvel
    CALL PUSHREAL8(rqsp)
    rqsp = qsp*wadj(ii+1, 0, 0, irho)
    CALL PUSHREAL8(rqsm)
    rqsm = qsm*wadj(ii, 0, 0, irho)
    CALL PUSHREAL8(pa)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
    pa = porflux*(padj(ii+1, 0, 0)+padj(ii, 0, 0))
! Compute the fluxes through this face.
! Update i and set fact to 1 for the second face.
    i = i + 1
    CALL PUSHREAL8(fact)
    fact = one
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the j-direction.                           *
!      *                                                                *
!      ******************************************************************
!
  i = icell
  j = jcell - 1
  k = kcell
  fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
  DO jj=-1,0
! Set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
    IF (addgridvelocities) sface = sfacej(i, j, k)
    CALL PUSHREAL8(vnp)
! Compute the normal velocities of the left and right state.
    vnp = wadj(0, jj+1, 0, ivx)*sjadj(0, jj, 0, 1) + wadj(0, jj+1, 0, &
&      ivy)*sjadj(0, jj, 0, 2) + wadj(0, jj+1, 0, ivz)*sjadj(0, jj, 0, 3&
&      )
    CALL PUSHREAL8(vnm)
    vnm = wadj(0, jj, 0, ivx)*sjadj(0, jj, 0, 1) + wadj(0, jj, 0, ivy)*&
&      sjadj(0, jj, 0, 2) + wadj(0, jj, 0, ivz)*sjadj(0, jj, 0, 3)
    CALL PUSHREAL8(porvel)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
    porvel = one
    CALL PUSHREAL8(porflux)
    porflux = half
    IF (porj(i, j, k) .EQ. noflux) porflux = 0.0
    IF (porj(i, j, k) .EQ. boundflux) THEN
      porvel = 0.0
      vnp = sface
      vnm = sface
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
! Incorporate porFlux in porVel.
    porvel = porvel*porflux
    CALL PUSHREAL8(qsp)
! Compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
    qsp = (vnp-sface)*porvel
    CALL PUSHREAL8(qsm)
    qsm = (vnm-sface)*porvel
    CALL PUSHREAL8(rqsp)
    rqsp = qsp*wadj(0, jj+1, 0, irho)
    CALL PUSHREAL8(rqsm)
    rqsm = qsm*wadj(0, jj, 0, irho)
    CALL PUSHREAL8(pa)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
    pa = porflux*(padj(0, jj+1, 0)+padj(0, jj, 0))
! Compute the fluxes through this face.
! Update j and set fact to 1 for the second face.
    j = j + 1
    CALL PUSHREAL8(fact)
    fact = one
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the k-direction.                           *
!      *                                                                *
!      ******************************************************************
!
!       should this be inside, have k=kCell+kk?
  i = icell
  j = jcell
  k = kcell - 1
  fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
  DO kk=-1,0
! Set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
    IF (addgridvelocities) sface = sfacek(i, j, k)
    CALL PUSHREAL8(vnp)
! Compute the normal velocities of the left and right state.
    vnp = wadj(0, 0, kk+1, ivx)*skadj(0, 0, kk, 1) + wadj(0, 0, kk+1, &
&      ivy)*skadj(0, 0, kk, 2) + wadj(0, 0, kk+1, ivz)*skadj(0, 0, kk, 3&
&      )
    CALL PUSHREAL8(vnm)
    vnm = wadj(0, 0, kk, ivx)*skadj(0, 0, kk, 1) + wadj(0, 0, kk, ivy)*&
&      skadj(0, 0, kk, 2) + wadj(0, 0, kk, ivz)*skadj(0, 0, kk, 3)
    CALL PUSHREAL8(porvel)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
    porvel = one
    CALL PUSHREAL8(porflux)
    porflux = half
    IF (pork(i, j, k) .EQ. noflux) porflux = 0.0
    IF (pork(i, j, k) .EQ. boundflux) THEN
      porvel = 0.0
      vnp = sface
      vnm = sface
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
! Incorporate porFlux in porVel.
    porvel = porvel*porflux
    CALL PUSHREAL8(qsp)
! Compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
    qsp = (vnp-sface)*porvel
    CALL PUSHREAL8(qsm)
    qsm = (vnm-sface)*porvel
    CALL PUSHREAL8(rqsp)
    rqsp = qsp*wadj(0, 0, kk+1, irho)
    CALL PUSHREAL8(rqsm)
    rqsm = qsm*wadj(0, 0, kk, irho)
    CALL PUSHREAL8(pa)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
    pa = porflux*(padj(0, 0, kk+1)+padj(0, 0, kk))
! Compute the fluxes through this face.
! Update k and set fact to 1 for the second face.
    k = k + 1
    CALL PUSHREAL8(fact)
    fact = one
  END DO
! Add the rotational source terms for a moving block in a
! steady state computation. These source terms account for the
! centrifugal acceleration and the coriolis term. However, as
! the equations are solved in the inertial frame and not
! in the moving frame, the form is different than what you
! normally find in a text book.
  IF (blockismoving .AND. equationmode .EQ. steady) THEN
    wx = timeref*cgnsdoms(nbkglobal)%rotrate(1)
    wy = timeref*cgnsdoms(nbkglobal)%rotrate(2)
    wz = timeref*cgnsdoms(nbkglobal)%rotrate(3)
    rvol = wadj(0, 0, 0, irho)*voladj(0, 0, 0)
    rvolb = (wz*wadj(0, 0, 0, ivx)-wx*wadj(0, 0, 0, ivz))*dwadjb(imy) + &
&      (wy*wadj(0, 0, 0, ivz)-wz*wadj(0, 0, 0, ivy))*dwadjb(imx) + (wx*&
&      wadj(0, 0, 0, ivy)-wy*wadj(0, 0, 0, ivx))*dwadjb(imz)
    wadjb(0, 0, 0, ivy) = wadjb(0, 0, 0, ivy) + rvol*wx*dwadjb(imz)
    wadjb(0, 0, 0, ivx) = wadjb(0, 0, 0, ivx) + rvol*wz*dwadjb(imy) - &
&      rvol*wy*dwadjb(imz)
    wadjb(0, 0, 0, ivz) = wadjb(0, 0, 0, ivz) + rvol*wy*dwadjb(imx) - &
&      rvol*wx*dwadjb(imy)
    wadjb(0, 0, 0, ivy) = wadjb(0, 0, 0, ivy) - rvol*wz*dwadjb(imx)
    voladjb(:, :, :) = 0.0
    wadjb(0, 0, 0, irho) = wadjb(0, 0, 0, irho) + voladj(0, 0, 0)*rvolb
    voladjb(0, 0, 0) = wadj(0, 0, 0, irho)*rvolb
  ELSE
    voladjb(:, :, :) = 0.0
  END IF
  DO kk=0,-1,-1
    CALL POPREAL8(fact)
    fsb = fact*dwadjb(irhoe)
    tempb1 = porflux*fsb
    qspb = wadj(0, 0, kk+1, irhoe)*fsb
    wadjb(0, 0, kk+1, irhoe) = wadjb(0, 0, kk+1, irhoe) + qsp*fsb
    qsmb = wadj(0, 0, kk, irhoe)*fsb
    wadjb(0, 0, kk, irhoe) = wadjb(0, 0, kk, irhoe) + qsm*fsb
    fsb = fact*dwadjb(imz)
    rqspb = wadj(0, 0, kk+1, ivz)*fsb
    wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + rqsp*fsb
    rqsmb = wadj(0, 0, kk, ivz)*fsb
    wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) + rqsm*fsb
    pab = skadj(0, 0, kk, 3)*fsb
    skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + pa*fsb
    fsb = fact*dwadjb(imy)
    rqspb = rqspb + wadj(0, 0, kk+1, ivy)*fsb
    wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, 0, kk, ivy)*fsb
    wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) + rqsm*fsb
    pab = pab + skadj(0, 0, kk, 2)*fsb
    skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + pa*fsb
    fsb = fact*dwadjb(imx)
    rqspb = rqspb + wadj(0, 0, kk+1, ivx)*fsb
    wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, 0, kk, ivx)*fsb
    wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) + rqsm*fsb
    pab = pab + skadj(0, 0, kk, 1)*fsb
    skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + pa*fsb
    fsb = fact*dwadjb(irho)
    rqspb = rqspb + fsb
    qspb = qspb + wadj(0, 0, kk+1, irho)*rqspb
    vnpb = porvel*qspb + padj(0, 0, kk+1)*tempb1
    padjb(0, 0, kk+1) = padjb(0, 0, kk+1) + vnp*tempb1
    rqsmb = rqsmb + fsb
    qsmb = qsmb + wadj(0, 0, kk, irho)*rqsmb
    vnmb = porvel*qsmb + padj(0, 0, kk)*tempb1
    padjb(0, 0, kk) = padjb(0, 0, kk) + vnm*tempb1
    CALL POPREAL8(pa)
    padjb(0, 0, kk+1) = padjb(0, 0, kk+1) + porflux*pab
    padjb(0, 0, kk) = padjb(0, 0, kk) + porflux*pab
    CALL POPREAL8(rqsm)
    wadjb(0, 0, kk, irho) = wadjb(0, 0, kk, irho) + qsm*rqsmb
    CALL POPREAL8(rqsp)
    wadjb(0, 0, kk+1, irho) = wadjb(0, 0, kk+1, irho) + qsp*rqspb
    CALL POPREAL8(qsm)
    CALL POPREAL8(qsp)
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      vnmb = 0.0
      vnpb = 0.0
    END IF
    CALL POPREAL8(porflux)
    CALL POPREAL8(porvel)
    CALL POPREAL8(vnm)
    wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) + skadj(0, 0, kk, 1)*&
&      vnmb
    skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + wadj(0, 0, kk, ivx)*vnmb
    wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) + skadj(0, 0, kk, 2)*&
&      vnmb
    skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + wadj(0, 0, kk, ivy)*vnmb
    wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) + skadj(0, 0, kk, 3)*&
&      vnmb
    skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + wadj(0, 0, kk, ivz)*vnmb
    CALL POPREAL8(vnp)
    wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + skadj(0, 0, kk, 1)&
&      *vnpb
    skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + wadj(0, 0, kk+1, ivx)*&
&      vnpb
    wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + skadj(0, 0, kk, 2)&
&      *vnpb
    skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + wadj(0, 0, kk+1, ivy)*&
&      vnpb
    wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + skadj(0, 0, kk, 3)&
&      *vnpb
    skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + wadj(0, 0, kk+1, ivz)*&
&      vnpb
  END DO
  DO jj=0,-1,-1
    CALL POPREAL8(fact)
    fsb = fact*dwadjb(irhoe)
    tempb0 = porflux*fsb
    qspb = wadj(0, jj+1, 0, irhoe)*fsb
    wadjb(0, jj+1, 0, irhoe) = wadjb(0, jj+1, 0, irhoe) + qsp*fsb
    qsmb = wadj(0, jj, 0, irhoe)*fsb
    wadjb(0, jj, 0, irhoe) = wadjb(0, jj, 0, irhoe) + qsm*fsb
    fsb = fact*dwadjb(imz)
    rqspb = wadj(0, jj+1, 0, ivz)*fsb
    wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + rqsp*fsb
    rqsmb = wadj(0, jj, 0, ivz)*fsb
    wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) + rqsm*fsb
    pab = sjadj(0, jj, 0, 3)*fsb
    sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + pa*fsb
    fsb = fact*dwadjb(imy)
    rqspb = rqspb + wadj(0, jj+1, 0, ivy)*fsb
    wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, jj, 0, ivy)*fsb
    wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) + rqsm*fsb
    pab = pab + sjadj(0, jj, 0, 2)*fsb
    sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + pa*fsb
    fsb = fact*dwadjb(imx)
    rqspb = rqspb + wadj(0, jj+1, 0, ivx)*fsb
    wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, jj, 0, ivx)*fsb
    wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) + rqsm*fsb
    pab = pab + sjadj(0, jj, 0, 1)*fsb
    sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + pa*fsb
    fsb = fact*dwadjb(irho)
    rqspb = rqspb + fsb
    qspb = qspb + wadj(0, jj+1, 0, irho)*rqspb
    vnpb = porvel*qspb + padj(0, jj+1, 0)*tempb0
    padjb(0, jj+1, 0) = padjb(0, jj+1, 0) + vnp*tempb0
    rqsmb = rqsmb + fsb
    qsmb = qsmb + wadj(0, jj, 0, irho)*rqsmb
    vnmb = porvel*qsmb + padj(0, jj, 0)*tempb0
    padjb(0, jj, 0) = padjb(0, jj, 0) + vnm*tempb0
    CALL POPREAL8(pa)
    padjb(0, jj+1, 0) = padjb(0, jj+1, 0) + porflux*pab
    padjb(0, jj, 0) = padjb(0, jj, 0) + porflux*pab
    CALL POPREAL8(rqsm)
    wadjb(0, jj, 0, irho) = wadjb(0, jj, 0, irho) + qsm*rqsmb
    CALL POPREAL8(rqsp)
    wadjb(0, jj+1, 0, irho) = wadjb(0, jj+1, 0, irho) + qsp*rqspb
    CALL POPREAL8(qsm)
    CALL POPREAL8(qsp)
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      vnmb = 0.0
      vnpb = 0.0
    END IF
    CALL POPREAL8(porflux)
    CALL POPREAL8(porvel)
    CALL POPREAL8(vnm)
    wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) + sjadj(0, jj, 0, 1)*&
&      vnmb
    sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + wadj(0, jj, 0, ivx)*vnmb
    wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) + sjadj(0, jj, 0, 2)*&
&      vnmb
    sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + wadj(0, jj, 0, ivy)*vnmb
    wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) + sjadj(0, jj, 0, 3)*&
&      vnmb
    sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + wadj(0, jj, 0, ivz)*vnmb
    CALL POPREAL8(vnp)
    wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + sjadj(0, jj, 0, 1)&
&      *vnpb
    sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + wadj(0, jj+1, 0, ivx)*&
&      vnpb
    wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + sjadj(0, jj, 0, 2)&
&      *vnpb
    sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + wadj(0, jj+1, 0, ivy)*&
&      vnpb
    wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + sjadj(0, jj, 0, 3)&
&      *vnpb
    sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + wadj(0, jj+1, 0, ivz)*&
&      vnpb
  END DO
  DO ii=0,-1,-1
    CALL POPREAL8(fact)
    fsb = fact*dwadjb(irhoe)
    tempb = porflux*fsb
    qspb = wadj(ii+1, 0, 0, irhoe)*fsb
    wadjb(ii+1, 0, 0, irhoe) = wadjb(ii+1, 0, 0, irhoe) + qsp*fsb
    qsmb = wadj(ii, 0, 0, irhoe)*fsb
    wadjb(ii, 0, 0, irhoe) = wadjb(ii, 0, 0, irhoe) + qsm*fsb
    fsb = fact*dwadjb(imz)
    rqspb = wadj(ii+1, 0, 0, ivz)*fsb
    wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + rqsp*fsb
    rqsmb = wadj(ii, 0, 0, ivz)*fsb
    wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) + rqsm*fsb
    pab = siadj(ii, 0, 0, 3)*fsb
    siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + pa*fsb
    fsb = fact*dwadjb(imy)
    rqspb = rqspb + wadj(ii+1, 0, 0, ivy)*fsb
    wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + rqsp*fsb
    rqsmb = rqsmb + wadj(ii, 0, 0, ivy)*fsb
    wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) + rqsm*fsb
    pab = pab + siadj(ii, 0, 0, 2)*fsb
    siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + pa*fsb
    fsb = fact*dwadjb(imx)
    rqspb = rqspb + wadj(ii+1, 0, 0, ivx)*fsb
    wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + rqsp*fsb
    rqsmb = rqsmb + wadj(ii, 0, 0, ivx)*fsb
    wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) + rqsm*fsb
    pab = pab + siadj(ii, 0, 0, 1)*fsb
    siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + pa*fsb
    fsb = fact*dwadjb(irho)
    rqspb = rqspb + fsb
    qspb = qspb + wadj(ii+1, 0, 0, irho)*rqspb
    vnpb = porvel*qspb + padj(ii+1, 0, 0)*tempb
    padjb(ii+1, 0, 0) = padjb(ii+1, 0, 0) + vnp*tempb
    rqsmb = rqsmb + fsb
    qsmb = qsmb + wadj(ii, 0, 0, irho)*rqsmb
    vnmb = porvel*qsmb + padj(ii, 0, 0)*tempb
    padjb(ii, 0, 0) = padjb(ii, 0, 0) + vnm*tempb
    CALL POPREAL8(pa)
    padjb(ii+1, 0, 0) = padjb(ii+1, 0, 0) + porflux*pab
    padjb(ii, 0, 0) = padjb(ii, 0, 0) + porflux*pab
    CALL POPREAL8(rqsm)
    wadjb(ii, 0, 0, irho) = wadjb(ii, 0, 0, irho) + qsm*rqsmb
    CALL POPREAL8(rqsp)
    wadjb(ii+1, 0, 0, irho) = wadjb(ii+1, 0, 0, irho) + qsp*rqspb
    CALL POPREAL8(qsm)
    CALL POPREAL8(qsp)
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      vnmb = 0.0
      vnpb = 0.0
    END IF
    CALL POPREAL8(porflux)
    CALL POPREAL8(porvel)
    CALL POPREAL8(vnm)
    wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) + siadj(ii, 0, 0, 1)*&
&      vnmb
    siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + wadj(ii, 0, 0, ivx)*vnmb
    wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) + siadj(ii, 0, 0, 2)*&
&      vnmb
    siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + wadj(ii, 0, 0, ivy)*vnmb
    wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) + siadj(ii, 0, 0, 3)*&
&      vnmb
    siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + wadj(ii, 0, 0, ivz)*vnmb
    CALL POPREAL8(vnp)
    wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + siadj(ii, 0, 0, 1)&
&      *vnpb
    siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + wadj(ii+1, 0, 0, ivx)*&
&      vnpb
    wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + siadj(ii, 0, 0, 2)&
&      *vnpb
    siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + wadj(ii+1, 0, 0, ivy)*&
&      vnpb
    wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + siadj(ii, 0, 0, 3)&
&      *vnpb
    siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + wadj(ii+1, 0, 0, ivz)*&
&      vnpb
  END DO
END SUBROUTINE INVISCIDCENTRALFLUXADJ_B
