!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of inviscidcentralfluxadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: rotrateadj voladj
!                padj wadj sfacekadj skadj sfacejadj sjadj sfaceiadj
!                siadj
!   of linear combination of output variables: padj dwadj wadj
!                sfacekadj skadj sfacejadj sjadj sfaceiadj siadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          inviscidCentralFluxAdj.f90                      *
!      * Author:        Edwin van der Weide, C.A.(Sandy) Mader          *
!      *                Seongim Choi                                    *
!      * Starting date: 11-21-2007                                      *
!      * Last modified: 10-22-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INVISCIDCENTRALFLUXADJ_B(wadj, wadjb, padj, padjb, dwadj, &
&  dwadjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, voladj, voladjb&
&  , sfaceiadj, sfaceiadjb, sfacejadj, sfacejadjb, sfacekadj, sfacekadjb&
&  , rotrateadj, rotrateadjb, icell, jcell, kcell)
  USE blockpointers
  USE cgnsgrid
  USE flowvarrefstate
  USE inputphysics
  IMPLICIT NONE
  REAL(KIND=REALTYPE) :: dwadj(nw), dwadjb(nw)
  INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2)
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotrateadj
  REAL(KIND=REALTYPE) :: rotrateadjb(3)
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: &
&  sfaceiadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: &
&  sfacejadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2), INTENT(IN) :: &
&  sfacekadj
  REAL(KIND=REALTYPE) :: sfaceiadjb(-2:2, -2:2, -2:2), sfacejadjb(-2:2, &
&  -2:2, -2:2), sfacekadjb(-2:2, -2:2, -2:2)
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3), INTENT(IN) :: &
&  siadj
  REAL(KIND=REALTYPE) :: siadjb(-3:2, -3:2, -3:2, 3), sjadjb(-3:2, -3:2&
&  , -3:2, 3), skadjb(-3:2, -3:2, -3:2, 3)
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3), INTENT(IN) :: &
&  sjadj
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3), INTENT(IN) :: &
&  skadj
  REAL(KIND=REALTYPE), DIMENSION(0:0, 0:0, 0:0), INTENT(IN) :: voladj
  REAL(KIND=REALTYPE) :: voladjb(0:0, 0:0, 0:0)
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw), INTENT(IN) :: &
&  wadj
  REAL(KIND=REALTYPE) :: wadjb(-2:2, -2:2, -2:2, nw)
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: fact, fs, fsb, pa, pab, sface, sfaceb, tempb, &
&  tempb0, tempb1, vnm, vnmb, vnp, vnpb
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, kk
  REAL(KIND=REALTYPE) :: porflux, porvel, qsm, qsmb, qsp, qspb, rqsm, &
&  rqsmb, rqsp, rqspb
  REAL(KIND=REALTYPE) :: tempb2, tempb3, tempb4
  REAL(KIND=REALTYPE) :: rvol, rvolb, wx, wxb, wy, wyb, wz, wzb
  REAL(KIND=REALTYPE) :: rvol2, wx2, wy2, wz2
!
!      ******************************************************************
!      *                                                                *
!      * inviscidCentralFluxAdj computes the Euler fluxes using a       *
!      * central discretization for the cell iCell, jCell, kCell of the *
!      * block to which the variables in blockPointers currently point  *
!      * to.                                                            *
!      *                                                                *
!      ******************************************************************
!
! sFaceI,sFaceJ,sFaceK,sI,sJ,sK,blockismoving,addgridvelocities
! vol, nbkGlobal
! constants (irho, ivx, ivy, imx,..), timeRef
! equationMode, steady
!
!
!      Subroutine arguments
!
!
!      Local variables.
!
!     testing vars
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Initialize sFace to zero. This value will be used if the
! block is not moving.
  sface = 0.0
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the i-direction.                           *
!      *                                                                *
!      ******************************************************************
!
  i = icell - 1
  j = jcell
  k = kcell
  fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
  DO ii=-1,0
! Set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
    IF (addgridvelocities) THEN
      sface = sfaceiadj(ii, 0, 0)
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    CALL PUSHREAL8(vnp)
! Compute the normal velocities of the left and right state.
    vnp = wadj(ii+1, 0, 0, ivx)*siadj(ii, 0, 0, 1) + wadj(ii+1, 0, 0, &
&      ivy)*siadj(ii, 0, 0, 2) + wadj(ii+1, 0, 0, ivz)*siadj(ii, 0, 0, 3&
&      )
    CALL PUSHREAL8(vnm)
    vnm = wadj(ii, 0, 0, ivx)*siadj(ii, 0, 0, 1) + wadj(ii, 0, 0, ivy)*&
&      siadj(ii, 0, 0, 2) + wadj(ii, 0, 0, ivz)*siadj(ii, 0, 0, 3)
    CALL PUSHREAL8(porvel)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
    porvel = one
    CALL PUSHREAL8(porflux)
    porflux = half
    IF (pori(i, j, k) .EQ. noflux) THEN
      porflux = 0.0
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    IF (pori(i, j, k) .EQ. boundflux) THEN
      porvel = 0.0
      vnp = sface
      vnm = sface
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
! Incorporate porFlux in porVel.
    porvel = porvel*porflux
    CALL PUSHREAL8(qsp)
! Compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
    qsp = (vnp-sface)*porvel
    CALL PUSHREAL8(qsm)
    qsm = (vnm-sface)*porvel
    CALL PUSHREAL8(rqsp)
    rqsp = qsp*wadj(ii+1, 0, 0, irho)
    CALL PUSHREAL8(rqsm)
    rqsm = qsm*wadj(ii, 0, 0, irho)
    CALL PUSHREAL8(pa)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
    pa = porflux*(padj(ii+1, 0, 0)+padj(ii, 0, 0))
! Compute the fluxes through this face.
! Update i and set fact to 1 for the second face.
    i = i + 1
    CALL PUSHREAL8(fact)
    fact = one
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the j-direction.                           *
!      *                                                                *
!      ******************************************************************
!
  i = icell
  j = jcell - 1
  k = kcell
  fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
  DO jj=-1,0
! Set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
    IF (addgridvelocities) THEN
      sface = sfacejadj(0, jj, 0)
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    CALL PUSHREAL8(vnp)
! Compute the normal velocities of the left and right state.
    vnp = wadj(0, jj+1, 0, ivx)*sjadj(0, jj, 0, 1) + wadj(0, jj+1, 0, &
&      ivy)*sjadj(0, jj, 0, 2) + wadj(0, jj+1, 0, ivz)*sjadj(0, jj, 0, 3&
&      )
    CALL PUSHREAL8(vnm)
    vnm = wadj(0, jj, 0, ivx)*sjadj(0, jj, 0, 1) + wadj(0, jj, 0, ivy)*&
&      sjadj(0, jj, 0, 2) + wadj(0, jj, 0, ivz)*sjadj(0, jj, 0, 3)
    CALL PUSHREAL8(porvel)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
    porvel = one
    CALL PUSHREAL8(porflux)
    porflux = half
    IF (porj(i, j, k) .EQ. noflux) THEN
      porflux = 0.0
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    IF (porj(i, j, k) .EQ. boundflux) THEN
      porvel = 0.0
      vnp = sface
      vnm = sface
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
! Incorporate porFlux in porVel.
    porvel = porvel*porflux
    CALL PUSHREAL8(qsp)
! Compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
    qsp = (vnp-sface)*porvel
    CALL PUSHREAL8(qsm)
    qsm = (vnm-sface)*porvel
    CALL PUSHREAL8(rqsp)
    rqsp = qsp*wadj(0, jj+1, 0, irho)
    CALL PUSHREAL8(rqsm)
    rqsm = qsm*wadj(0, jj, 0, irho)
    CALL PUSHREAL8(pa)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
    pa = porflux*(padj(0, jj+1, 0)+padj(0, jj, 0))
! Compute the fluxes through this face.
! Update j and set fact to 1 for the second face.
    j = j + 1
    CALL PUSHREAL8(fact)
    fact = one
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the k-direction.                           *
!      *                                                                *
!      ******************************************************************
!
!       should this be inside, have k=kCell+kk?
  i = icell
  j = jcell
  k = kcell - 1
  fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
  DO kk=-1,0
! Set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
    IF (addgridvelocities) THEN
      sface = sfacekadj(0, 0, kk)
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    CALL PUSHREAL8(vnp)
! Compute the normal velocities of the left and right state.
    vnp = wadj(0, 0, kk+1, ivx)*skadj(0, 0, kk, 1) + wadj(0, 0, kk+1, &
&      ivy)*skadj(0, 0, kk, 2) + wadj(0, 0, kk+1, ivz)*skadj(0, 0, kk, 3&
&      )
    CALL PUSHREAL8(vnm)
    vnm = wadj(0, 0, kk, ivx)*skadj(0, 0, kk, 1) + wadj(0, 0, kk, ivy)*&
&      skadj(0, 0, kk, 2) + wadj(0, 0, kk, ivz)*skadj(0, 0, kk, 3)
    CALL PUSHREAL8(porvel)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
    porvel = one
    CALL PUSHREAL8(porflux)
    porflux = half
    IF (pork(i, j, k) .EQ. noflux) THEN
      porflux = 0.0
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    IF (pork(i, j, k) .EQ. boundflux) THEN
      porvel = 0.0
      vnp = sface
      vnm = sface
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
! Incorporate porFlux in porVel.
    porvel = porvel*porflux
    CALL PUSHREAL8(qsp)
! Compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
    qsp = (vnp-sface)*porvel
    CALL PUSHREAL8(qsm)
    qsm = (vnm-sface)*porvel
    CALL PUSHREAL8(rqsp)
    rqsp = qsp*wadj(0, 0, kk+1, irho)
    CALL PUSHREAL8(rqsm)
    rqsm = qsm*wadj(0, 0, kk, irho)
    CALL PUSHREAL8(pa)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
    pa = porflux*(padj(0, 0, kk+1)+padj(0, 0, kk))
! Compute the fluxes through this face.
! Update k and set fact to 1 for the second face.
    k = k + 1
    CALL PUSHREAL8(fact)
    fact = one
  END DO
! Add the rotational source terms for a moving block in a
! steady state computation. These source terms account for the
! centrifugal acceleration and the coriolis term. However, as
! the equations are solved in the inertial frame and not
! in the moving frame, the form is different than what you
! normally find in a text book.
  IF (blockismoving .AND. equationmode .EQ. steady) THEN
!          wx = timeRef*rotRateAdj(1)
!          wy = timeRef*rotRateAdj(2)
!          wz = timeRef*rotRateAdj(3)
!timeref is taken into account in copyAdjointStencil...
    wx = rotrateadj(1)
    wy = rotrateadj(2)
    wz = rotrateadj(3)
    rvol = wadj(0, 0, 0, irho)*voladj(0, 0, 0)
    tempb2 = rvol*dwadjb(imz)
    rvolb = (wy*wadj(0, 0, 0, ivz)-wz*wadj(0, 0, 0, ivy))*dwadjb(imx) + &
&      (wz*wadj(0, 0, 0, ivx)-wx*wadj(0, 0, 0, ivz))*dwadjb(imy) + (wx*&
&      wadj(0, 0, 0, ivy)-wy*wadj(0, 0, 0, ivx))*dwadjb(imz)
    tempb3 = rvol*dwadjb(imy)
    wxb = wadj(0, 0, 0, ivy)*tempb2 - wadj(0, 0, 0, ivz)*tempb3
    wadjb(0, 0, 0, ivy) = wadjb(0, 0, 0, ivy) + wx*tempb2
    tempb4 = rvol*dwadjb(imx)
    wyb = wadj(0, 0, 0, ivz)*tempb4 - wadj(0, 0, 0, ivx)*tempb2
    wadjb(0, 0, 0, ivx) = wadjb(0, 0, 0, ivx) + wz*tempb3 - wy*tempb2
    wzb = wadj(0, 0, 0, ivx)*tempb3 - wadj(0, 0, 0, ivy)*tempb4
    wadjb(0, 0, 0, ivz) = wadjb(0, 0, 0, ivz) + wy*tempb4 - wx*tempb3
    wadjb(0, 0, 0, ivy) = wadjb(0, 0, 0, ivy) - wz*tempb4
    voladjb(0:0, 0:0, 0:0) = 0.0
    wadjb(0, 0, 0, irho) = wadjb(0, 0, 0, irho) + voladj(0, 0, 0)*rvolb
    voladjb(0, 0, 0) = wadj(0, 0, 0, irho)*rvolb
    rotrateadjb(1:3) = 0.0
    rotrateadjb(3) = wzb
    rotrateadjb(2) = rotrateadjb(2) + wyb
    rotrateadjb(1) = rotrateadjb(1) + wxb
  ELSE
    rotrateadjb(1:3) = 0.0
    voladjb(0:0, 0:0, 0:0) = 0.0
  END IF
  sfaceb = 0.0
  DO kk=0,-1,-1
    CALL POPREAL8(fact)
    fsb = fact*dwadjb(irhoe)
    tempb1 = porflux*fsb
    qspb = wadj(0, 0, kk+1, irhoe)*fsb
    wadjb(0, 0, kk+1, irhoe) = wadjb(0, 0, kk+1, irhoe) + qsp*fsb
    qsmb = wadj(0, 0, kk, irhoe)*fsb
    wadjb(0, 0, kk, irhoe) = wadjb(0, 0, kk, irhoe) + qsm*fsb
    fsb = fact*dwadjb(imz)
    rqspb = wadj(0, 0, kk+1, ivz)*fsb
    wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + rqsp*fsb
    rqsmb = wadj(0, 0, kk, ivz)*fsb
    wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) + rqsm*fsb
    pab = skadj(0, 0, kk, 3)*fsb
    skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + pa*fsb
    fsb = fact*dwadjb(imy)
    rqspb = rqspb + wadj(0, 0, kk+1, ivy)*fsb
    wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, 0, kk, ivy)*fsb
    wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) + rqsm*fsb
    pab = pab + skadj(0, 0, kk, 2)*fsb
    skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + pa*fsb
    fsb = fact*dwadjb(imx)
    rqspb = rqspb + wadj(0, 0, kk+1, ivx)*fsb
    wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, 0, kk, ivx)*fsb
    wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) + rqsm*fsb
    pab = pab + skadj(0, 0, kk, 1)*fsb
    skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + pa*fsb
    fsb = fact*dwadjb(irho)
    rqspb = rqspb + fsb
    qspb = qspb + wadj(0, 0, kk+1, irho)*rqspb
    vnpb = porvel*qspb + padj(0, 0, kk+1)*tempb1
    padjb(0, 0, kk+1) = padjb(0, 0, kk+1) + vnp*tempb1
    rqsmb = rqsmb + fsb
    qsmb = qsmb + wadj(0, 0, kk, irho)*rqsmb
    vnmb = porvel*qsmb + padj(0, 0, kk)*tempb1
    padjb(0, 0, kk) = padjb(0, 0, kk) + vnm*tempb1
    CALL POPREAL8(pa)
    padjb(0, 0, kk+1) = padjb(0, 0, kk+1) + porflux*pab
    padjb(0, 0, kk) = padjb(0, 0, kk) + porflux*pab
    CALL POPREAL8(rqsm)
    wadjb(0, 0, kk, irho) = wadjb(0, 0, kk, irho) + qsm*rqsmb
    CALL POPREAL8(rqsp)
    wadjb(0, 0, kk+1, irho) = wadjb(0, 0, kk+1, irho) + qsp*rqspb
    CALL POPREAL8(qsm)
    sfaceb = sfaceb - porvel*qspb - porvel*qsmb
    CALL POPREAL8(qsp)
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      sfaceb = sfaceb + vnpb + vnmb
      vnmb = 0.0
      vnpb = 0.0
    END IF
    CALL POPINTEGER4(branch)
    CALL POPREAL8(porflux)
    CALL POPREAL8(porvel)
    CALL POPREAL8(vnm)
    wadjb(0, 0, kk, ivx) = wadjb(0, 0, kk, ivx) + skadj(0, 0, kk, 1)*&
&      vnmb
    skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + wadj(0, 0, kk, ivx)*vnmb
    wadjb(0, 0, kk, ivy) = wadjb(0, 0, kk, ivy) + skadj(0, 0, kk, 2)*&
&      vnmb
    skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + wadj(0, 0, kk, ivy)*vnmb
    wadjb(0, 0, kk, ivz) = wadjb(0, 0, kk, ivz) + skadj(0, 0, kk, 3)*&
&      vnmb
    skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + wadj(0, 0, kk, ivz)*vnmb
    CALL POPREAL8(vnp)
    wadjb(0, 0, kk+1, ivx) = wadjb(0, 0, kk+1, ivx) + skadj(0, 0, kk, 1)&
&      *vnpb
    skadjb(0, 0, kk, 1) = skadjb(0, 0, kk, 1) + wadj(0, 0, kk+1, ivx)*&
&      vnpb
    wadjb(0, 0, kk+1, ivy) = wadjb(0, 0, kk+1, ivy) + skadj(0, 0, kk, 2)&
&      *vnpb
    skadjb(0, 0, kk, 2) = skadjb(0, 0, kk, 2) + wadj(0, 0, kk+1, ivy)*&
&      vnpb
    wadjb(0, 0, kk+1, ivz) = wadjb(0, 0, kk+1, ivz) + skadj(0, 0, kk, 3)&
&      *vnpb
    skadjb(0, 0, kk, 3) = skadjb(0, 0, kk, 3) + wadj(0, 0, kk+1, ivz)*&
&      vnpb
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      sfacekadjb(0, 0, kk) = sfacekadjb(0, 0, kk) + sfaceb
      sfaceb = 0.0
    END IF
  END DO
  DO jj=0,-1,-1
    CALL POPREAL8(fact)
    fsb = fact*dwadjb(irhoe)
    tempb0 = porflux*fsb
    qspb = wadj(0, jj+1, 0, irhoe)*fsb
    wadjb(0, jj+1, 0, irhoe) = wadjb(0, jj+1, 0, irhoe) + qsp*fsb
    qsmb = wadj(0, jj, 0, irhoe)*fsb
    wadjb(0, jj, 0, irhoe) = wadjb(0, jj, 0, irhoe) + qsm*fsb
    fsb = fact*dwadjb(imz)
    rqspb = wadj(0, jj+1, 0, ivz)*fsb
    wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + rqsp*fsb
    rqsmb = wadj(0, jj, 0, ivz)*fsb
    wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) + rqsm*fsb
    pab = sjadj(0, jj, 0, 3)*fsb
    sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + pa*fsb
    fsb = fact*dwadjb(imy)
    rqspb = rqspb + wadj(0, jj+1, 0, ivy)*fsb
    wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, jj, 0, ivy)*fsb
    wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) + rqsm*fsb
    pab = pab + sjadj(0, jj, 0, 2)*fsb
    sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + pa*fsb
    fsb = fact*dwadjb(imx)
    rqspb = rqspb + wadj(0, jj+1, 0, ivx)*fsb
    wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + rqsp*fsb
    rqsmb = rqsmb + wadj(0, jj, 0, ivx)*fsb
    wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) + rqsm*fsb
    pab = pab + sjadj(0, jj, 0, 1)*fsb
    sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + pa*fsb
    fsb = fact*dwadjb(irho)
    rqspb = rqspb + fsb
    qspb = qspb + wadj(0, jj+1, 0, irho)*rqspb
    vnpb = porvel*qspb + padj(0, jj+1, 0)*tempb0
    padjb(0, jj+1, 0) = padjb(0, jj+1, 0) + vnp*tempb0
    rqsmb = rqsmb + fsb
    qsmb = qsmb + wadj(0, jj, 0, irho)*rqsmb
    vnmb = porvel*qsmb + padj(0, jj, 0)*tempb0
    padjb(0, jj, 0) = padjb(0, jj, 0) + vnm*tempb0
    CALL POPREAL8(pa)
    padjb(0, jj+1, 0) = padjb(0, jj+1, 0) + porflux*pab
    padjb(0, jj, 0) = padjb(0, jj, 0) + porflux*pab
    CALL POPREAL8(rqsm)
    wadjb(0, jj, 0, irho) = wadjb(0, jj, 0, irho) + qsm*rqsmb
    CALL POPREAL8(rqsp)
    wadjb(0, jj+1, 0, irho) = wadjb(0, jj+1, 0, irho) + qsp*rqspb
    CALL POPREAL8(qsm)
    sfaceb = sfaceb - porvel*qspb - porvel*qsmb
    CALL POPREAL8(qsp)
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      sfaceb = sfaceb + vnpb + vnmb
      vnmb = 0.0
      vnpb = 0.0
    END IF
    CALL POPINTEGER4(branch)
    CALL POPREAL8(porflux)
    CALL POPREAL8(porvel)
    CALL POPREAL8(vnm)
    wadjb(0, jj, 0, ivx) = wadjb(0, jj, 0, ivx) + sjadj(0, jj, 0, 1)*&
&      vnmb
    sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + wadj(0, jj, 0, ivx)*vnmb
    wadjb(0, jj, 0, ivy) = wadjb(0, jj, 0, ivy) + sjadj(0, jj, 0, 2)*&
&      vnmb
    sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + wadj(0, jj, 0, ivy)*vnmb
    wadjb(0, jj, 0, ivz) = wadjb(0, jj, 0, ivz) + sjadj(0, jj, 0, 3)*&
&      vnmb
    sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + wadj(0, jj, 0, ivz)*vnmb
    CALL POPREAL8(vnp)
    wadjb(0, jj+1, 0, ivx) = wadjb(0, jj+1, 0, ivx) + sjadj(0, jj, 0, 1)&
&      *vnpb
    sjadjb(0, jj, 0, 1) = sjadjb(0, jj, 0, 1) + wadj(0, jj+1, 0, ivx)*&
&      vnpb
    wadjb(0, jj+1, 0, ivy) = wadjb(0, jj+1, 0, ivy) + sjadj(0, jj, 0, 2)&
&      *vnpb
    sjadjb(0, jj, 0, 2) = sjadjb(0, jj, 0, 2) + wadj(0, jj+1, 0, ivy)*&
&      vnpb
    wadjb(0, jj+1, 0, ivz) = wadjb(0, jj+1, 0, ivz) + sjadj(0, jj, 0, 3)&
&      *vnpb
    sjadjb(0, jj, 0, 3) = sjadjb(0, jj, 0, 3) + wadj(0, jj+1, 0, ivz)*&
&      vnpb
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      sfacejadjb(0, jj, 0) = sfacejadjb(0, jj, 0) + sfaceb
      sfaceb = 0.0
    END IF
  END DO
  DO ii=0,-1,-1
    CALL POPREAL8(fact)
    fsb = fact*dwadjb(irhoe)
    tempb = porflux*fsb
    qspb = wadj(ii+1, 0, 0, irhoe)*fsb
    wadjb(ii+1, 0, 0, irhoe) = wadjb(ii+1, 0, 0, irhoe) + qsp*fsb
    qsmb = wadj(ii, 0, 0, irhoe)*fsb
    wadjb(ii, 0, 0, irhoe) = wadjb(ii, 0, 0, irhoe) + qsm*fsb
    fsb = fact*dwadjb(imz)
    rqspb = wadj(ii+1, 0, 0, ivz)*fsb
    wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + rqsp*fsb
    rqsmb = wadj(ii, 0, 0, ivz)*fsb
    wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) + rqsm*fsb
    pab = siadj(ii, 0, 0, 3)*fsb
    siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + pa*fsb
    fsb = fact*dwadjb(imy)
    rqspb = rqspb + wadj(ii+1, 0, 0, ivy)*fsb
    wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + rqsp*fsb
    rqsmb = rqsmb + wadj(ii, 0, 0, ivy)*fsb
    wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) + rqsm*fsb
    pab = pab + siadj(ii, 0, 0, 2)*fsb
    siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + pa*fsb
    fsb = fact*dwadjb(imx)
    rqspb = rqspb + wadj(ii+1, 0, 0, ivx)*fsb
    wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + rqsp*fsb
    rqsmb = rqsmb + wadj(ii, 0, 0, ivx)*fsb
    wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) + rqsm*fsb
    pab = pab + siadj(ii, 0, 0, 1)*fsb
    siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + pa*fsb
    fsb = fact*dwadjb(irho)
    rqspb = rqspb + fsb
    qspb = qspb + wadj(ii+1, 0, 0, irho)*rqspb
    vnpb = porvel*qspb + padj(ii+1, 0, 0)*tempb
    padjb(ii+1, 0, 0) = padjb(ii+1, 0, 0) + vnp*tempb
    rqsmb = rqsmb + fsb
    qsmb = qsmb + wadj(ii, 0, 0, irho)*rqsmb
    vnmb = porvel*qsmb + padj(ii, 0, 0)*tempb
    padjb(ii, 0, 0) = padjb(ii, 0, 0) + vnm*tempb
    CALL POPREAL8(pa)
    padjb(ii+1, 0, 0) = padjb(ii+1, 0, 0) + porflux*pab
    padjb(ii, 0, 0) = padjb(ii, 0, 0) + porflux*pab
    CALL POPREAL8(rqsm)
    wadjb(ii, 0, 0, irho) = wadjb(ii, 0, 0, irho) + qsm*rqsmb
    CALL POPREAL8(rqsp)
    wadjb(ii+1, 0, 0, irho) = wadjb(ii+1, 0, 0, irho) + qsp*rqspb
    CALL POPREAL8(qsm)
    sfaceb = sfaceb - porvel*qspb - porvel*qsmb
    CALL POPREAL8(qsp)
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      sfaceb = sfaceb + vnpb + vnmb
      vnmb = 0.0
      vnpb = 0.0
    END IF
    CALL POPINTEGER4(branch)
    CALL POPREAL8(porflux)
    CALL POPREAL8(porvel)
    CALL POPREAL8(vnm)
    wadjb(ii, 0, 0, ivx) = wadjb(ii, 0, 0, ivx) + siadj(ii, 0, 0, 1)*&
&      vnmb
    siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + wadj(ii, 0, 0, ivx)*vnmb
    wadjb(ii, 0, 0, ivy) = wadjb(ii, 0, 0, ivy) + siadj(ii, 0, 0, 2)*&
&      vnmb
    siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + wadj(ii, 0, 0, ivy)*vnmb
    wadjb(ii, 0, 0, ivz) = wadjb(ii, 0, 0, ivz) + siadj(ii, 0, 0, 3)*&
&      vnmb
    siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + wadj(ii, 0, 0, ivz)*vnmb
    CALL POPREAL8(vnp)
    wadjb(ii+1, 0, 0, ivx) = wadjb(ii+1, 0, 0, ivx) + siadj(ii, 0, 0, 1)&
&      *vnpb
    siadjb(ii, 0, 0, 1) = siadjb(ii, 0, 0, 1) + wadj(ii+1, 0, 0, ivx)*&
&      vnpb
    wadjb(ii+1, 0, 0, ivy) = wadjb(ii+1, 0, 0, ivy) + siadj(ii, 0, 0, 2)&
&      *vnpb
    siadjb(ii, 0, 0, 2) = siadjb(ii, 0, 0, 2) + wadj(ii+1, 0, 0, ivy)*&
&      vnpb
    wadjb(ii+1, 0, 0, ivz) = wadjb(ii+1, 0, 0, ivz) + siadj(ii, 0, 0, 3)&
&      *vnpb
    siadjb(ii, 0, 0, 3) = siadjb(ii, 0, 0, 3) + wadj(ii+1, 0, 0, ivz)*&
&      vnpb
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 1) THEN
      sfaceiadjb(ii, 0, 0) = sfaceiadjb(ii, 0, 0) + sfaceb
      sfaceb = 0.0
    END IF
  END DO
END SUBROUTINE INVISCIDCENTRALFLUXADJ_B
