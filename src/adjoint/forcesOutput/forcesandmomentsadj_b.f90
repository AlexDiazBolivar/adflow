!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of forcesandmomentsadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: pointrefadj padj
!                xadj skadj machcoefadj sjadj siadj
!   of linear combination of output variables: cfpadjout cmvadjout
!                cmpadjout cfvadjout
!
!      ******************************************************************
!      *                                                                *
!      * File:          forcesAndMomentsAdj.f90                            *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi                                    *
!      * Starting date: 12-18-2007                                      *
!      * Last modified: 12-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE FORCESANDMOMENTSADJ_B(cfpadj, cmpadj, cfvadj, cmvadj, &
&  cfpadjout, cfpadjoutb, cmpadjout, cmpadjoutb, cfvadjout, cfvadjoutb, &
&  cmvadjout, cmvadjoutb, yplusmax, pointrefadj, pointrefadjb, siadj, &
&  siadjb, sjadj, sjadjb, skadj, skadjb, normadj, xadj, xadjb, padj, &
&  padjb, wadj, iibeg, iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, &
&  level, mm, nn, machcoefadj, machcoefadjb)
  USE bctypes
  USE blockpointers
  USE communication
  USE flowvarrefstate
  USE inputphysics
  IMPLICIT NONE
!!$               
!!$               print *,'forcemoment',cfpadj(1),cmpadj(1)
!
!          **************************************************************
!          *                                                            *
!          * Integration of the viscous forces.                         *
!          * Only for viscous boundaries.                               *
!          *                                                            *
!          **************************************************************
!
!s       cMv(1) = cMv(1)*fact; cMv(2) = cMv(2)*fact; cMv(3) = cMv(3)*fact
  REAL(KIND=REALTYPE) :: cfpadj(3), cfvadj(3)
  REAL(KIND=REALTYPE) :: cfpadjout(3), cfpadjoutb(3), cfvadjout(3), &
&  cfvadjoutb(3)
  REAL(KIND=REALTYPE) :: cmpadj(3), cmvadj(3)
  REAL(KIND=REALTYPE) :: cmpadjout(3), cmpadjoutb(3), cmvadjout(3), &
&  cmvadjoutb(3)
  INTEGER(KIND=INTTYPE) :: i2beg, i2end, j2beg, j2end
  INTEGER(KIND=INTTYPE) :: iibeg, iiend, jjbeg, jjend
  INTEGER(KIND=INTTYPE) :: level, mm, nn
  REAL(KIND=REALTYPE) :: machcoefadj, machcoefadjb
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 3)&
&  , INTENT(IN) :: normadj
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(0:ib, 0:jb, 0:kb)
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: pointrefadj
  REAL(KIND=REALTYPE) :: pointrefadjb(3)
  REAL(KIND=REALTYPE), DIMENSION(2, iibeg:iiend, jjbeg:jjend, 3)&
&  , INTENT(IN) :: siadj
  REAL(KIND=REALTYPE) :: siadjb(2, iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, 2, jjbeg:jjend, 3)&
&  , INTENT(IN) :: sjadj
  REAL(KIND=REALTYPE) :: sjadjb(iibeg:iiend, 2, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 2, 3)&
&  , INTENT(IN) :: skadj
  REAL(KIND=REALTYPE) :: skadjb(iibeg:iiend, jjbeg:jjend, 2, 3)
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb, nw), INTENT(IN) :: &
&  wadj
  REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3), INTENT(IN) :: &
&  xadj
  REAL(KIND=REALTYPE) :: xadjb(0:ie, 0:je, 0:ke, 3)
  REAL(KIND=REALTYPE), INTENT(IN) :: yplusmax
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: cfpadjb(3)
  REAL(KIND=REALTYPE) :: cmpadjb(3)
  REAL(KIND=REALTYPE) :: dwall, fact, factb
  REAL(KIND=REALTYPE) :: fn, fx, fxb, fy, fyb, fz, fzb, pm1, pm1b, &
&  tempb2
  INTEGER(KIND=INTTYPE) :: i, ii, j, k
  REAL(KIND=REALTYPE) :: pp1(iibeg:iiend, jjbeg:jjend), pp1b(iibeg:iiend&
&  , jjbeg:jjend), pp2(iibeg:iiend, jjbeg:jjend), pp2b(iibeg:iiend, &
&  jjbeg:jjend)
  REAL(KIND=REALTYPE) :: refpoint(3), refpointb(3)
  REAL(KIND=REALTYPE) :: rho1(iibeg:iiend, jjbeg:jjend), rho2(iibeg:&
&  iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: ss(iibeg:iiend, jjbeg:jjend, 3), ssb(iibeg:&
&  iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: temp, temp0
  LOGICAL :: viscoussubface
  REAL(KIND=REALTYPE) :: tempb, tempb0, tempb1, xc, xcb, yc, ycb, zc, &
&  zcb
  REAL(KIND=REALTYPE) :: xx(i2beg:i2end+1, j2beg:j2end+1, 3), xxb(i2beg:&
&  i2end+1, j2beg:j2end+1, 3)
!
!      ******************************************************************
!      *                                                                *
!      * forcesAndMoments computes the contribution of the block        *
!      * given by the pointers in blockPointers to the force and        *
!      * moment coefficients of the geometry. A distinction is made     *
!      * between the inviscid and viscous parts. In case the maximum    *
!      * yplus value must be monitored (only possible for RANS), this   *
!      * value is also computed.                                        *
!      *                                                                *
!      ******************************************************************
!
!ie,je,ke
! myID for debug
!
!      Subroutine arguments
!
!s       integer(kind=intType),intent(in) :: iiBeg,iiEnd,jjBeg,jjEnd
!s
!s       real(kind=realType), dimension(3), intent(inout) :: cFpAdj, cFvAdj
!s       real(kind=realType), dimension(3), intent(inout) :: cMpAdj, cMvAdj
!s
!s       !add to allow for scaling!
!s       real(kind=realType), dimension(3), intent(out) :: cFpAdjOut, cFvAdjOut
!s       real(kind=realType), dimension(3), intent(out) :: cMpAdjOut, cMvAdjOut
!s       real(kind=realType), dimension(3), intent(in) :: refPoint
!s       real(kind=realType), intent(out), intent(in) :: yplusMax
!s       integer(kind=intType), intent(in) :: mm, level, nn
!s       real(kind=realType), dimension(2,1:je,1:ke,3), intent(in) :: siAdj
!s       real(kind=realType), dimension(1:ie,2,1:ke,3), intent(in) :: sjAdj
!s       real(kind=realType), dimension(1:ie,1:je,2,3), intent(in) :: skAdj
!s       real(kind=realType), dimension(iiBeg:iiEnd,jjBeg:jjEnd,3), intent(in) :: normAdj
!s       ! Note that the range of xAdj should correspond to 0:ie,0:je,0:ke
!s       real(kind=realType), dimension(0:ie,0:je,0:ke,3), intent(in) :: xAdj
!add to allow for scaling!
! Note that the range of xAdj should correspond to 0:ie,0:je,0:ke
!
!      Local variables.
!
!v       real(kind=realType) :: tauxx, tauyy, tauzz
!v       real(kind=realType) :: tauxy, tauxz, tauyz
!       real(kind=realType), dimension(iiBeg:iiEnd,jjBeg:jjEnd,3) :: xx
!real(kind=realType), dimension(iiBeg:iiEnd,jjBeg:jjEnd,3) :: xx
!v       real(kind=realType), dimension(:,:),   pointer :: rlv2, rlv1
!v       real(kind=realType), dimension(:,:),   pointer :: dd2Wall
!v       real(kind=realType), dimension(:,:,:), pointer :: ss, xx
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!    
! Determine the reference point for the moment computation in
! meters.
  refpoint(1) = lref*pointrefadj(1)
  refpoint(2) = lref*pointrefadj(2)
  refpoint(3) = lref*pointrefadj(3)
! Loop over the boundary subfaces of this block.
  IF (bctype(mm) .EQ. eulerwall .OR. bctype(mm) .EQ. nswalladiabatic &
&      .OR. bctype(mm) .EQ. nswallisothermal) THEN
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,:,kl)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,1:,kl); rlv1 => rlv(1:,1:,ke)
!v               endif
! Set a bunch of pointers depending on the face id to make
! a generic treatment possible. The routine setBcPointers
! is not used, because quite a few other ones are needed.
    SELECT CASE  (bcfaceid(mm)) 
    CASE (imin) 
!                print *,'imin'
      pp2(:, :) = padj(2, iibeg:iiend, jjbeg:jjend)
      pp1(:, :) = padj(1, iibeg:iiend, jjbeg:jjend)
      ss(:, :, :) = siadj(1, iibeg:iiend, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(1,iiBeg-1:iiEnd,jjBeg-1:jjEnd,:)
!               print *,'shape',shape(xx),shape(xAdj)
!!xx(:,:,:)   = xAdj(1,iiBeg-1:iiEnd-1,jjBeg-1:jjEnd-1,:)
      xx(:, :, :) = xadj(1, i2beg-1:i2end, j2beg-1:j2end, :)
!               xx(:,:,:)   = xAdj(1,:,:,:)
      fact = -one
      CALL PUSHINTEGER4(1)
    CASE (imax) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(2,:,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(2,1:,1:); rlv1 => rlv(1,1:,1:)
!v               endif
!===========================================================
!                print *,'imax'
      pp2(:, :) = padj(il, iibeg:iiend, jjbeg:jjend)
      pp1(:, :) = padj(ie, iibeg:iiend, jjbeg:jjend)
      ss(:, :, :) = siadj(2, iibeg:iiend, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(il,iiBeg-1:iiEnd,jjBeg-1:jjEnd,:)
!!xx(:,:,:)   = xAdj(il,iiBeg-1:iiEnd-1,jjBeg-1:jjEnd-1,:)
      xx(:, :, :) = xadj(il, i2beg-1:i2end, j2beg-1:j2end, :)
!               xx(:,:,:)   = xAdj(il,:,:,:)
      fact = one
      CALL PUSHINTEGER4(2)
    CASE (jmin) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(il,:,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(il,1:,1:); rlv1 => rlv(ie,1:,1:)
!v               endif
!===========================================================
!                print *,'jmin'
      pp2(:, :) = padj(iibeg:iiend, 2, jjbeg:jjend)
      pp1(:, :) = padj(iibeg:iiend, 1, jjbeg:jjend)
!!$               pp4  => p(1:,2,1:);      pp3  => p(1:,1,1:)
!!$               ss2   => sj(:,1,:,:); xx2   => x(:,1,:,:)
!!$         
!rho2 => w(1:,2,1:,irho); rho1 => w(1:,1,1:,irho)
!ss   => sj(:,1,:,:);     xx   => x(:,1,:,:)
!fact = -one
      ss(:, :, :) = sjadj(iibeg:iiend, 1, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,1,jjBeg-1:jjEnd,:)
!               print *,'indices',iibeg,i2beg,iiend,i2end
!               print *,'shape',shape(xx),shape(xAdj(iiBeg-1:iiEnd,1,jjBeg-1:jjEnd,:))
!xx(:,:,:)   = xAdj(iiBeg-1:iiEnd-1,1,jjBeg-1:jjEnd-1,:)
      xx(:, :, :) = xadj(i2beg-1:i2end, 1, j2beg-1:j2end, :)
!xx(:,:,:)   = xAdj(:,1,:,:)
!               print *,'xxjmin',xx(1,1,1),xadj(1,1,1,1),xx(1,2,1),xadj(1,1,2,1)
!               print *,'shape2',shape(xx),shape(xAdj(iiBeg-1:iiEnd,1,jjBeg-1:jjEnd,:))
!               stop
!               print *,'xx',xx(1,1,1),xx2(1,1,1),xAdj(0,0,0,1),x(0,0,0,1),x(1,1,1,1)
!               stop
      fact = -one
      CALL PUSHINTEGER4(3)
    CASE (jmax) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,2,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,2,1:); rlv1 => rlv(1:,1,1:)
!v               endif
!===========================================================
!               print *,'jmax'
      pp2(:, :) = padj(iibeg:iiend, jl, jjbeg:jjend)
      pp1(:, :) = padj(iibeg:iiend, je, jjbeg:jjend)
!!$               pp4  => p(1:,jl,1:);      pp3  => p(1:,je,1:)
!!$               ss2   => sj(:,jl,:,:);     xx2   => x(:,jl,:,:)
      ss(:, :, :) = sjadj(iibeg:iiend, 2, jjbeg:jjend, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,jl,jjBeg-1:jjEnd,:)
!xx(:,:,:)   = xAdj(iiBeg-1:iiEnd-1,jl,jjBeg-1:jjEnd-1,:)
      xx(:, :, :) = xadj(i2beg-1:i2end, jl, j2beg-1:j2end, :)
!               xx(:,:,:)   = xAdj(:,jl,:,:)
      fact = one
      CALL PUSHINTEGER4(4)
    CASE (kmin) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,jl,:)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,jl,1:); rlv1 => rlv(1:,je,1:)
!v               endif
!===========================================================
!                print *,'kmin'
      pp2(:, :) = padj(iibeg:iiend, jjbeg:jjend, 2)
      pp1(:, :) = padj(iibeg:iiend, jjbeg:jjend, 1)
!!$               pp4  => p(1:,1:,2);      pp3  => p(1:,1:,1)
!!$               ss2   => sk(:,:,1,:);     xx2   => x(:,:,1,:)
      ss(:, :, :) = skadj(iibeg:iiend, jjbeg:jjend, 1, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,jjBeg-1:jjEnd,1,:)
!xx(:,:,:)   = xAdj(iiBeg-1:iiEnd-1,jjBeg-1:jjEnd-1,1,:)
      xx(:, :, :) = xadj(i2beg-1:i2end, j2beg-1:j2end, 1, :)
!               xx(:,:,:)   = xAdj(:,:,1,:)
      fact = -one
      CALL PUSHINTEGER4(5)
    CASE (kmax) 
!v               if(equations == RANSEquations) dd2Wall => d2Wall(:,:,2)
!v               if( viscousSubface ) then
!v                 rlv2 => rlv(1:,1:,2); rlv1 => rlv(1:,1:,1)
!v               endif
!===========================================================
!                print *,'kmax'
      pp2(:, :) = padj(iibeg:iiend, jjbeg:jjend, kl)
      pp1(:, :) = padj(iibeg:iiend, jjbeg:jjend, ke)
!!$               pp4  => p(1:,1:,kl);      pp3  => p(1:,1:,ke)
!!$               ss2   => sk(:,:,kl,:);     xx2   => x(:,:,kl,:)
      ss(:, :, :) = skadj(iibeg:iiend, jjbeg:jjend, 2, :)
!               xx(:,:,:)   = xAdj(iiBeg-1:iiEnd,jjBeg-1:jjEnd,kl,:)
!xx(:,:,:)   = xAdj(iiBeg-1:iiEnd-1,jjBeg-1:jjEnd-1,kl,:)
      xx(:, :, :) = xadj(i2beg-1:i2end, j2beg-1:j2end, kl, :)
!               xx(:,:,:)   = xAdj(:,:,kl,:)
      fact = one
      CALL PUSHINTEGER4(6)
    CASE DEFAULT
      CALL PUSHINTEGER4(0)
    END SELECT
! Loop over the quadrilateral faces of the subface. 
! Note that +1 to Beg, and -1 to End to have ranges for the owned cell.
!print *,'indicies',i2beg,i2end,iiend,j2beg,j2end!,shape(xx)
    DO j=j2beg,j2end
      DO i=i2beg,i2end
        CALL PUSHREAL8(pm1)
!print *,'indices',i,j,xx(i+1,j+1,1),xx(i,j,1),xAdj(il,i-1,j-1,1),x(il,i-1,j-1,1),i2beg,i2end,iibeg,iiend,ie
!xAdj(i-1,1,j-1,1),x(i-1,1,j-1,1),i2beg,i2end,iibeg,iiend,ie
! Compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. Due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. The pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
        pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)
        CALL PUSHREAL8(xc)
!pm2 = fact*(half*(pp4(i,j) + pp3(i,j)) - pInf)
!print *,'pm comparison',pm1,pm2
        xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&          , 1)) - refpoint(1)
        CALL PUSHREAL8(yc)
        yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&          , 2)) - refpoint(2)
        CALL PUSHREAL8(zc)
        zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&          , 3)) - refpoint(3)
        CALL PUSHREAL8(fx)
!!$               xc2 = fourth*(xx2(i,j,  1) + xx2(i+1,j,  1) &
!!$                  +         xx2(i,j+1,1) + xx2(i+1,j+1,1)) - refPoint(1)
!!$               yc2 = fourth*(xx2(i,j,  2) + xx2(i+1,j,  2) &
!!$                  +         xx2(i,j+1,2) + xx2(i+1,j+1,2)) - refPoint(2)
!!$               zc2 = fourth*(xx2(i,j,  3) + xx2(i+1,j,  3) &
!!$                  +         xx2(i,j+1,3) + xx2(i+1,j+1,3)) - refPoint(3)
!print *,'shape',shape(xx),shape(xx2)
!stop
!               print *,'xc Comp',xc,xc2,xx(i,j,1),xx2(i,j,1),refpoint(1)
!               print *,'yc Comp',yc,yc2,xx(i,j,2),xx2(i,j,2),refpoint(2)
!               print *,'zc Comp',zc,zc2,xx(i,j,3),xx2(i,j,3),refpoint(3)
!!$               pm1 = fact*(half*(pp2(i,j) + pp1(i,j)) - pInf)
!!$
!!$               xc = fourth*(xx(i,j,  1) + xx(i-1,j,  1) &
!!$                  +         xx(i,j-1,1) + xx(i-1,j-1,1)) - refPoint(1)
!!$               yc = fourth*(xx(i,j,  2) + xx(i-1,j,  2) &
!!$                  +         xx(i,j-1,2) + xx(i-1,j-1,2)) - refPoint(2)
!!$               zc = fourth*(xx(i,j,  3) + xx(i-1,j,  3) &
!!$                  +         xx(i,j-1,3) + xx(i-1,j-1,3)) - refPoint(3)
! Compute the force components.
        fx = pm1*ss(i, j, 1)
        CALL PUSHREAL8(fy)
        fy = pm1*ss(i, j, 2)
        CALL PUSHREAL8(fz)
        fz = pm1*ss(i, j, 3)
!!$               fx2 = pm1*ss2(i,j,1)
!!$               fy2 = pm1*ss2(i,j,2)
!!$               fz2 = pm1*ss2(i,j,3)
!!$
!!$               !print *,'fx comparison',fx,fx2
! Update the inviscid force and moment coefficients.
        cfpadj(1) = cfpadj(1) + fx
        cfpadj(2) = cfpadj(2) + fy
        cfpadj(3) = cfpadj(3) + fz
        cmpadj(1) = cmpadj(1) + yc*fz - zc*fy
        cmpadj(2) = cmpadj(2) + zc*fx - xc*fz
        cmpadj(3) = cmpadj(3) + xc*fy - yc*fx
      END DO
    END DO
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
! It hasn't been implemented yet. 
!!$               ! Initialize dwall for the laminar case and set the pointer
!!$             ! for the unit normals.
!!$
!!$             dwall = zero
!!$             norm => BCData(nn)%norm
!!$
!!$             ! Loop over the quadrilateral faces of the subface and
!!$             ! compute the viscous contribution to the force and
!!$             ! moment and update the maximum value of y+.
!!$
!!$             do j=(BCData(nn)%jnBeg+1),BCData(nn)%jnEnd
!!$               do i=(BCData(nn)%inBeg+1),BCData(nn)%inEnd
!!$
!!$                 ! Store the viscous stress tensor a bit easier.
!!$
!!$                 tauXx = viscSubface(nn)%tau(i,j,1)
!!$                 tauYy = viscSubface(nn)%tau(i,j,2)
!!$                 tauZz = viscSubface(nn)%tau(i,j,3)
!!$                 tauXy = viscSubface(nn)%tau(i,j,4)
!!$                 tauXz = viscSubface(nn)%tau(i,j,5)
!!$                 tauYz = viscSubface(nn)%tau(i,j,6)
!!$
!!$                 ! Compute the viscous force on the face. A minus sign
!!$                 ! is now present, due to the definition of this force.
!!$
!!$                 fx = -fact*(tauXx*ss(i,j,1) + tauXy*ss(i,j,2) &
!!$                    +        tauXz*ss(i,j,3))
!!$                 fy = -fact*(tauXy*ss(i,j,1) + tauYy*ss(i,j,2) &
!!$                    +        tauYz*ss(i,j,3))
!!$                 fz = -fact*(tauXz*ss(i,j,1) + tauYz*ss(i,j,2) &
!!$                    +        tauZz*ss(i,j,3))
!!$
!!$                 ! Compute the coordinates of the centroid of the face
!!$                 ! relative from the moment reference point. Due to the
!!$                 ! usage of pointers for xx and offset of 1 is present,
!!$                 ! because x originally starts at 0.
!!$
!!$                 xc = fourth*(xx(i,j,  1) + xx(i+1,j,  1) &
!!$                    +         xx(i,j+1,1) + xx(i+1,j+1,1)) - refPoint(1)
!!$                 yc = fourth*(xx(i,j,  2) + xx(i+1,j,  2) &
!!$                    +         xx(i,j+1,2) + xx(i+1,j+1,2)) - refPoint(2)
!!$                 zc = fourth*(xx(i,j,  3) + xx(i+1,j,  3) &
!!$                    +         xx(i,j+1,3) + xx(i+1,j+1,3)) - refPoint(3)
!!$
!!$                 ! Update the viscous force and moment coefficients.
!!$
!!$                 cFv(1) = cFv(1) + fx
!!$                 cFv(2) = cFv(2) + fy
!!$                 cFv(3) = cFv(3) + fz
!!$
!!$                 cMv(1) = cMv(1) + yc*fz - zc*fy
!!$                 cMv(2) = cMv(2) + zc*fx - xc*fz
!!$                 cMv(3) = cMv(3) + xc*fy - yc*fx
!!$
!!$                 ! Compute the tangential component of the stress tensor,
!!$                 ! which is needed to monitor y+. The result is stored
!!$                 ! in fx, fy, fz, although it is not really a force.
!!$                 ! As later on only the magnitude of the tangential
!!$                 ! component is important, there is no need to take the
!!$                 ! sign into account (it should be a minus sign).
!!$
!!$                 fx = tauXx*norm(i,j,1) + tauXy*norm(i,j,2) &
!!$                    + tauXz*norm(i,j,3)
!!$                 fy = tauXy*norm(i,j,1) + tauYy*norm(i,j,2) &
!!$                    + tauYz*norm(i,j,3)
!!$                 fz = tauXz*norm(i,j,1) + tauYz*norm(i,j,2) &
!!$                    + tauZz*norm(i,j,3)
!!$
!!$                 fn = fx*norm(i,j,1) + fy*norm(i,j,2) + fz*norm(i,j,3)
!!$
!!$                 fx = fx - fn*norm(i,j,1)
!!$                 fy = fy - fn*norm(i,j,2)
!!$                 fz = fz - fn*norm(i,j,3)
!!$
!!$                 ! Compute the local value of y+. Due to the usage
!!$                 ! of pointers there is on offset of -1 in dd2Wall..
!!$
!!$                 if(equations == RANSEquations) dwall = dd2Wall(i-1,j-1)
!!$
!!$                 rho   = half*(rho2(i,j) + rho1(i,j))
!!$                 mul   = half*(rlv2(i,j) + rlv1(i,j))
!!$                 yplus = sqrt(rho*sqrt(fx*fx + fy*fy + fz*fz))*dwall/mul
!!$
!!$                 ! Store this value if this value is larger than the
!!$                 ! currently stored value.
!!$
!!$                 yplusMax = max(yplusMax, yplus)
!!$
!!$               enddo
!!$             enddo
!temporary
  cfvadj(:) = 0.0
  cmvadj(:) = 0.0
  CALL PUSHREAL8(fact)
! Currently the coefficients only contain the surface integral
! of the pressure tensor. These values must be scaled to
! obtain the correct coefficients.
  fact = two/(gammainf*pinf*machcoefadj*machcoefadj*surfaceref*lref*lref&
&    )
  CALL PUSHREAL8(fact)
!s       cFv(1) = cFv(1)*fact; cFv(2) = cFv(2)*fact; cFv(3) = cFv(3)*fact
  fact = fact/(lengthref*lref)
  factb = cmvadj(3)*cmvadjoutb(3)
  cmvadjoutb(3) = 0.0
  factb = factb + cmvadj(2)*cmvadjoutb(2)
  cmvadjoutb(2) = 0.0
  factb = factb + cmpadj(3)*cmpadjoutb(3) + cmvadj(1)*cmvadjoutb(1)
  cmpadjb(1:3) = 0.0
  cmpadjb(3) = fact*cmpadjoutb(3)
  cmpadjoutb(3) = 0.0
  cmpadjb(2) = cmpadjb(2) + fact*cmpadjoutb(2)
  factb = factb + cmpadj(2)*cmpadjoutb(2)
  cmpadjoutb(2) = 0.0
  cmpadjb(1) = cmpadjb(1) + fact*cmpadjoutb(1)
  factb = factb + cmpadj(1)*cmpadjoutb(1)
  CALL POPREAL8(fact)
  factb = cfvadj(3)*cfvadjoutb(3) + factb/(lengthref*lref)
  cfvadjoutb(3) = 0.0
  factb = factb + cfvadj(2)*cfvadjoutb(2)
  cfvadjoutb(2) = 0.0
  factb = factb + cfpadj(3)*cfpadjoutb(3) + cfvadj(1)*cfvadjoutb(1)
  cfpadjb(1:3) = 0.0
  cfpadjb(3) = fact*cfpadjoutb(3)
  cfpadjoutb(3) = 0.0
  cfpadjb(2) = cfpadjb(2) + fact*cfpadjoutb(2)
  factb = factb + cfpadj(2)*cfpadjoutb(2)
  cfpadjoutb(2) = 0.0
  cfpadjb(1) = cfpadjb(1) + fact*cfpadjoutb(1)
  factb = factb + cfpadj(1)*cfpadjoutb(1)
  CALL POPREAL8(fact)
  temp0 = gammainf*pinf*surfaceref*lref**2
  temp = temp0*machcoefadj**2
  machcoefadjb = -(two*temp0*2*machcoefadj*factb/temp**2)
  CALL POPINTEGER4(branch)
  IF (branch .LT. 1) THEN
    padjb(0:ib, 0:jb, 0:kb) = 0.0
    xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
    skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
    sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
    siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
    refpointb(1:3) = 0.0
  ELSE
    refpointb(1:3) = 0.0
    xxb(i2beg:i2end+1, j2beg:j2end+1, 1:3) = 0.0
    pp1b(iibeg:iiend, jjbeg:jjend) = 0.0
    pp2b(iibeg:iiend, jjbeg:jjend) = 0.0
    ssb(iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
    DO j=j2end,j2beg,-1
      DO i=i2end,i2beg,-1
        xcb = fy*cmpadjb(3) - fz*cmpadjb(2)
        fyb = cfpadjb(2) - zc*cmpadjb(1) + xc*cmpadjb(3)
        ycb = fz*cmpadjb(1) - fx*cmpadjb(3)
        fxb = cfpadjb(1) + zc*cmpadjb(2) - yc*cmpadjb(3)
        zcb = fx*cmpadjb(2) - fy*cmpadjb(1)
        fzb = cfpadjb(3) + yc*cmpadjb(1) - xc*cmpadjb(2)
        CALL POPREAL8(fz)
        pm1b = ss(i, j, 1)*fxb + ss(i, j, 2)*fyb + ss(i, j, 3)*fzb
        ssb(i, j, 3) = ssb(i, j, 3) + pm1*fzb
        CALL POPREAL8(fy)
        ssb(i, j, 2) = ssb(i, j, 2) + pm1*fyb
        CALL POPREAL8(fx)
        ssb(i, j, 1) = ssb(i, j, 1) + pm1*fxb
        CALL POPREAL8(zc)
        tempb = fourth*zcb
        xxb(i, j, 3) = xxb(i, j, 3) + tempb
        xxb(i+1, j, 3) = xxb(i+1, j, 3) + tempb
        xxb(i, j+1, 3) = xxb(i, j+1, 3) + tempb
        xxb(i+1, j+1, 3) = xxb(i+1, j+1, 3) + tempb
        refpointb(3) = refpointb(3) - zcb
        CALL POPREAL8(yc)
        tempb0 = fourth*ycb
        xxb(i, j, 2) = xxb(i, j, 2) + tempb0
        xxb(i+1, j, 2) = xxb(i+1, j, 2) + tempb0
        xxb(i, j+1, 2) = xxb(i, j+1, 2) + tempb0
        xxb(i+1, j+1, 2) = xxb(i+1, j+1, 2) + tempb0
        refpointb(2) = refpointb(2) - ycb
        CALL POPREAL8(xc)
        tempb1 = fourth*xcb
        xxb(i, j, 1) = xxb(i, j, 1) + tempb1
        xxb(i+1, j, 1) = xxb(i+1, j, 1) + tempb1
        xxb(i, j+1, 1) = xxb(i, j+1, 1) + tempb1
        xxb(i+1, j+1, 1) = xxb(i+1, j+1, 1) + tempb1
        refpointb(1) = refpointb(1) - xcb
        CALL POPREAL8(pm1)
        tempb2 = fact*half*pm1b
        pp2b(i, j) = pp2b(i, j) + tempb2
        pp1b(i, j) = pp1b(i, j) + tempb2
      END DO
    END DO
    CALL POPINTEGER4(branch)
    IF (branch .LT. 4) THEN
      IF (branch .LT. 2) THEN
        IF (branch .LT. 1) THEN
          padjb(0:ib, 0:jb, 0:kb) = 0.0
          xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
          skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
          sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
          siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
        ELSE
          xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
          xadjb(1, i2beg-1:i2end, j2beg-1:j2end, :) = xxb(:, :, :)
          siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
          siadjb(1, iibeg:iiend, jjbeg:jjend, :) = ssb(:, :, :)
          padjb(0:ib, 0:jb, 0:kb) = 0.0
          padjb(1, iibeg:iiend, jjbeg:jjend) = pp1b(:, :)
          padjb(2, iibeg:iiend, jjbeg:jjend) = padjb(2, iibeg:iiend, &
&            jjbeg:jjend) + pp2b(:, :)
          skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
          sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        END IF
      ELSE IF (branch .LT. 3) THEN
        xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
        xadjb(il, i2beg-1:i2end, j2beg-1:j2end, :) = xxb(:, :, :)
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
        siadjb(2, iibeg:iiend, jjbeg:jjend, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(ie, iibeg:iiend, jjbeg:jjend) = pp1b(:, :)
        padjb(il, iibeg:iiend, jjbeg:jjend) = padjb(il, iibeg:iiend, &
&          jjbeg:jjend) + pp2b(:, :)
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
      ELSE
        xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
        xadjb(i2beg-1:i2end, 1, j2beg-1:j2end, :) = xxb(:, :, :)
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        sjadjb(iibeg:iiend, 1, jjbeg:jjend, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(iibeg:iiend, 1, jjbeg:jjend) = pp1b(:, :)
        padjb(iibeg:iiend, 2, jjbeg:jjend) = padjb(iibeg:iiend, 2, jjbeg&
&          :jjend) + pp2b(:, :)
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      END IF
    ELSE IF (branch .LT. 6) THEN
      IF (branch .LT. 5) THEN
        xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
        xadjb(i2beg-1:i2end, jl, j2beg-1:j2end, :) = xxb(:, :, :)
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        sjadjb(iibeg:iiend, 2, jjbeg:jjend, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(iibeg:iiend, je, jjbeg:jjend) = pp1b(:, :)
        padjb(iibeg:iiend, jl, jjbeg:jjend) = padjb(iibeg:iiend, jl, &
&          jjbeg:jjend) + pp2b(:, :)
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      ELSE
        xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
        xadjb(i2beg-1:i2end, j2beg-1:j2end, 1, :) = xxb(:, :, :)
        skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
        skadjb(iibeg:iiend, jjbeg:jjend, 1, :) = ssb(:, :, :)
        padjb(0:ib, 0:jb, 0:kb) = 0.0
        padjb(iibeg:iiend, jjbeg:jjend, 1) = pp1b(:, :)
        padjb(iibeg:iiend, jjbeg:jjend, 2) = padjb(iibeg:iiend, jjbeg:&
&          jjend, 2) + pp2b(:, :)
        sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
        siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
      END IF
    ELSE
      xadjb(0:ie, 0:je, 0:ke, 1:3) = 0.0
      xadjb(i2beg-1:i2end, j2beg-1:j2end, kl, :) = xxb(:, :, :)
      skadjb(iibeg:iiend, jjbeg:jjend, 1:2, 1:3) = 0.0
      skadjb(iibeg:iiend, jjbeg:jjend, 2, :) = ssb(:, :, :)
      padjb(0:ib, 0:jb, 0:kb) = 0.0
      padjb(iibeg:iiend, jjbeg:jjend, ke) = pp1b(:, :)
      padjb(iibeg:iiend, jjbeg:jjend, kl) = padjb(iibeg:iiend, jjbeg:&
&        jjend, kl) + pp2b(:, :)
      sjadjb(iibeg:iiend, 1:2, jjbeg:jjend, 1:3) = 0.0
      siadjb(1:2, iibeg:iiend, jjbeg:jjend, 1:3) = 0.0
    END IF
  END IF
 !pointrefadjb(1:3) = 0.0
  pointrefadjb(3) = pointrefadjb(3) + lref*refpointb(3)
  refpointb(3) = 0.0
  pointrefadjb(2) = pointrefadjb(2) + lref*refpointb(2)
  refpointb(2) = 0.0
  pointrefadjb(1) = pointrefadjb(1) + lref*refpointb(1)
  refpointb(1) = 0.0
 
END SUBROUTINE FORCESANDMOMENTSADJ_B
