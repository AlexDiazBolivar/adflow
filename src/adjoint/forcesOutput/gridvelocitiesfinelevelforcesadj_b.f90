   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of gridvelocitiesfinelevelforcesadj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: pointrefadj rotrateadj
   !                alphaadj rotpointadj xadj betaadj machgridadj
   !                rotcenteradj veldirfreestreamadj timeunsteadyrestart
   !                timeunsteady sincoeffouralpha coscoeffouryrot
   !                sincoeffourbeta coscoeffourxrot coefpolmach coefpolzrot
   !                omegafourmach omegafouralpha omegafourzrot coefpolyrot
   !                omegafouryrot coefpolxrot coefpolalpha sincoeffourmach
   !                omegafourxrot sincoeffourzrot coscoeffourbeta
   !                sincoeffouryrot sincoeffourxrot coscoeffouralpha
   !                coefpolbeta omegafourbeta coscoeffourmach coscoeffourzrot
   !   of linear combination of output variables: pointrefadj xadj
   !                sadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          gridVelocitiesFineLevelForcesAdj.f90            *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 02-23-2004                                      *
   !      * Last modified: 10-22-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE GRIDVELOCITIESFINELEVELFORCESADJ_B(useoldcoor, t, sps, xadj, &
   &  xadjb, sadj, sadjb, iibeg, iiend, jjbeg, jjend, i2beg, i2end, j2beg, &
   &  j2end, mm, sfaceiadj, sfacejadj, sfacekadj, machgridadj, machgridadjb&
   &  , veldirfreestreamadj, veldirfreestreamadjb, liftdirectionadj, &
   &  alphaadj, alphaadjb, betaadj, betaadjb, liftindex, rotpointadj, &
   &  rotpointadjb, pointrefadj, pointrefadjb, rotcenteradj, rotcenteradjb&
   &  , rotrateadj, rotrateadjb, siadj, sjadj, skadj)
   USE bctypes
   USE blockpointers
   USE cgnsgrid
   USE flowvarrefstate
   USE inputmotion
   USE inputphysics
   USE inputtimespectral
   USE inputtsstabderiv
   USE inputunsteady
   USE iteration
   USE monitor
   IMPLICIT NONE
   !           enddo loopDirection
   !      enddo domains
   ! print *,'finished grid velocities'
   REAL(KIND=REALTYPE) :: alphaadj, alphaadjb, betaadj, betaadjb
   INTEGER(KIND=INTTYPE) :: i2beg, i2end, j2beg, j2end
   INTEGER(KIND=INTTYPE) :: iibeg, iiend, jjbeg, jjend
   REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: liftdirectionadj
   INTEGER(KIND=INTTYPE) :: liftindex
   REAL(KIND=REALTYPE), INTENT(IN) :: machgridadj
   REAL(KIND=REALTYPE) :: machgridadjb
   INTEGER(KIND=INTTYPE) :: mm
   REAL(KIND=REALTYPE) :: pointrefadj(3), pointrefadjb(3)
   REAL(KIND=REALTYPE) :: rotcenteradj(3), rotcenteradjb(3), rotrateadj(3&
   &  ), rotrateadjb(3)
   REAL(KIND=REALTYPE) :: rotpointadj(3), rotpointadjb(3)
   REAL(KIND=REALTYPE) :: sadj(0:ie, 0:je, 0:ke, 3), sadjb(0:ie, 0:je, 0:&
   &  ke, 3)
   REAL(KIND=REALTYPE) :: sfaceiadj(2, iibeg:iiend, jjbeg:jjend)
   REAL(KIND=REALTYPE) :: sfacejadj(iibeg:iiend, 2, jjbeg:jjend)
   REAL(KIND=REALTYPE) :: sfacekadj(iibeg:iiend, jjbeg:jjend, 2)
   REAL(KIND=REALTYPE), DIMENSION(2, iibeg:iiend, jjbeg:jjend, 3)&
   &  , INTENT(IN) :: siadj
   REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, 2, jjbeg:jjend, 3)&
   &  , INTENT(IN) :: sjadj
   REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 2, 3)&
   &  , INTENT(IN) :: skadj
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   REAL(KIND=REALTYPE), DIMENSION(*), INTENT(IN) :: t
   LOGICAL, INTENT(IN) :: useoldcoor
   REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: veldirfreestreamadj
   REAL(KIND=REALTYPE) :: veldirfreestreamadjb(3)
   REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3), INTENT(IN) :: &
   &  xadj
   REAL(KIND=REALTYPE) :: xadjb(0:ie, 0:je, 0:ke, 3)
   REAL(KIND=REALTYPE) :: alphats, alphatsb, betats, betatsb
   REAL(KIND=REALTYPE) :: alpha, alphab, beta, betab
   REAL(KIND=REALTYPE) :: alphaincrement, betaincrement
   INTEGER :: branch
   REAL(KIND=REALTYPE) :: dragdir(3), liftdir(3), liftdirb(3), veldir(3)&
   &  , veldirb(3)
   INTEGER(KIND=INTTYPE) :: i, ii, iie, j, jje, k, kke
   INTEGER(KIND=INTTYPE) :: nn
   REAL(KIND=REALTYPE) :: offsetvector(3), offsetvectorb(3)
   REAL(KIND=REALTYPE) :: oneover4dt, oneover8dt
   REAL(KIND=REALTYPE) :: derivrotationmatrixadj(3, 3), rotationmatrixadj&
   &  (3, 3)
   REAL(KIND=REALTYPE) :: rotationpointadj(3), rotationpointadjb(3)
   REAL(KIND=REALTYPE) :: rotratetemp(3), rotratetempb(3)
   REAL(KIND=REALTYPE) :: rotratetrans(3, 3), rotratetransb(3, 3)
   REAL(KIND=REALTYPE) :: sfaceadj(iibeg:iiend, jjbeg:jjend)
   REAL(KIND=REALTYPE) :: ssadj(iibeg:iiend, jjbeg:jjend, 3)
   REAL(KIND=REALTYPE) :: intervalmach, tnew, told
   REAL(KIND=REALTYPE) :: TSALPHA
   REAL(KIND=REALTYPE) :: TSBETA
   REAL(KIND=REALTYPE) :: TSMACH
   REAL(KIND=REALTYPE) :: ainf, velxgrid, velxgridb, velygrid, velygridb&
   &  , velzgrid, velzgridb
   REAL(KIND=REALTYPE) :: velxgrid0, velxgrid0b, velygrid0, velygrid0b, &
   &  velzgrid0, velzgrid0b
   REAL(KIND=REALTYPE) :: sc(3), scb(3), tempb, tempb0, tempb1, xc(3), &
   &  xcb(3), xxc(3), xxcb(3)
   REAL(KIND=REALTYPE) :: xxadj(iibeg-1:iiend, jjbeg-1:jjend, 3)
   INTRINSIC COS, SIN, SQRT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * gridVelocitiesFineLevel computes the grid velocities for       *
   !      * the cell centers and the normal grid velocities for the faces  *
   !      * of moving blocks for the currently finest grid, i.e.           *
   !      * groundLevel. The velocities are computed at time t for         *
   !      * spectral mode sps. If useOldCoor is .true. the velocities      *
   !      * are determined using the unsteady time integrator in           *
   !      * combination with the old coordinates; otherwise the analytic   *
   !      * form is used.                                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   !imin,imax,etc.
   !nTimeIntervalsSpectral
   !Timeunsteady, timeunsteadyrestart
   !
   !      Subroutine arguments.
   !
   !
   !      Local variables.
   !
   !function definitions
   !real(kind=realType), dimension(:,:), pointer :: sFace
   !       real(kind=realType), dimension(:,:,:),   pointer :: xx, ss
   !       real(kind=realType), dimension(:,:,:,:), pointer :: xxOld
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the mesh velocity from the given mesh Mach number.
   !print *,'in gridvelocities',mm
   !  aInf = sqrt(gammaInf*pInf/rhoInf)
   !  velxGrid = aInf*MachGrid(1)
   !  velyGrid = aInf*MachGrid(2)
   !  velzGrid = aInf*MachGrid(3)
   ! velxGrid = zero
   ! velyGrid = zero
   ! velzGrid = zero
   ainf = SQRT(gammainf*pinf/rhoinf)
   ! Compute the derivative of the rotation matrix and the rotation
   ! point; needed for velocity due to the rigid body rotation of
   ! the entire grid. It is assumed that the rigid body motion of
   ! the grid is only specified if there is only 1 section present.
   CALL DERIVATIVEROTMATRIXRIGIDFORCESADJ(derivrotationmatrixadj, &
   &                                   rotationpointadj, rotpointadj, t(1))
   !compute the rotation matrix to update the velocities for the time
   !spectral stability derivative case...
   IF (tsstability) THEN
   ! Determine the time values of the old and new time level.
   ! It is assumed that the rigid body rotation of the mesh is only
   ! used when only 1 section is present.
   tnew = timeunsteady + timeunsteadyrestart
   told = tnew - t(1)
   !print *,'Time',t(1)
   IF (tspmode .OR. tsqmode .OR. tsrmode) THEN
   ! Compute the rotation matrix of the rigid body rotation as
   ! well as the rotation point; the latter may vary in time due
   ! to rigid body translation.
   CALL ROTMATRIXRIGIDBODYFORCESADJ(tnew, told, rotationmatrixadj, &
   &                                 rotationpointadj, rotpointadj)
   CALL PUSHINTEGER4(1)
   ELSE IF (tsalphamode) THEN
   !print*,'liftindex alpha',liftindex,velDirFreestreamAdj,liftDir,liftIndex
   ! get the baseline alpha and determine the liftIndex
   !             call getDirAngleForces(velDirFreestreamAdj,liftDir,liftIndex,alpha,beta)
   !print *,'liftindex alpha',liftindex
   !Determine the alpha for this time instance
   alphaincrement = TSALPHA(degreepolalpha, coefpolalpha, &
   &        degreefouralpha, omegafouralpha, coscoeffouralpha, &
   &        sincoeffouralpha, t(1))
   alphats = alphaadj + alphaincrement
   !Determine the grid velocity for this alpha
   CALL ADJUSTINFLOWANGLEFORCESADJ(alphats, betaadj, veldir, liftdir&
   &                                , dragdir, liftindex)
   !do I need to update the lift direction and drag direction as well?
   !set the effictive grid velocity for this time interval
   !print *,'base velocity',machgridadj, velxGrid0 , velyGrid0 , velzGrid0 
   CALL PUSHINTEGER4(2)
   ELSE IF (tsbetamode) THEN
   ! get the baseline alpha and determine the liftIndex
   !call getDirAngleForces(velDirFreestreamAdj,liftDir,liftIndex,alpha,beta)
   !Determine the alpha for this time instance
   betaincrement = TSBETA(degreepolbeta, coefpolbeta, degreefourbeta&
   &        , omegafourbeta, coscoeffourbeta, sincoeffourbeta, t(1))
   betats = betaadj + betaincrement
   !Determine the grid velocity for this alpha
   CALL ADJUSTINFLOWANGLEFORCESADJ(alphaadj, betats, veldir, liftdir&
   &                                , dragdir, liftindex)
   !do I need to update the lift direction and drag direction as well?
   !set the effictive grid velocity for this time interval
   CALL PUSHINTEGER4(3)
   ELSE IF (tsmachmode) THEN
   !determine the mach number at this time interval
   intervalmach = TSMACH(degreepolmach, coefpolmach, degreefourmach, &
   &        omegafourmach, coscoeffourmach, sincoeffourmach, t(1))
   !set the effective grid velocity
   CALL PUSHINTEGER4(4)
   ELSE
   CALL PUSHINTEGER4(5)
   END IF
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   !moved outside
   !!$       ! Loop over the number of local blocks.
   !!$
   !!$       domains: do nn=1,nDom
   !!$
   !!$         ! Set the pointers for this block.
   !!$
   !!$         call setPointers(nn, groundLevel, sps)
   ! Check for a moving block.
   IF (blockismoving) THEN
   ! Determine the situation we are having here.
   IF (useoldcoor) THEN
   rotrateadjb(1:3) = 0.0
   alphaadjb = 0.0
   rotpointadjb(1:3) = 0.0
   betaadjb = 0.0
   rotcenteradjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   rotationpointadjb(1:3) = 0.0
   velygrid0b = 0.0
   ELSE
   !
   !            ************************************************************
   !            *                                                          *
   !            * The velocities must be determined analytically.          *
   !            *                                                          *
   !            ************************************************************
   !
   !!! Pass these in, set them in copyADjointStencil.f90
   !!$
   !!$             ! Store the rotation center and determine the
   !!$             ! nonDimensional rotation rate of this block. As the
   !!$             ! reference length is 1 timeRef == 1/uRef and at the end
   !!$             ! the nonDimensional velocity is computed.
   !!$
   !!$             j = nbkGlobal
   !!$
   !!$             rotCenter = cgnsDoms(j)%rotCenter
   !!$             rotRate   = timeRef*cgnsDoms(j)%rotRate
   IF (usewindaxis) THEN
   alpha = alphaadj
   beta = betaadj
   !Rotate the rotation rate from the wind axis back to the local body axis
   rotratetrans(1, 1) = COS(alpha)*COS(beta)
   rotratetrans(1, 2) = -(COS(alpha)*SIN(beta))
   rotratetrans(1, 3) = -SIN(alpha)
   rotratetrans(2, 1) = SIN(beta)
   rotratetrans(2, 2) = COS(beta)
   rotratetrans(2, 3) = 0.0
   rotratetrans(3, 1) = SIN(alpha)*COS(beta)
   rotratetrans(3, 2) = -(SIN(alpha)*SIN(beta))
   rotratetrans(3, 3) = COS(alpha)
   rotratetemp = rotrateadj
   rotrateadj = 0.0
   DO i=1,3
   DO j=1,3
   rotrateadj(i) = rotrateadj(i) + rotratetemp(j)*rotratetrans(&
   &              i, j)
   END DO
   END DO
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   offsetvector = rotcenteradj - pointrefadj
   !subtract off the rotational velocity of the center of the grid
   ! to account for the added overall velocity.
   !
   !            ************************************************************
   !            *                                                          *
   !            * Grid velocities of the cell centers, including the       *
   !            * 1st level halo cells.                                    *
   !            *                                                          *
   !            ************************************************************
   !
   ! Loop over the cells, including the 1st level halo's.
   ! print *,'calculating grid velocities',ie,je,ke,shape(xadj)
   DO k=1,ke
   DO j=1,je
   DO i=1,ie
   ! Determine the coordinates of the cell center,
   ! which are stored in xc.
   xc(1) = eighth*(xadj(i-1, j-1, k-1, 1)+xadj(i, j-1, k-1, 1)+&
   &              xadj(i-1, j, k-1, 1)+xadj(i, j, k-1, 1)+xadj(i-1, j-1, k&
   &              , 1)+xadj(i, j-1, k, 1)+xadj(i-1, j, k, 1)+xadj(i, j, k, &
   &              1))
   xc(2) = eighth*(xadj(i-1, j-1, k-1, 2)+xadj(i, j-1, k-1, 2)+&
   &              xadj(i-1, j, k-1, 2)+xadj(i, j, k-1, 2)+xadj(i-1, j-1, k&
   &              , 2)+xadj(i, j-1, k, 2)+xadj(i-1, j, k, 2)+xadj(i, j, k, &
   &              2))
   xc(3) = eighth*(xadj(i-1, j-1, k-1, 3)+xadj(i, j-1, k-1, 3)+&
   &              xadj(i-1, j, k-1, 3)+xadj(i, j, k-1, 3)+xadj(i-1, j-1, k&
   &              , 3)+xadj(i, j-1, k, 3)+xadj(i-1, j, k, 3)+xadj(i, j, k, &
   &              3))
   CALL PUSHREAL8(xxc(1))
   ! Determine the coordinates relative to the
   ! center of rotation.
   xxc(1) = xc(1) - rotcenteradj(1)
   CALL PUSHREAL8(xxc(2))
   xxc(2) = xc(2) - rotcenteradj(2)
   CALL PUSHREAL8(xxc(3))
   xxc(3) = xc(3) - rotcenteradj(3)
   CALL PUSHREAL8(xxc(1))
   ! Determine the rotation speed of the cell center,
   ! which is omega*r.
   ! Determine the coordinates relative to the
   ! rigid body rotation point.
   xxc(1) = xc(1) - rotationpointadj(1)
   CALL PUSHREAL8(xxc(2))
   xxc(2) = xc(2) - rotationpointadj(2)
   CALL PUSHREAL8(xxc(3))
   xxc(3) = xc(3) - rotationpointadj(3)
   ! Determine the total velocity of the cell center.
   ! This is a combination of rotation speed of this
   ! block and the entire rigid body rotation.
   END DO
   END DO
   END DO
   rotrateadjb(1:3) = 0.0
   rotcenteradjb(1:3) = 0.0
   velygridb = 0.0
   xcb(1:3) = 0.0
   xxcb(1:3) = 0.0
   velzgridb = 0.0
   rotationpointadjb(1:3) = 0.0
   scb(1:3) = 0.0
   velxgridb = 0.0
   DO k=ke,1,-1
   DO j=je,1,-1
   DO i=ie,1,-1
   scb(3) = scb(3) + sadjb(i, j, k, 3)
   velzgridb = velzgridb + sadjb(i, j, k, 3)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(3, 1)*sadjb(i, j&
   &              , k, 3)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(3, 2)*sadjb(i, j&
   &              , k, 3)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(3, 3)*sadjb(i, j&
   &              , k, 3)
   sadjb(i, j, k, 3) = 0.0
   scb(2) = scb(2) + sadjb(i, j, k, 2)
   velygridb = velygridb + sadjb(i, j, k, 2)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(2, 1)*sadjb(i, j&
   &              , k, 2)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(2, 2)*sadjb(i, j&
   &              , k, 2)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(2, 3)*sadjb(i, j&
   &              , k, 2)
   sadjb(i, j, k, 2) = 0.0
   scb(1) = scb(1) + sadjb(i, j, k, 1)
   velxgridb = velxgridb + sadjb(i, j, k, 1)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(1, 1)*sadjb(i, j&
   &              , k, 1)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(1, 2)*sadjb(i, j&
   &              , k, 1)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(1, 3)*sadjb(i, j&
   &              , k, 1)
   sadjb(i, j, k, 1) = 0.0
   CALL POPREAL8(xxc(3))
   xcb(3) = xcb(3) + xxcb(3)
   rotationpointadjb(3) = rotationpointadjb(3) - xxcb(3)
   xxcb(3) = 0.0
   CALL POPREAL8(xxc(2))
   xcb(2) = xcb(2) + xxcb(2)
   rotationpointadjb(2) = rotationpointadjb(2) - xxcb(2)
   xxcb(2) = 0.0
   CALL POPREAL8(xxc(1))
   xcb(1) = xcb(1) + xxcb(1)
   rotationpointadjb(1) = rotationpointadjb(1) - xxcb(1)
   xxcb(1) = 0.0
   rotrateadjb(1) = rotrateadjb(1) + xxc(2)*scb(3)
   xxcb(2) = xxcb(2) + rotrateadj(1)*scb(3)
   rotrateadjb(2) = rotrateadjb(2) - xxc(1)*scb(3)
   xxcb(1) = xxcb(1) - rotrateadj(2)*scb(3)
   scb(3) = 0.0
   rotrateadjb(3) = rotrateadjb(3) + xxc(1)*scb(2)
   xxcb(1) = xxcb(1) + rotrateadj(3)*scb(2)
   rotrateadjb(1) = rotrateadjb(1) - xxc(3)*scb(2)
   xxcb(3) = xxcb(3) - rotrateadj(1)*scb(2)
   scb(2) = 0.0
   rotrateadjb(2) = rotrateadjb(2) + xxc(3)*scb(1)
   xxcb(3) = xxcb(3) + rotrateadj(2)*scb(1)
   rotrateadjb(3) = rotrateadjb(3) - xxc(2)*scb(1)
   xxcb(2) = xxcb(2) - rotrateadj(3)*scb(1)
   scb(1) = 0.0
   CALL POPREAL8(xxc(3))
   xcb(3) = xcb(3) + xxcb(3)
   rotcenteradjb(3) = rotcenteradjb(3) - xxcb(3)
   xxcb(3) = 0.0
   CALL POPREAL8(xxc(2))
   xcb(2) = xcb(2) + xxcb(2)
   rotcenteradjb(2) = rotcenteradjb(2) - xxcb(2)
   xxcb(2) = 0.0
   CALL POPREAL8(xxc(1))
   xcb(1) = xcb(1) + xxcb(1)
   rotcenteradjb(1) = rotcenteradjb(1) - xxcb(1)
   xxcb(1) = 0.0
   tempb = eighth*xcb(3)
   xadjb(i-1, j-1, k-1, 3) = xadjb(i-1, j-1, k-1, 3) + tempb
   xadjb(i, j-1, k-1, 3) = xadjb(i, j-1, k-1, 3) + tempb
   xadjb(i-1, j, k-1, 3) = xadjb(i-1, j, k-1, 3) + tempb
   xadjb(i, j, k-1, 3) = xadjb(i, j, k-1, 3) + tempb
   xadjb(i-1, j-1, k, 3) = xadjb(i-1, j-1, k, 3) + tempb
   xadjb(i, j-1, k, 3) = xadjb(i, j-1, k, 3) + tempb
   xadjb(i-1, j, k, 3) = xadjb(i-1, j, k, 3) + tempb
   xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + tempb
   xcb(3) = 0.0
   tempb0 = eighth*xcb(2)
   xadjb(i-1, j-1, k-1, 2) = xadjb(i-1, j-1, k-1, 2) + tempb0
   xadjb(i, j-1, k-1, 2) = xadjb(i, j-1, k-1, 2) + tempb0
   xadjb(i-1, j, k-1, 2) = xadjb(i-1, j, k-1, 2) + tempb0
   xadjb(i, j, k-1, 2) = xadjb(i, j, k-1, 2) + tempb0
   xadjb(i-1, j-1, k, 2) = xadjb(i-1, j-1, k, 2) + tempb0
   xadjb(i, j-1, k, 2) = xadjb(i, j-1, k, 2) + tempb0
   xadjb(i-1, j, k, 2) = xadjb(i-1, j, k, 2) + tempb0
   xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + tempb0
   xcb(2) = 0.0
   tempb1 = eighth*xcb(1)
   xadjb(i-1, j-1, k-1, 1) = xadjb(i-1, j-1, k-1, 1) + tempb1
   xadjb(i, j-1, k-1, 1) = xadjb(i, j-1, k-1, 1) + tempb1
   xadjb(i-1, j, k-1, 1) = xadjb(i-1, j, k-1, 1) + tempb1
   xadjb(i, j, k-1, 1) = xadjb(i, j, k-1, 1) + tempb1
   xadjb(i-1, j-1, k, 1) = xadjb(i-1, j-1, k, 1) + tempb1
   xadjb(i, j-1, k, 1) = xadjb(i, j-1, k, 1) + tempb1
   xadjb(i-1, j, k, 1) = xadjb(i-1, j, k, 1) + tempb1
   xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + tempb1
   xcb(1) = 0.0
   END DO
   END DO
   END DO
   rotpointadjb(1:3) = 0.0
   offsetvectorb(1:3) = 0.0
   velzgrid0b = velzgridb
   rotrateadjb(1) = rotrateadjb(1) + offsetvector(2)*velzgridb
   offsetvectorb(2) = rotrateadj(1)*velzgridb
   rotrateadjb(2) = rotrateadjb(2) - offsetvector(1)*velzgridb
   offsetvectorb(1) = rotrateadj(3)*velygridb - rotrateadj(2)*&
   &        velzgridb
   rotpointadjb(1) = derivrotationmatrixadj(3, 1)*velzgridb
   rotpointadjb(2) = derivrotationmatrixadj(3, 2)*velzgridb
   rotpointadjb(3) = derivrotationmatrixadj(3, 3)*velzgridb
   velygrid0b = velygridb
   rotrateadjb(3) = rotrateadjb(3) + offsetvector(1)*velygridb
   rotrateadjb(1) = rotrateadjb(1) - offsetvector(3)*velygridb
   offsetvectorb(3) = offsetvectorb(3) + rotrateadj(2)*velxgridb - &
   &        rotrateadj(1)*velygridb
   rotpointadjb(1) = rotpointadjb(1) + derivrotationmatrixadj(2, 1)*&
   &        velygridb
   rotpointadjb(2) = rotpointadjb(2) + derivrotationmatrixadj(2, 2)*&
   &        velygridb
   rotpointadjb(3) = rotpointadjb(3) + derivrotationmatrixadj(2, 3)*&
   &        velygridb
   velxgrid0b = velxgridb
   rotrateadjb(2) = rotrateadjb(2) + offsetvector(3)*velxgridb
   rotrateadjb(3) = rotrateadjb(3) - offsetvector(2)*velxgridb
   offsetvectorb(2) = offsetvectorb(2) - rotrateadj(3)*velxgridb
   rotpointadjb(1) = rotpointadjb(1) + derivrotationmatrixadj(1, 1)*&
   &        velxgridb
   rotpointadjb(2) = rotpointadjb(2) + derivrotationmatrixadj(1, 2)*&
   &        velxgridb
   rotpointadjb(3) = rotpointadjb(3) + derivrotationmatrixadj(1, 3)*&
   &        velxgridb
   rotcenteradjb = rotcenteradjb + offsetvectorb
   pointrefadjb = pointrefadjb - offsetvectorb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   alphaadjb = 0.0
   betaadjb = 0.0
   ELSE
   rotratetransb(1:3, 1:3) = 0.0
   rotratetempb(1:3) = 0.0
   DO i=3,1,-1
   DO j=3,1,-1
   rotratetempb(j) = rotratetempb(j) + rotratetrans(i, j)*&
   &              rotrateadjb(i)
   rotratetransb(i, j) = rotratetransb(i, j) + rotratetemp(j)*&
   &              rotrateadjb(i)
   END DO
   END DO
   rotrateadjb(1:3) = 0.0
   rotrateadjb = rotratetempb
   alphab = -(SIN(alpha)*rotratetransb(3, 3))
   rotratetransb(3, 3) = 0.0
   alphab = alphab - SIN(beta)*COS(alpha)*rotratetransb(3, 2)
   betab = -(SIN(alpha)*COS(beta)*rotratetransb(3, 2))
   rotratetransb(3, 2) = 0.0
   alphab = alphab + COS(beta)*COS(alpha)*rotratetransb(3, 1)
   betab = betab - SIN(alpha)*SIN(beta)*rotratetransb(3, 1)
   rotratetransb(3, 1) = 0.0
   rotratetransb(2, 3) = 0.0
   betab = betab - SIN(beta)*rotratetransb(2, 2)
   rotratetransb(2, 2) = 0.0
   betab = betab + COS(beta)*rotratetransb(2, 1)
   rotratetransb(2, 1) = 0.0
   alphab = alphab - COS(alpha)*rotratetransb(1, 3)
   rotratetransb(1, 3) = 0.0
   alphab = alphab + SIN(beta)*SIN(alpha)*rotratetransb(1, 2)
   betab = betab - COS(alpha)*COS(beta)*rotratetransb(1, 2)
   rotratetransb(1, 2) = 0.0
   alphab = alphab - COS(beta)*SIN(alpha)*rotratetransb(1, 1)
   betab = betab - COS(alpha)*SIN(beta)*rotratetransb(1, 1)
   betaadjb = betab
   alphaadjb = alphab
   END IF
   END IF
   ELSE
   rotrateadjb(1:3) = 0.0
   alphaadjb = 0.0
   rotpointadjb(1:3) = 0.0
   betaadjb = 0.0
   rotcenteradjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   rotationpointadjb(1:3) = 0.0
   velygrid0b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 3) THEN
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   machgridadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   ELSE
   velygrid0b = velygrid0b + rotationmatrixadj(3, 2)*velzgrid0b
   velxgrid0b = velxgrid0b + rotationmatrixadj(2, 1)*velygrid0b + &
   &          rotationmatrixadj(3, 1)*velzgrid0b
   velzgrid0b = rotationmatrixadj(1, 3)*velxgrid0b + &
   &          rotationmatrixadj(2, 3)*velygrid0b + rotationmatrixadj(3, 3)*&
   &          velzgrid0b
   velygrid0b = rotationmatrixadj(1, 2)*velxgrid0b + &
   &          rotationmatrixadj(2, 2)*velygrid0b
   velxgrid0b = rotationmatrixadj(1, 1)*velxgrid0b
   CALL ROTMATRIXRIGIDBODYFORCESADJ_B(tnew, told, rotationmatrixadj&
   &                                     , rotationpointadj, &
   &                                     rotationpointadjb, rotpointadj, &
   &                                     rotpointadjb)
   machgridadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   END IF
   ELSE
   veldirb(1:3) = 0.0
   machgridadjb = -(ainf*veldir(1)*velxgrid0b) - ainf*veldir(2)*&
   &        velygrid0b - ainf*veldir(3)*velzgrid0b
   veldirb(3) = -(ainf*machgridadj*velzgrid0b)
   veldirb(2) = veldirb(2) - ainf*machgridadj*velygrid0b
   veldirb(1) = veldirb(1) - ainf*machgridadj*velxgrid0b
   liftdirb(:) = 0.0
   alphatsb = 0.0
   CALL ADJUSTINFLOWANGLEFORCESADJ_B(alphats, alphatsb, betaadj, &
   &                                  betaadjb, veldir, veldirb, liftdir, &
   &                                  liftdirb, dragdir, liftindex)
   alphaadjb = alphaadjb + alphatsb
   veldirfreestreamadjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   velygrid0b = 0.0
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .LT. 4) THEN
   veldirb(1:3) = 0.0
   machgridadjb = -(ainf*veldir(1)*velxgrid0b) - ainf*veldir(2)*&
   &        velygrid0b - ainf*veldir(3)*velzgrid0b
   veldirb(3) = -(ainf*machgridadj*velzgrid0b)
   veldirb(2) = veldirb(2) - ainf*machgridadj*velygrid0b
   veldirb(1) = veldirb(1) - ainf*machgridadj*velxgrid0b
   liftdirb(:) = 0.0
   betatsb = 0.0
   CALL ADJUSTINFLOWANGLEFORCESADJ_B(alphaadj, alphaadjb, betats, &
   &                                  betatsb, veldir, veldirb, liftdir, &
   &                                  liftdirb, dragdir, liftindex)
   betaadjb = betaadjb + betatsb
   veldirfreestreamadjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   velygrid0b = 0.0
   ELSE
   veldirfreestreamadjb(1:3) = 0.0
   machgridadjb = -(ainf*veldirfreestreamadj(1)*velxgrid0b) - ainf*&
   &        veldirfreestreamadj(2)*velygrid0b - ainf*veldirfreestreamadj(3)&
   &        *velzgrid0b
   veldirfreestreamadjb(3) = -(ainf*(intervalmach+machgridadj)*&
   &        velzgrid0b)
   veldirfreestreamadjb(2) = veldirfreestreamadjb(2) - ainf*(&
   &        intervalmach+machgridadj)*velygrid0b
   veldirfreestreamadjb(1) = veldirfreestreamadjb(1) - ainf*(&
   &        intervalmach+machgridadj)*velxgrid0b
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   velygrid0b = 0.0
   END IF
   ELSE
   machgridadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   END IF
   CALL DERIVATIVEROTMATRIXRIGIDFORCESADJ_B(derivrotationmatrixadj, &
   &                                     rotationpointadj, &
   &                                     rotationpointadjb, rotpointadj, &
   &                                     rotpointadjb, t(1))
   machgridadjb = machgridadjb - ainf*veldirfreestreamadj(1)*velxgrid0b -&
   &   ainf*veldirfreestreamadj(2)*velygrid0b - ainf*veldirfreestreamadj(3)&
   &    *velzgrid0b
   veldirfreestreamadjb(3) = veldirfreestreamadjb(3) - ainf*machgridadj*&
   &    velzgrid0b
   veldirfreestreamadjb(2) = veldirfreestreamadjb(2) - ainf*machgridadj*&
   &    velygrid0b
   veldirfreestreamadjb(1) = veldirfreestreamadjb(1) - ainf*machgridadj*&
   &    velxgrid0b
  
   END SUBROUTINE GRIDVELOCITIESFINELEVELFORCESADJ_B
