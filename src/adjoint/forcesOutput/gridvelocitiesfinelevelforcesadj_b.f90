!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of gridvelocitiesfinelevelforcesadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: rotrateadj xadj
!                machgridadj veldirfreestreamadj sincoeffouralpha
!                coscoeffouryrot sincoeffourbeta coscoeffourxrot
!                coefpolmach coefpolzrot omegafourmach omegafouralpha
!                omegafourzrot coefpolyrot omegafouryrot coefpolxrot
!                coefpolalpha sincoeffourmach omegafourxrot sincoeffourzrot
!                coscoeffourbeta rotpoint sincoeffouryrot sincoeffourxrot
!                coscoeffouralpha coefpolbeta omegafourbeta coscoeffourmach
!                coscoeffourzrot
!   of linear combination of output variables: xadj sadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          gridVelocitiesFineLevelForcesAdj.f90            *
!      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
!      * Starting date: 02-23-2004                                      *
!      * Last modified: 10-22-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE GRIDVELOCITIESFINELEVELFORCESADJ_B(useoldcoor, t, sps, xadj, &
&  xadjb, sadj, sadjb, iibeg, iiend, jjbeg, jjend, i2beg, i2end, j2beg, &
&  j2end, mm, sfaceiadj, sfacejadj, sfacekadj, machgridadj, machgridadjb&
&  , veldirfreestreamadj, veldirfreestreamadjb, rotcenteradj, rotrateadj&
&  , rotrateadjb, siadj, sjadj, skadj)
  USE bctypes
  USE blockpointers
  USE cgnsgrid
  USE flowvarrefstate
  USE inputmotion
  USE inputtimespectral
  USE inputtsstabderiv
  USE inputunsteady
  USE iteration
  IMPLICIT NONE
!           enddo loopDirection
!      enddo domains
! print *,'finished grid velocities'
  INTEGER(KIND=INTTYPE) :: i2beg, i2end, j2beg, j2end
  INTEGER(KIND=INTTYPE) :: iibeg, iiend, jjbeg, jjend
  REAL(KIND=REALTYPE), INTENT(IN) :: machgridadj
  REAL(KIND=REALTYPE) :: machgridadjb
  INTEGER(KIND=INTTYPE) :: mm
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotcenteradj
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotrateadj
  REAL(KIND=REALTYPE) :: rotrateadjb(3)
  REAL(KIND=REALTYPE) :: sadj(0:ie, 0:je, 0:ke, 3), sadjb(0:ie, 0:je, 0:&
&  ke, 3)
  REAL(KIND=REALTYPE) :: sfaceiadj(2, iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: sfacejadj(iibeg:iiend, 2, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: sfacekadj(iibeg:iiend, jjbeg:jjend, 2)
  REAL(KIND=REALTYPE), DIMENSION(2, iibeg:iiend, jjbeg:jjend, 3)&
&  , INTENT(IN) :: siadj
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, 2, jjbeg:jjend, 3)&
&  , INTENT(IN) :: sjadj
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 2, 3)&
&  , INTENT(IN) :: skadj
  INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
  REAL(KIND=REALTYPE), DIMENSION(*), INTENT(IN) :: t
  LOGICAL, INTENT(IN) :: useoldcoor
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: veldirfreestreamadj
  REAL(KIND=REALTYPE) :: veldirfreestreamadjb(3)
  REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3), INTENT(IN) :: &
&  xadj
  REAL(KIND=REALTYPE) :: xadjb(0:ie, 0:je, 0:ke, 3)
  REAL(KIND=REALTYPE) :: alpha, alphab, beta, betab
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: dragdir(3), liftdir(3), liftdirb(3), veldir(3)&
&  , veldirb(3)
  INTEGER(KIND=INTTYPE) :: i, ii, iie, j, jje, k, kke
  INTEGER(KIND=INTTYPE) :: liftindex
  INTEGER(KIND=INTTYPE) :: nn
  REAL(KIND=REALTYPE) :: oneover4dt, oneover8dt
  REAL(KIND=REALTYPE) :: derivrotationmatrixadj(3, 3), rotationmatrixadj&
&  (3, 3)
  REAL(KIND=REALTYPE) :: rotationpointadj(3), rotpointadj(3)
  REAL(KIND=REALTYPE) :: sfaceadj(iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: ssadj(iibeg:iiend, jjbeg:jjend, 3)
  REAL :: timeunsteady
  REAL :: timeunsteadyrestart
  REAL(KIND=REALTYPE) :: intervalmach, tnew, told
  REAL(KIND=REALTYPE) :: TSALPHA
  REAL(KIND=REALTYPE) :: TSBETA
  REAL(KIND=REALTYPE) :: TSMACH
  REAL(KIND=REALTYPE) :: ainf, velxgrid, velxgridb, velygrid, velygridb&
&  , velzgrid, velzgridb
  REAL(KIND=REALTYPE) :: velxgrid0, velxgrid0b, velygrid0, velygrid0b, &
&  velzgrid0, velzgrid0b
  REAL(KIND=REALTYPE) :: sc(3), scb(3), tempb, tempb0, tempb1, xc(3), &
&  xcb(3), xxc(3), xxcb(3)
  REAL(KIND=REALTYPE) :: xxadj(iibeg-1:iiend, jjbeg-1:jjend, 3)
  INTRINSIC SQRT
  EXTERNAL TERMINATE
!
!      ******************************************************************
!      *                                                                *
!      * gridVelocitiesFineLevel computes the grid velocities for       *
!      * the cell centers and the normal grid velocities for the faces  *
!      * of moving blocks for the currently finest grid, i.e.           *
!      * groundLevel. The velocities are computed at time t for         *
!      * spectral mode sps. If useOldCoor is .true. the velocities      *
!      * are determined using the unsteady time integrator in           *
!      * combination with the old coordinates; otherwise the analytic   *
!      * form is used.                                                  *
!      *                                                                *
!      ******************************************************************
!
!imin,imax,etc.
!nTimeIntervalsSpectral
!Timeunsteady, timeunsteadyrestart
!
!      Subroutine arguments.
!
!
!      Local variables.
!
!function definitions
!real(kind=realType), dimension(:,:), pointer :: sFace
!       real(kind=realType), dimension(:,:,:),   pointer :: xx, ss
!       real(kind=realType), dimension(:,:,:,:), pointer :: xxOld
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Compute the mesh velocity from the given mesh Mach number.
!print *,'in gridvelocities',mm
!  aInf = sqrt(gammaInf*pInf/rhoInf)
!  velxGrid = aInf*MachGrid(1)
!  velyGrid = aInf*MachGrid(2)
!  velzGrid = aInf*MachGrid(3)
! velxGrid = zero
! velyGrid = zero
! velzGrid = zero
  ainf = SQRT(gammainf*pinf/rhoinf)
! Compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. It is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
!this may need to be modified later...(perhaps put in copy stencil?)
  CALL DERIVATIVEROTMATRIXRIGIDFORCESADJ(derivrotationmatrixadj, &
&                                   rotationpointadj, rotpointadj, t(1))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
  IF (tsstability) THEN
! Determine the time values of the old and new time level.
! It is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
    tnew = timeunsteady + timeunsteadyrestart
    told = tnew - t(1)
!print *,'Time',t(1)
    IF (tspmode .OR. tsqmode .OR. tsrmode) THEN
! Compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
      CALL ROTMATRIXRIGIDBODYFORCESADJ(tnew, told, rotationmatrixadj, &
&                                 rotationpointadj)
      CALL PUSHINTEGER4(1)
    ELSE IF (tsalphamode) THEN
! get the baseline alpha and determine the liftIndex
      CALL GETDIRANGLEFORCES(veldirfreestreamadj, liftdir, liftindex, &
&                       alpha, beta)
!Determine the alpha for this time instance
      alpha = TSALPHA(degreepolalpha, coefpolalpha, degreefouralpha, &
&        omegafouralpha, coscoeffouralpha, sincoeffouralpha, t(1))
      CALL PUSHREAL8ARRAY(liftdir, 3)
!Determine the grid velocity for this alpha
      CALL ADJUSTINFLOWANGLEFORCESADJ(alpha, beta, veldir, liftdir, &
&                                dragdir, liftindex)
!do I need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
      CALL PUSHINTEGER4(2)
    ELSE IF (tsbetamode) THEN
! get the baseline alpha and determine the liftIndex
      CALL GETDIRANGLEFORCES(veldirfreestreamadj, liftdir, liftindex, &
&                       alpha, beta)
!Determine the alpha for this time instance
      alpha = TSBETA(degreepolbeta, coefpolbeta, degreefourbeta, &
&        omegafourbeta, coscoeffourbeta, sincoeffourbeta, t(1))
      CALL PUSHREAL8ARRAY(liftdir, 3)
!Determine the grid velocity for this alpha
      CALL ADJUSTINFLOWANGLEFORCESADJ(alpha, beta, veldir, liftdir, &
&                                dragdir, liftindex)
!do I need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
      CALL PUSHINTEGER4(3)
    ELSE IF (tsmachmode) THEN
!determine the mach number at this time interval
      intervalmach = TSMACH(degreepolmach, coefpolmach, degreefourmach, &
&        omegafourmach, coscoeffourmach, sincoeffourmach, t(1))
!set the effective grid velocity
      CALL PUSHINTEGER4(4)
    ELSE
      CALL PUSHINTEGER4(5)
    END IF
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
!moved outside
!!$       ! Loop over the number of local blocks.
!!$
!!$       domains: do nn=1,nDom
!!$
!!$         ! Set the pointers for this block.
!!$
!!$         call setPointers(nn, groundLevel, sps)
! Check for a moving block.
  IF (blockismoving) THEN
! Determine the situation we are having here.
    IF (useoldcoor) THEN
      rotrateadjb(1:3) = 0.0
      velxgrid0b = 0.0
      velzgrid0b = 0.0
      velygrid0b = 0.0
    ELSE
!
!            ************************************************************
!            *                                                          *
!            * Grid velocities of the cell centers, including the       *
!            * 1st level halo cells.                                    *
!            *                                                          *
!            ************************************************************
!
! Loop over the cells, including the 1st level halo's.
! print *,'calculating grid velocities',ie,je,ke,shape(xadj)
      DO k=1,ke
        DO j=1,je
          DO i=1,ie
! Determine the coordinates of the cell center,
! which are stored in xc.
            xc(1) = eighth*(xadj(i-1, j-1, k-1, 1)+xadj(i, j-1, k-1, 1)+&
&              xadj(i-1, j, k-1, 1)+xadj(i, j, k-1, 1)+xadj(i-1, j-1, k&
&              , 1)+xadj(i, j-1, k, 1)+xadj(i-1, j, k, 1)+xadj(i, j, k, &
&              1))
            xc(2) = eighth*(xadj(i-1, j-1, k-1, 2)+xadj(i, j-1, k-1, 2)+&
&              xadj(i-1, j, k-1, 2)+xadj(i, j, k-1, 2)+xadj(i-1, j-1, k&
&              , 2)+xadj(i, j-1, k, 2)+xadj(i-1, j, k, 2)+xadj(i, j, k, &
&              2))
            xc(3) = eighth*(xadj(i-1, j-1, k-1, 3)+xadj(i, j-1, k-1, 3)+&
&              xadj(i-1, j, k-1, 3)+xadj(i, j, k-1, 3)+xadj(i-1, j-1, k&
&              , 3)+xadj(i, j-1, k, 3)+xadj(i-1, j, k, 3)+xadj(i, j, k, &
&              3))
            CALL PUSHREAL8(xxc(1))
! Determine the coordinates relative to the
! center of rotation.
            xxc(1) = xc(1) - rotcenteradj(1)
            CALL PUSHREAL8(xxc(2))
            xxc(2) = xc(2) - rotcenteradj(2)
            CALL PUSHREAL8(xxc(3))
            xxc(3) = xc(3) - rotcenteradj(3)
            CALL PUSHREAL8(xxc(1))
! Determine the rotation speed of the cell center,
! which is omega*r.
! Determine the coordinates relative to the
! rigid body rotation point.
            xxc(1) = xc(1) - rotationpointadj(1)
            CALL PUSHREAL8(xxc(2))
            xxc(2) = xc(2) - rotationpointadj(2)
            CALL PUSHREAL8(xxc(3))
            xxc(3) = xc(3) - rotationpointadj(3)
! Determine the total velocity of the cell center.
! This is a combination of rotation speed of this
! block and the entire rigid body rotation.
          END DO
        END DO
      END DO
      rotrateadjb(1:3) = 0.0
      velygridb = 0.0
      xcb(1:3) = 0.0
      xxcb(1:3) = 0.0
      velzgridb = 0.0
      scb(1:3) = 0.0
      velxgridb = 0.0
      DO k=ke,1,-1
        DO j=je,1,-1
          DO i=ie,1,-1
            scb(3) = scb(3) + sadjb(i, j, k, 3)
            velzgridb = velzgridb + sadjb(i, j, k, 3)
            xxcb(1) = xxcb(1) + derivrotationmatrixadj(3, 1)*sadjb(i, j&
&              , k, 3)
            xxcb(2) = xxcb(2) + derivrotationmatrixadj(3, 2)*sadjb(i, j&
&              , k, 3)
            xxcb(3) = xxcb(3) + derivrotationmatrixadj(3, 3)*sadjb(i, j&
&              , k, 3)
            sadjb(i, j, k, 3) = 0.0
            scb(2) = scb(2) + sadjb(i, j, k, 2)
            velygridb = velygridb + sadjb(i, j, k, 2)
            xxcb(1) = xxcb(1) + derivrotationmatrixadj(2, 1)*sadjb(i, j&
&              , k, 2)
            xxcb(2) = xxcb(2) + derivrotationmatrixadj(2, 2)*sadjb(i, j&
&              , k, 2)
            xxcb(3) = xxcb(3) + derivrotationmatrixadj(2, 3)*sadjb(i, j&
&              , k, 2)
            sadjb(i, j, k, 2) = 0.0
            scb(1) = scb(1) + sadjb(i, j, k, 1)
            velxgridb = velxgridb + sadjb(i, j, k, 1)
            xxcb(1) = xxcb(1) + derivrotationmatrixadj(1, 1)*sadjb(i, j&
&              , k, 1)
            xxcb(2) = xxcb(2) + derivrotationmatrixadj(1, 2)*sadjb(i, j&
&              , k, 1)
            xxcb(3) = xxcb(3) + derivrotationmatrixadj(1, 3)*sadjb(i, j&
&              , k, 1)
            sadjb(i, j, k, 1) = 0.0
            CALL POPREAL8(xxc(3))
            xcb(3) = xcb(3) + xxcb(3)
            xxcb(3) = 0.0
            CALL POPREAL8(xxc(2))
            xcb(2) = xcb(2) + xxcb(2)
            xxcb(2) = 0.0
            CALL POPREAL8(xxc(1))
            xcb(1) = xcb(1) + xxcb(1)
            xxcb(1) = 0.0
            rotrateadjb(1) = rotrateadjb(1) + xxc(2)*scb(3)
            xxcb(2) = xxcb(2) + rotrateadj(1)*scb(3)
            rotrateadjb(2) = rotrateadjb(2) - xxc(1)*scb(3)
            xxcb(1) = xxcb(1) - rotrateadj(2)*scb(3)
            scb(3) = 0.0
            rotrateadjb(3) = rotrateadjb(3) + xxc(1)*scb(2)
            xxcb(1) = xxcb(1) + rotrateadj(3)*scb(2)
            rotrateadjb(1) = rotrateadjb(1) - xxc(3)*scb(2)
            xxcb(3) = xxcb(3) - rotrateadj(1)*scb(2)
            scb(2) = 0.0
            rotrateadjb(2) = rotrateadjb(2) + xxc(3)*scb(1)
            xxcb(3) = xxcb(3) + rotrateadj(2)*scb(1)
            rotrateadjb(3) = rotrateadjb(3) - xxc(2)*scb(1)
            xxcb(2) = xxcb(2) - rotrateadj(3)*scb(1)
            scb(1) = 0.0
            CALL POPREAL8(xxc(3))
            xcb(3) = xcb(3) + xxcb(3)
            xxcb(3) = 0.0
            CALL POPREAL8(xxc(2))
            xcb(2) = xcb(2) + xxcb(2)
            xxcb(2) = 0.0
            CALL POPREAL8(xxc(1))
            xcb(1) = xcb(1) + xxcb(1)
            xxcb(1) = 0.0
            tempb = eighth*xcb(3)
            xadjb(i-1, j-1, k-1, 3) = xadjb(i-1, j-1, k-1, 3) + tempb
            xadjb(i, j-1, k-1, 3) = xadjb(i, j-1, k-1, 3) + tempb
            xadjb(i-1, j, k-1, 3) = xadjb(i-1, j, k-1, 3) + tempb
            xadjb(i, j, k-1, 3) = xadjb(i, j, k-1, 3) + tempb
            xadjb(i-1, j-1, k, 3) = xadjb(i-1, j-1, k, 3) + tempb
            xadjb(i, j-1, k, 3) = xadjb(i, j-1, k, 3) + tempb
            xadjb(i-1, j, k, 3) = xadjb(i-1, j, k, 3) + tempb
            xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + tempb
            xcb(3) = 0.0
            tempb0 = eighth*xcb(2)
            xadjb(i-1, j-1, k-1, 2) = xadjb(i-1, j-1, k-1, 2) + tempb0
            xadjb(i, j-1, k-1, 2) = xadjb(i, j-1, k-1, 2) + tempb0
            xadjb(i-1, j, k-1, 2) = xadjb(i-1, j, k-1, 2) + tempb0
            xadjb(i, j, k-1, 2) = xadjb(i, j, k-1, 2) + tempb0
            xadjb(i-1, j-1, k, 2) = xadjb(i-1, j-1, k, 2) + tempb0
            xadjb(i, j-1, k, 2) = xadjb(i, j-1, k, 2) + tempb0
            xadjb(i-1, j, k, 2) = xadjb(i-1, j, k, 2) + tempb0
            xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + tempb0
            xcb(2) = 0.0
            tempb1 = eighth*xcb(1)
            xadjb(i-1, j-1, k-1, 1) = xadjb(i-1, j-1, k-1, 1) + tempb1
            xadjb(i, j-1, k-1, 1) = xadjb(i, j-1, k-1, 1) + tempb1
            xadjb(i-1, j, k-1, 1) = xadjb(i-1, j, k-1, 1) + tempb1
            xadjb(i, j, k-1, 1) = xadjb(i, j, k-1, 1) + tempb1
            xadjb(i-1, j-1, k, 1) = xadjb(i-1, j-1, k, 1) + tempb1
            xadjb(i, j-1, k, 1) = xadjb(i, j-1, k, 1) + tempb1
            xadjb(i-1, j, k, 1) = xadjb(i-1, j, k, 1) + tempb1
            xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + tempb1
            xcb(1) = 0.0
          END DO
        END DO
      END DO
      velzgrid0b = velzgridb
      rotrateadjb(1) = rotrateadjb(1) + rotcenteradj(2)*velzgridb
      rotrateadjb(2) = rotrateadjb(2) - rotcenteradj(1)*velzgridb
      velygrid0b = velygridb
      rotrateadjb(3) = rotrateadjb(3) + rotcenteradj(1)*velygridb
      rotrateadjb(1) = rotrateadjb(1) - rotcenteradj(3)*velygridb
      velxgrid0b = velxgridb
      rotrateadjb(2) = rotrateadjb(2) + rotcenteradj(3)*velxgridb
      rotrateadjb(3) = rotrateadjb(3) - rotcenteradj(2)*velxgridb
    END IF
  ELSE
    rotrateadjb(1:3) = 0.0
    velxgrid0b = 0.0
    velzgrid0b = 0.0
    velygrid0b = 0.0
  END IF
  CALL POPINTEGER4(branch)
  IF (branch .LT. 3) THEN
    IF (branch .LT. 2) THEN
      IF (branch .LT. 1) THEN
        machgridadjb = 0.0
        veldirfreestreamadjb(1:3) = 0.0
      ELSE
        velygrid0b = velygrid0b + rotationmatrixadj(3, 2)*velzgrid0b
        velxgrid0b = velxgrid0b + rotationmatrixadj(2, 1)*velygrid0b + &
&          rotationmatrixadj(3, 1)*velzgrid0b
        velzgrid0b = rotationmatrixadj(1, 3)*velxgrid0b + &
&          rotationmatrixadj(2, 3)*velygrid0b + rotationmatrixadj(3, 3)*&
&          velzgrid0b
        velygrid0b = rotationmatrixadj(1, 2)*velxgrid0b + &
&          rotationmatrixadj(2, 2)*velygrid0b
        velxgrid0b = rotationmatrixadj(1, 1)*velxgrid0b
        machgridadjb = 0.0
        veldirfreestreamadjb(1:3) = 0.0
      END IF
    ELSE
      veldirb(1:3) = 0.0
      machgridadjb = -(ainf*veldir(1)*velxgrid0b) - ainf*veldir(2)*&
&        velygrid0b - ainf*veldir(3)*velzgrid0b
      veldirb(3) = -(ainf*machgridadj*velzgrid0b)
      veldirb(2) = veldirb(2) - ainf*machgridadj*velygrid0b
      veldirb(1) = veldirb(1) - ainf*machgridadj*velxgrid0b
      CALL POPREAL8ARRAY(liftdir, 3)
      liftdirb(:) = 0.0
      CALL ADJUSTINFLOWANGLEFORCESADJ_B(alpha, alphab, beta, betab, &
&                                  veldir, veldirb, liftdir, liftdirb, &
&                                  dragdir, liftindex)
      CALL GETDIRANGLEFORCES_B(veldirfreestreamadj, veldirfreestreamadjb&
&                         , liftdir, liftindex, alpha, beta, betab)
      velxgrid0b = 0.0
      velzgrid0b = 0.0
      velygrid0b = 0.0
    END IF
  ELSE IF (branch .LT. 5) THEN
    IF (branch .LT. 4) THEN
      veldirb(1:3) = 0.0
      machgridadjb = -(ainf*veldir(1)*velxgrid0b) - ainf*veldir(2)*&
&        velygrid0b - ainf*veldir(3)*velzgrid0b
      veldirb(3) = -(ainf*machgridadj*velzgrid0b)
      veldirb(2) = veldirb(2) - ainf*machgridadj*velygrid0b
      veldirb(1) = veldirb(1) - ainf*machgridadj*velxgrid0b
      CALL POPREAL8ARRAY(liftdir, 3)
      liftdirb(:) = 0.0
      CALL ADJUSTINFLOWANGLEFORCESADJ_B(alpha, alphab, beta, betab, &
&                                  veldir, veldirb, liftdir, liftdirb, &
&                                  dragdir, liftindex)
      CALL GETDIRANGLEFORCES_B(veldirfreestreamadj, veldirfreestreamadjb&
&                         , liftdir, liftindex, alpha, beta, betab)
      velxgrid0b = 0.0
      velzgrid0b = 0.0
      velygrid0b = 0.0
    ELSE
      veldirfreestreamadjb(1:3) = 0.0
      machgridadjb = -(ainf*veldirfreestreamadj(1)*velxgrid0b) - ainf*&
&        veldirfreestreamadj(2)*velygrid0b - ainf*veldirfreestreamadj(3)&
&        *velzgrid0b
      veldirfreestreamadjb(3) = -(ainf*(intervalmach+machgridadj)*&
&        velzgrid0b)
      veldirfreestreamadjb(2) = veldirfreestreamadjb(2) - ainf*(&
&        intervalmach+machgridadj)*velygrid0b
      veldirfreestreamadjb(1) = veldirfreestreamadjb(1) - ainf*(&
&        intervalmach+machgridadj)*velxgrid0b
      velxgrid0b = 0.0
      velzgrid0b = 0.0
      velygrid0b = 0.0
    END IF
  ELSE
    machgridadjb = 0.0
    veldirfreestreamadjb(1:3) = 0.0
  END IF
  machgridadjb = machgridadjb - ainf*veldirfreestreamadj(1)*velxgrid0b -&
&   ainf*veldirfreestreamadj(2)*velygrid0b - ainf*veldirfreestreamadj(3)&
&    *velzgrid0b
  veldirfreestreamadjb(3) = veldirfreestreamadjb(3) - ainf*machgridadj*&
&    velzgrid0b
  veldirfreestreamadjb(2) = veldirfreestreamadjb(2) - ainf*machgridadj*&
&    velygrid0b
  veldirfreestreamadjb(1) = veldirfreestreamadjb(1) - ainf*machgridadj*&
&    velxgrid0b
!  coscoeffourzrotb(:) = 0.0
!  coscoeffourmachb(:) = 0.0
!  omegafourbetab = 0.0
!  coefpolbetab(:) = 0.0
!  coscoeffouralphab(:) = 0.0
!  sincoeffourxrotb(:) = 0.0
!  sincoeffouryrotb(:) = 0.0
!  rotpointb(1:3) = 0.0
!  coscoeffourbetab(:) = 0.0
!  sincoeffourzrotb(:) = 0.0
!  omegafourxrotb = 0.0
!  sincoeffourmachb(:) = 0.0
!  coefpolalphab(:) = 0.0
!  coefpolxrotb(:) = 0.0
!  omegafouryrotb = 0.0
!  coefpolyrotb(:) = 0.0
!  omegafourzrotb = 0.0
!  omegafouralphab = 0.0
!  omegafourmachb = 0.0
!  coefpolzrotb(:) = 0.0
!  coefpolmachb(:) = 0.0
!  coscoeffourxrotb(:) = 0.0
!  sincoeffourbetab(:) = 0.0
!  coscoeffouryrotb(:) = 0.0
!  sincoeffouralphab(:) = 0.0
END SUBROUTINE GRIDVELOCITIESFINELEVELFORCESADJ_B
