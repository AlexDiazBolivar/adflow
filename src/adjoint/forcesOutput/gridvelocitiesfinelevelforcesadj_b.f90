!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of gridvelocitiesfinelevelforcesadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: rotrateadj xadj
!                veldirfreestreamadj coscoeffouryrot coscoeffourxrot
!                coefpolzrot omegafourzrot coefpolyrot omegafouryrot
!                coefpolxrot omegafourxrot sincoeffourzrot sincoeffouryrot
!                sincoeffourxrot coscoeffourzrot
!   of linear combination of output variables: xadj sadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          gridVelocitiesFineLevelForcesAdj.f90            *
!      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
!      * Starting date: 02-23-2004                                      *
!      * Last modified: 10-22-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE GRIDVELOCITIESFINELEVELFORCESADJ_B(useoldcoor, t, sps, xadj, &
&  xadjb, sadj, sadjb, iibeg, iiend, jjbeg, jjend, i2beg, i2end, j2beg, &
&  j2end, mm, sfaceiadj, sfacejadj, sfacekadj, machgridadj, &
&  veldirfreestreamadj, veldirfreestreamadjb, rotcenteradj, rotrateadj, &
&  rotrateadjb, siadj, sjadj, skadj)
  USE bctypes
  USE blockpointers
  USE cgnsgrid
  USE flowvarrefstate
  USE inputmotion
  USE inputunsteady
  USE iteration
  IMPLICIT NONE
!           enddo loopDirection
!      enddo domains
! print *,'finished grid velocities'
  INTEGER(KIND=INTTYPE) :: i2beg, i2end, j2beg, j2end
  INTEGER(KIND=INTTYPE) :: iibeg, iiend, jjbeg, jjend
  REAL(KIND=REALTYPE), INTENT(IN) :: machgridadj
  INTEGER(KIND=INTTYPE) :: mm
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotcenteradj
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotrateadj
  REAL(KIND=REALTYPE) :: rotrateadjb(3)
  REAL(KIND=REALTYPE) :: sadj(0:ie, 0:je, 0:ke, 3), sadjb(0:ie, 0:je, 0:&
&  ke, 3)
  REAL(KIND=REALTYPE) :: sfaceiadj(2, iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: sfacejadj(iibeg:iiend, 2, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: sfacekadj(iibeg:iiend, jjbeg:jjend, 2)
  REAL(KIND=REALTYPE), DIMENSION(2, iibeg:iiend, jjbeg:jjend, 3)&
&  , INTENT(IN) :: siadj
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, 2, jjbeg:jjend, 3)&
&  , INTENT(IN) :: sjadj
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 2, 3)&
&  , INTENT(IN) :: skadj
  INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
  REAL(KIND=REALTYPE), DIMENSION(*), INTENT(IN) :: t
  LOGICAL, INTENT(IN) :: useoldcoor
  REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: veldirfreestreamadj
  REAL(KIND=REALTYPE) :: veldirfreestreamadjb(3)
  REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3), INTENT(IN) :: &
&  xadj
  REAL(KIND=REALTYPE) :: xadjb(0:ie, 0:je, 0:ke, 3)
  INTEGER(KIND=INTTYPE) :: i, ii, iie, j, jje, k, kke
  INTEGER(KIND=INTTYPE) :: nn
  REAL(KIND=REALTYPE) :: oneover4dt, oneover8dt
  REAL(KIND=REALTYPE) :: rotationmatrixadj(3, 3)
  REAL(KIND=REALTYPE) :: rotationpointadj(3), rotpointadj(3)
  REAL(KIND=REALTYPE) :: sfaceadj(iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: ssadj(iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: ainf, velxgrid, velxgridb, velygrid, velygridb&
&  , velzgrid, velzgridb
  REAL(KIND=REALTYPE) :: sc(3), scb(3), tempb, tempb0, tempb1, xc(3), &
&  xcb(3), xxc(3), xxcb(3)
  REAL(KIND=REALTYPE) :: xxadj(iibeg-1:iiend, jjbeg-1:jjend, 3)
  INTRINSIC SQRT
  EXTERNAL TERMINATE
!
!      ******************************************************************
!      *                                                                *
!      * gridVelocitiesFineLevel computes the grid velocities for       *
!      * the cell centers and the normal grid velocities for the faces  *
!      * of moving blocks for the currently finest grid, i.e.           *
!      * groundLevel. The velocities are computed at time t for         *
!      * spectral mode sps. If useOldCoor is .true. the velocities      *
!      * are determined using the unsteady time integrator in           *
!      * combination with the old coordinates; otherwise the analytic   *
!      * form is used.                                                  *
!      *                                                                *
!      ******************************************************************
!
!imin,imax,etc.
!
!      Subroutine arguments.
!
!
!      Local variables.
!
!real(kind=realType), dimension(:,:), pointer :: sFace
!       real(kind=realType), dimension(:,:,:),   pointer :: xx, ss
!       real(kind=realType), dimension(:,:,:,:), pointer :: xxOld
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Compute the mesh velocity from the given mesh Mach number.
!print *,'in gridvelocities',mm
!  aInf = sqrt(gammaInf*pInf/rhoInf)
!  velxGrid = aInf*MachGrid(1)
!  velyGrid = aInf*MachGrid(2)
!  velzGrid = aInf*MachGrid(3)
! velxGrid = zero
! velyGrid = zero
! velzGrid = zero
  ainf = SQRT(gammainf*pinf/rhoinf)
! Compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. It is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
  CALL DERIVATIVEROTMATRIXRIGIDFORCESADJ(rotationmatrixadj, &
&                                   rotationpointadj, rotpointadj, t(1))
!moved outside
!!$       ! Loop over the number of local blocks.
!!$
!!$       domains: do nn=1,nDom
!!$
!!$         ! Set the pointers for this block.
!!$
!!$         call setPointers(nn, groundLevel, sps)
! Check for a moving block.
  IF (blockismoving) THEN
! Determine the situation we are having here.
    IF (useoldcoor) THEN
      rotrateadjb(1:3) = 0.0
      velygridb = 0.0
      velzgridb = 0.0
      velxgridb = 0.0
    ELSE
!
!            ************************************************************
!            *                                                          *
!            * Grid velocities of the cell centers, including the       *
!            * 1st level halo cells.                                    *
!            *                                                          *
!            ************************************************************
!
! Loop over the cells, including the 1st level halo's.
! print *,'calculating grid velocities',ie,je,ke,shape(xadj)
      DO k=1,ke
        DO j=1,je
          DO i=1,ie
! Determine the coordinates of the cell center,
! which are stored in xc.
            xc(1) = eighth*(xadj(i-1, j-1, k-1, 1)+xadj(i, j-1, k-1, 1)+&
&              xadj(i-1, j, k-1, 1)+xadj(i, j, k-1, 1)+xadj(i-1, j-1, k&
&              , 1)+xadj(i, j-1, k, 1)+xadj(i-1, j, k, 1)+xadj(i, j, k, &
&              1))
            xc(2) = eighth*(xadj(i-1, j-1, k-1, 2)+xadj(i, j-1, k-1, 2)+&
&              xadj(i-1, j, k-1, 2)+xadj(i, j, k-1, 2)+xadj(i-1, j-1, k&
&              , 2)+xadj(i, j-1, k, 2)+xadj(i-1, j, k, 2)+xadj(i, j, k, &
&              2))
            xc(3) = eighth*(xadj(i-1, j-1, k-1, 3)+xadj(i, j-1, k-1, 3)+&
&              xadj(i-1, j, k-1, 3)+xadj(i, j, k-1, 3)+xadj(i-1, j-1, k&
&              , 3)+xadj(i, j-1, k, 3)+xadj(i-1, j, k, 3)+xadj(i, j, k, &
&              3))
            CALL PUSHREAL8(xxc(1))
! Determine the coordinates relative to the
! center of rotation.
            xxc(1) = xc(1) - rotcenteradj(1)
            CALL PUSHREAL8(xxc(2))
            xxc(2) = xc(2) - rotcenteradj(2)
            CALL PUSHREAL8(xxc(3))
            xxc(3) = xc(3) - rotcenteradj(3)
            CALL PUSHREAL8(xxc(1))
! Determine the rotation speed of the cell center,
! which is omega*r.
! Determine the coordinates relative to the
! rigid body rotation point.
            xxc(1) = xc(1) - rotationpointadj(1)
            CALL PUSHREAL8(xxc(2))
            xxc(2) = xc(2) - rotationpointadj(2)
            CALL PUSHREAL8(xxc(3))
            xxc(3) = xc(3) - rotationpointadj(3)
! Determine the total velocity of the cell center.
! This is a combination of rotation speed of this
! block and the entire rigid body rotation.
          END DO
        END DO
      END DO
      rotrateadjb(1:3) = 0.0
      velygridb = 0.0
      xcb(1:3) = 0.0
      xxcb(1:3) = 0.0
      velzgridb = 0.0
      scb(1:3) = 0.0
      velxgridb = 0.0
      DO k=ke,1,-1
        DO j=je,1,-1
          DO i=ie,1,-1
            scb(3) = scb(3) + sadjb(i, j, k, 3)
            velzgridb = velzgridb + sadjb(i, j, k, 3)
            xxcb(1) = xxcb(1) + rotationmatrixadj(3, 1)*sadjb(i, j, k, 3&
&              )
            xxcb(2) = xxcb(2) + rotationmatrixadj(3, 2)*sadjb(i, j, k, 3&
&              )
            xxcb(3) = xxcb(3) + rotationmatrixadj(3, 3)*sadjb(i, j, k, 3&
&              )
            sadjb(i, j, k, 3) = 0.0
            scb(2) = scb(2) + sadjb(i, j, k, 2)
            velygridb = velygridb + sadjb(i, j, k, 2)
            xxcb(1) = xxcb(1) + rotationmatrixadj(2, 1)*sadjb(i, j, k, 2&
&              )
            xxcb(2) = xxcb(2) + rotationmatrixadj(2, 2)*sadjb(i, j, k, 2&
&              )
            xxcb(3) = xxcb(3) + rotationmatrixadj(2, 3)*sadjb(i, j, k, 2&
&              )
            sadjb(i, j, k, 2) = 0.0
            scb(1) = scb(1) + sadjb(i, j, k, 1)
            velxgridb = velxgridb + sadjb(i, j, k, 1)
            xxcb(1) = xxcb(1) + rotationmatrixadj(1, 1)*sadjb(i, j, k, 1&
&              )
            xxcb(2) = xxcb(2) + rotationmatrixadj(1, 2)*sadjb(i, j, k, 1&
&              )
            xxcb(3) = xxcb(3) + rotationmatrixadj(1, 3)*sadjb(i, j, k, 1&
&              )
            sadjb(i, j, k, 1) = 0.0
            CALL POPREAL8(xxc(3))
            xcb(3) = xcb(3) + xxcb(3)
            xxcb(3) = 0.0
            CALL POPREAL8(xxc(2))
            xcb(2) = xcb(2) + xxcb(2)
            xxcb(2) = 0.0
            CALL POPREAL8(xxc(1))
            xcb(1) = xcb(1) + xxcb(1)
            xxcb(1) = 0.0
            rotrateadjb(1) = rotrateadjb(1) + xxc(2)*scb(3)
            xxcb(2) = xxcb(2) + rotrateadj(1)*scb(3)
            rotrateadjb(2) = rotrateadjb(2) - xxc(1)*scb(3)
            xxcb(1) = xxcb(1) - rotrateadj(2)*scb(3)
            scb(3) = 0.0
            rotrateadjb(3) = rotrateadjb(3) + xxc(1)*scb(2)
            xxcb(1) = xxcb(1) + rotrateadj(3)*scb(2)
            rotrateadjb(1) = rotrateadjb(1) - xxc(3)*scb(2)
            xxcb(3) = xxcb(3) - rotrateadj(1)*scb(2)
            scb(2) = 0.0
            rotrateadjb(2) = rotrateadjb(2) + xxc(3)*scb(1)
            xxcb(3) = xxcb(3) + rotrateadj(2)*scb(1)
            rotrateadjb(3) = rotrateadjb(3) - xxc(2)*scb(1)
            xxcb(2) = xxcb(2) - rotrateadj(3)*scb(1)
            scb(1) = 0.0
            CALL POPREAL8(xxc(3))
            xcb(3) = xcb(3) + xxcb(3)
            xxcb(3) = 0.0
            CALL POPREAL8(xxc(2))
            xcb(2) = xcb(2) + xxcb(2)
            xxcb(2) = 0.0
            CALL POPREAL8(xxc(1))
            xcb(1) = xcb(1) + xxcb(1)
            xxcb(1) = 0.0
            tempb = eighth*xcb(3)
            xadjb(i-1, j-1, k-1, 3) = xadjb(i-1, j-1, k-1, 3) + tempb
            xadjb(i, j-1, k-1, 3) = xadjb(i, j-1, k-1, 3) + tempb
            xadjb(i-1, j, k-1, 3) = xadjb(i-1, j, k-1, 3) + tempb
            xadjb(i, j, k-1, 3) = xadjb(i, j, k-1, 3) + tempb
            xadjb(i-1, j-1, k, 3) = xadjb(i-1, j-1, k, 3) + tempb
            xadjb(i, j-1, k, 3) = xadjb(i, j-1, k, 3) + tempb
            xadjb(i-1, j, k, 3) = xadjb(i-1, j, k, 3) + tempb
            xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + tempb
            xcb(3) = 0.0
            tempb0 = eighth*xcb(2)
            xadjb(i-1, j-1, k-1, 2) = xadjb(i-1, j-1, k-1, 2) + tempb0
            xadjb(i, j-1, k-1, 2) = xadjb(i, j-1, k-1, 2) + tempb0
            xadjb(i-1, j, k-1, 2) = xadjb(i-1, j, k-1, 2) + tempb0
            xadjb(i, j, k-1, 2) = xadjb(i, j, k-1, 2) + tempb0
            xadjb(i-1, j-1, k, 2) = xadjb(i-1, j-1, k, 2) + tempb0
            xadjb(i, j-1, k, 2) = xadjb(i, j-1, k, 2) + tempb0
            xadjb(i-1, j, k, 2) = xadjb(i-1, j, k, 2) + tempb0
            xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + tempb0
            xcb(2) = 0.0
            tempb1 = eighth*xcb(1)
            xadjb(i-1, j-1, k-1, 1) = xadjb(i-1, j-1, k-1, 1) + tempb1
            xadjb(i, j-1, k-1, 1) = xadjb(i, j-1, k-1, 1) + tempb1
            xadjb(i-1, j, k-1, 1) = xadjb(i-1, j, k-1, 1) + tempb1
            xadjb(i, j, k-1, 1) = xadjb(i, j, k-1, 1) + tempb1
            xadjb(i-1, j-1, k, 1) = xadjb(i-1, j-1, k, 1) + tempb1
            xadjb(i, j-1, k, 1) = xadjb(i, j-1, k, 1) + tempb1
            xadjb(i-1, j, k, 1) = xadjb(i-1, j, k, 1) + tempb1
            xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + tempb1
            xcb(1) = 0.0
          END DO
        END DO
      END DO
      rotrateadjb(1) = rotrateadjb(1) + rotcenteradj(2)*velzgridb
      rotrateadjb(2) = rotrateadjb(2) - rotcenteradj(1)*velzgridb
      rotrateadjb(3) = rotrateadjb(3) + rotcenteradj(1)*velygridb
      rotrateadjb(1) = rotrateadjb(1) - rotcenteradj(3)*velygridb
      rotrateadjb(2) = rotrateadjb(2) + rotcenteradj(3)*velxgridb
      rotrateadjb(3) = rotrateadjb(3) - rotcenteradj(2)*velxgridb
    END IF
  ELSE
    rotrateadjb(1:3) = 0.0
    velygridb = 0.0
    velzgridb = 0.0
    velxgridb = 0.0
  END IF
  veldirfreestreamadjb(1:3) = 0.0
  veldirfreestreamadjb(3) = -(ainf*machgridadj*velzgridb)
  veldirfreestreamadjb(2) = veldirfreestreamadjb(2) - ainf*machgridadj*&
&    velygridb
  veldirfreestreamadjb(1) = veldirfreestreamadjb(1) - ainf*machgridadj*&
&    velxgridb
!!$  coscoeffourzrotb(:) = 0.0
!!$  sincoeffourxrotb(:) = 0.0
!!$  sincoeffouryrotb(:) = 0.0
!!$  sincoeffourzrotb(:) = 0.0
!!$  omegafourxrotb = 0.0
!!$  coefpolxrotb(:) = 0.0
!!$  omegafouryrotb = 0.0
!!$  coefpolyrotb(:) = 0.0
!!$  omegafourzrotb = 0.0
!!$  coefpolzrotb(:) = 0.0
!!$  coscoeffourxrotb(:) = 0.0
!!$  coscoeffouryrotb(:) = 0.0
END SUBROUTINE GRIDVELOCITIESFINELEVELFORCESADJ_B
