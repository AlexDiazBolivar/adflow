!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of computeforcesadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: cdadj rotrateadj
!                cladj machadj alphaadj xadj wadj betaadj cmzadj
!                cmyadj machcoefadj cmxadj
!   of linear combination of output variables: cdadj cladj cmzadj
!                cmyadj cmxadj
!
!     ******************************************************************
!     *                                                                *
!     * File:          computeForcesAdj.f90                            *
!     * Author:        C.A.(Sandy) Mader, Andre C. Marta               *
!     *                Seongim Choi
!     * Starting date: 12-14-2007                                      *
!     * Last modified: 12-27-2007                                      *
!     *                                                                *
!     ******************************************************************
!
SUBROUTINE COMPUTEFORCESADJ_B(xadj, xadjb, wadj, wadjb, padj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, cfxadj, cfyadj, &
&  cfzadj, cmxadj, cmxadjb, cmyadj, cmyadjb, cmzadj, cmzadjb, yplusmax, &
&  refpoint, cladj, cladjb, cdadj, cdadjb, nn, level, sps, cfpadj, &
&  cmpadj, righthanded, secondhalo, alphaadj, alphaadjb, betaadj, &
&  betaadjb, machadj, machadjb, machcoefadj, machcoefadjb, prefadj, &
&  rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, murefadj, &
&  timerefadj, pinfcorradj, rotcenteradj, rotrateadj, rotrateadjb, &
&  liftindex)
  USE bctypes
  USE blockpointers
  USE communication
  USE flowvarrefstate
  USE inputphysics
  USE inputtimespectral
  IMPLICIT NONE
!!$      
  REAL(KIND=REALTYPE) :: alphaadj, alphaadjb, betaadj, betaadjb
  REAL(KIND=REALTYPE) :: cfpadj(3), cmpadj(3)
  REAL(KIND=REALTYPE) :: cdadj(ntimeintervalsspectral), cdadjb(&
&  ntimeintervalsspectral), cfxadj(ntimeintervalsspectral), cfyadj(&
&  ntimeintervalsspectral), cfzadj(ntimeintervalsspectral), cladj(&
&  ntimeintervalsspectral), cladjb(ntimeintervalsspectral), cmxadj(&
&  ntimeintervalsspectral), cmxadjb(ntimeintervalsspectral), cmyadj(&
&  ntimeintervalsspectral), cmyadjb(ntimeintervalsspectral), cmzadj(&
&  ntimeintervalsspectral), cmzadjb(ntimeintervalsspectral)
  INTEGER(KIND=INTTYPE), INTENT(IN) :: i2beg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: i2end
  INTEGER(KIND=INTTYPE), INTENT(IN) :: iibeg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: iiend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: j2beg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: j2end
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jjbeg
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jjend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: level
  INTEGER(KIND=INTTYPE) :: liftindex
  REAL(KIND=REALTYPE) :: machadj, machadjb, machcoefadj, machcoefadjb, &
&  pinfcorradj
  INTEGER(KIND=INTTYPE), INTENT(IN) :: mm
  REAL(KIND=REALTYPE) :: murefadj, timerefadj
  INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: pinfdimadj, rhoinfdimadj
  REAL(KIND=REALTYPE) :: refpoint(3)
  REAL(KIND=REALTYPE) :: pinfadj, rhoinfadj
  REAL(KIND=REALTYPE) :: prefadj, rhorefadj
  LOGICAL, INTENT(IN) :: righthanded
  REAL(KIND=REALTYPE) :: rotcenteradj(3), rotrateadj(3), rotrateadjb(3)
  LOGICAL, INTENT(IN) :: secondhalo
  INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
  REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb, nw), INTENT(IN) :: &
&  wadj
  REAL(KIND=REALTYPE) :: wadjb(0:ib, 0:jb, 0:kb, nw)
  REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3), INTENT(IN) :: &
&  xadj
  REAL(KIND=REALTYPE) :: xadjb(0:ie, 0:je, 0:ke, 3)
  REAL(KIND=REALTYPE) :: yplusmax
  REAL(KIND=REALTYPE) :: cfvadj(3), cmvadj(3)
  REAL(KIND=REALTYPE) :: cfpadjout(3), cfpadjoutb(3), cfvadjout(3), &
&  cfvadjoutb(3)
  REAL(KIND=REALTYPE) :: cmpadjout(3), cmpadjoutb(3), cmvadjout(3), &
&  cmvadjoutb(3)
  REAL(KIND=REALTYPE) :: dragdirectionadj(3), dragdirectionadjb(3)
  INTEGER(KIND=INTTYPE) :: i, j, k, kk, l
  REAL(KIND=REALTYPE) :: liftdirectionadj(3), liftdirectionadjb(3)
  REAL(KIND=REALTYPE) :: normadj(iibeg:iiend, jjbeg:jjend, 3), normadjb(&
&  iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: padjb(0:ib, 0:jb, 0:kb)
  REAL(KIND=REALTYPE) :: rfaceadj(iibeg:iiend, jjbeg:jjend)
  REAL(KIND=REALTYPE) :: sadj(0:ie, 0:je, 0:ke, 3), sadjb(0:ie, 0:je, 0:&
&  ke, 3)
  REAL(KIND=REALTYPE) :: sfaceiadj(2, iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: sfacejadj(iibeg:iiend, 2, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: sfacekadj(iibeg:iiend, jjbeg:jjend, 2, 3)
  REAL(KIND=REALTYPE) :: siadj(2, iibeg:iiend, jjbeg:jjend, 3), siadjb(2&
&  , iibeg:iiend, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: sjadj(iibeg:iiend, 2, jjbeg:jjend, 3), sjadjb(&
&  iibeg:iiend, 2, jjbeg:jjend, 3)
  REAL(KIND=REALTYPE) :: skadj(iibeg:iiend, jjbeg:jjend, 2, 3), skadjb(&
&  iibeg:iiend, jjbeg:jjend, 2, 3)
  REAL(KIND=REALTYPE) :: pinfcorradjb, uinfadj, uinfadjb
  REAL(KIND=REALTYPE) :: veldirfreestreamadj(3), veldirfreestreamadjb(3)
  REAL(KIND=REALTYPE) :: winfadj(nw), winfadjb(nw)
!(xAdj, &
!         iiBeg,iiEnd,jjBeg,jjEnd,i2Beg,i2End,j2Beg,j2End, &
!         mm,cFxAdj,cFyAdj,cFzAdj, &
!         cMxAdj,cMyAdj,cMzAdj,yplusMax,refPoint,CLAdj,CDAdj,  &
!        nn,level,sps,cFpAdj,cMpAdj)
!
!     ******************************************************************
!     *                                                                *
!     * Computes the Force coefficients for the current configuration  *
!     * for the finest grid level and specified time instance using the*
!     * auxiliar routines modified for tapenade. This code calculates  *
!     * the result for a single boundary subface and requires an       *
!     * outside driver to loop over mm subfaces and nn domains to      *
!     * calculate the total forces and moments.                        *
!     *                                                                *
!     ******************************************************************
!
! ie,je,ke
! procHalo(currentLevel)%nProcSend, myID
! equations
! nTimeIntervalsSpectral!nTimeInstancesMax
! EulerWall, ...
!nw
!
!     Subroutine arguments.
!
! notice the range of x dim is set 1:2 which corresponds to 1/il
!
!     Local variables.
!
! notice the range of y dim is set 1:2 which corresponds to 1/jl
! notice the range of z dim is set 1:2 which corresponds to 1/kl
!add to allow for scaling!
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
!===============================================================
! Compute the forces.
!      call the initialization routines to calculate the effect of Mach and alpha
  CALL ADJUSTINFLOWANGLEFORCESADJ(alphaadj, betaadj, veldirfreestreamadj&
&                            , liftdirectionadj, dragdirectionadj, &
&                            liftindex)
  CALL PUSHREAL8(machcoefadj)
  CALL PUSHREAL8ARRAY(liftdirectionadj, 3)
  CALL PUSHREAL8ARRAY(veldirfreestreamadj, 3)
  CALL CHECKINPUTPARAMFORCESADJ(veldirfreestreamadj, liftdirectionadj, &
&                          dragdirectionadj, machadj, machcoefadj)
  CALL PUSHREAL8(gammainf)
  CALL PUSHREAL8(rhorefadj)
  CALL PUSHREAL8(prefadj)
  CALL REFERENCESTATEFORCESADJ(machadj, machcoefadj, uinfadj, prefadj, &
&                         rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj&
&                         , pinfadj, murefadj, timerefadj)
!referenceStateAdj(velDirFreestreamAdj,liftDirectionAdj,&
!      dragDirectionAdj, Machadj, MachCoefAdj,uInfAdj,prefAdj,&
!      rhorefAdj, pinfdimAdj, rhoinfdimAdj, rhoinfAdj, pinfAdj,&
!      murefAdj, timerefAdj)
!(velDirFreestreamAdj,liftDirectionAdj,&
!     dragDirectionAdj, Machadj, MachCoefAdj,uInfAdj)
  CALL SETFLOWINFINITYSTATEFORCESADJ(veldirfreestreamadj, &
&                               liftdirectionadj, dragdirectionadj, &
&                               machadj, machcoefadj, uinfadj, winfadj, &
&                               prefadj, rhorefadj, pinfdimadj, &
&                               rhoinfdimadj, rhoinfadj, pinfadj, &
&                               murefadj, timerefadj, pinfcorradj)
  CALL PUSHREAL8ARRAY(skadj, (iiend-iibeg+1)*(jjend-jjbeg+1)*2*3)
  CALL PUSHREAL8ARRAY(sjadj, (iiend-iibeg+1)*2*(jjend-jjbeg+1)*3)
  CALL PUSHREAL8ARRAY(siadj, 2*(iiend-iibeg+1)*(jjend-jjbeg+1)*3)
! Compute the surface normals (normAdj which is used only in 
! visous force computation) for the stencil
! Get siAdj,sjAdj,skAdj,normAdj
  CALL GETSURFACENORMALSADJ(xadj, siadj, sjadj, skadj, normadj, iibeg, &
&                      iiend, jjbeg, jjend, mm, level, nn, sps, &
&                      righthanded)
!call the gridVelocities function to get the cell center ,face center and boundary mesh velocities.
!first two arguments needed for time spectral.just set to initial values for the current steady case...
  CALL GRIDVELOCITIESFINELEVELFORCESADJ(.false., zero, sps, xadj, sadj, &
&                                  iibeg, iiend, jjbeg, jjend, i2beg, &
&                                  i2end, j2beg, j2end, mm, sfaceiadj, &
&                                  sfacejadj, sfacekadj, rotcenteradj, &
&                                  rotrateadj, siadj, sjadj, skadj)
  CALL NORMALVELOCITIESALLLEVELSFORCESADJ(sps, mm, sfaceiadj, iibeg, &
&                                    iiend, jjbeg, jjend, i2beg, i2end, &
&                                    j2beg, j2end, sfacejadj, sfacekadj&
&                                    , siadj, sjadj, skadj, rfaceadj)
!needed for uSlip in Viscous Calculations
!call slipVelocitiesFineLevel(.false., t, mm)
!     print *,'computing pressures'
  CALL COMPUTEFORCESPRESSUREADJ(wadj, padj)
  CALL PUSHREAL8ARRAY(padj, (ib+1)*(jb+1)*(kb+1))
  CALL PUSHREAL8ARRAY(wadj, (ib+1)*(jb+1)*(kb+1)*nw)
!     print *,'applyingbcs'
  CALL APPLYALLBCFORCESADJ(winfadj, pinfcorradj, wadj, padj, sadj, siadj&
&                     , sjadj, skadj, normadj, rfaceadj, iibeg, iiend, &
&                     jjbeg, jjend, i2beg, i2end, j2beg, j2end, &
&                     secondhalo, mm)
  CALL PUSHREAL8ARRAY(cmvadj, 3)
  CALL PUSHREAL8ARRAY(cfvadj, 3)
  CALL PUSHREAL8ARRAY(cmpadj, 3)
  CALL PUSHREAL8ARRAY(cfpadj, 3)
!      print *,'integrating forces'
! Integrate force components along the given subface
  CALL FORCESANDMOMENTSADJ(cfpadj, cmpadj, cfvadj, cmvadj, cfpadjout, &
&                     cmpadjout, cfvadjout, cmvadjout, yplusmax, &
&                     refpoint, siadj, sjadj, skadj, normadj, xadj, padj&
&                     , wadj, iibeg, iiend, jjbeg, jjend, i2beg, i2end, &
&                     j2beg, j2end, level, mm, nn, machcoefadj)
!(cFpAdj,cMpAdj, &
!     cFpAdjOut,cMpAdjOut, &
!     yplusMax,refPoint,siAdj,sjAdj,skAdj,normAdj,xAdj,pAdj,wAdj,&
!     iiBeg,iiEnd,jjBeg,jjEnd,i2Beg,i2End,j2Beg,j2End, &
!     level,mm,nn,machCoefAdj)
!end if invForce
! Compute the force components for the current block subface
!print *,'cfpadjout',cfpadjout,liftdirectionadj
  cmvadjoutb(1:3) = 0.0
  cmpadjoutb(1:3) = 0.0
  cmpadjoutb(3) = cmzadjb(sps)
  cmvadjoutb(3) = cmzadjb(sps)
  cmpadjoutb(2) = cmpadjoutb(2) + cmyadjb(sps)
  cmvadjoutb(2) = cmvadjoutb(2) + cmyadjb(sps)
  cmpadjoutb(1) = cmpadjoutb(1) + cmxadjb(sps)
  cmvadjoutb(1) = cmvadjoutb(1) + cmxadjb(sps)
  cfpadjoutb(1:3) = 0.0
  dragdirectionadjb(1:3) = 0.0
  cfvadjoutb(1:3) = 0.0
  cfpadjoutb(1) = dragdirectionadj(1)*cdadjb(sps)
  cfvadjoutb(1) = dragdirectionadj(1)*cdadjb(sps)
  dragdirectionadjb(1) = (cfpadjout(1)+cfvadjout(1))*cdadjb(sps)
  cfpadjoutb(2) = dragdirectionadj(2)*cdadjb(sps)
  cfvadjoutb(2) = dragdirectionadj(2)*cdadjb(sps)
  dragdirectionadjb(2) = (cfpadjout(2)+cfvadjout(2))*cdadjb(sps)
  cfpadjoutb(3) = dragdirectionadj(3)*cdadjb(sps)
  cfvadjoutb(3) = dragdirectionadj(3)*cdadjb(sps)
  dragdirectionadjb(3) = (cfpadjout(3)+cfvadjout(3))*cdadjb(sps)
  liftdirectionadjb(1:3) = 0.0
  cfpadjoutb(1) = cfpadjoutb(1) + liftdirectionadj(1)*cladjb(sps)
  cfvadjoutb(1) = cfvadjoutb(1) + liftdirectionadj(1)*cladjb(sps)
  liftdirectionadjb(1) = (cfpadjout(1)+cfvadjout(1))*cladjb(sps)
  cfpadjoutb(2) = cfpadjoutb(2) + liftdirectionadj(2)*cladjb(sps)
  cfvadjoutb(2) = cfvadjoutb(2) + liftdirectionadj(2)*cladjb(sps)
  liftdirectionadjb(2) = (cfpadjout(2)+cfvadjout(2))*cladjb(sps)
  cfpadjoutb(3) = cfpadjoutb(3) + liftdirectionadj(3)*cladjb(sps)
  cfvadjoutb(3) = cfvadjoutb(3) + liftdirectionadj(3)*cladjb(sps)
  liftdirectionadjb(3) = (cfpadjout(3)+cfvadjout(3))*cladjb(sps)
  CALL POPREAL8ARRAY(cfpadj, 3)
  CALL POPREAL8ARRAY(cmpadj, 3)
  CALL POPREAL8ARRAY(cfvadj, 3)
  CALL POPREAL8ARRAY(cmvadj, 3)
  CALL FORCESANDMOMENTSADJ_B(cfpadj, cmpadj, cfvadj, cmvadj, cfpadjout, &
&                       cfpadjoutb, cmpadjout, cmpadjoutb, cfvadjout, &
&                       cfvadjoutb, cmvadjout, cmvadjoutb, yplusmax, &
&                       refpoint, siadj, siadjb, sjadj, sjadjb, skadj, &
&                       skadjb, normadj, xadj, xadjb, padj, padjb, wadj&
&                       , iibeg, iiend, jjbeg, jjend, i2beg, i2end, &
&                       j2beg, j2end, level, mm, nn, machcoefadj, &
&                       machcoefadjb)
  CALL POPREAL8ARRAY(wadj, (ib+1)*(jb+1)*(kb+1)*nw)
  CALL POPREAL8ARRAY(padj, (ib+1)*(jb+1)*(kb+1))
  CALL APPLYALLBCFORCESADJ_B(winfadj, winfadjb, pinfcorradj, &
&                       pinfcorradjb, wadj, wadjb, padj, padjb, sadj, &
&                       sadjb, siadj, siadjb, sjadj, sjadjb, skadj, &
&                       skadjb, normadj, normadjb, rfaceadj, iibeg, &
&                       iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end&
&                       , secondhalo, mm)
  CALL COMPUTEFORCESPRESSUREADJ_B(wadj, wadjb, padj, padjb)
  CALL GRIDVELOCITIESFINELEVELFORCESADJ_B(.false., zero, sps, xadj, &
&                                    xadjb, sadj, sadjb, iibeg, iiend, &
&                                    jjbeg, jjend, i2beg, i2end, j2beg, &
&                                    j2end, mm, sfaceiadj, sfacejadj, &
&                                    sfacekadj, rotcenteradj, rotrateadj&
&                                    , rotrateadjb, siadj, sjadj, skadj)
  CALL POPREAL8ARRAY(siadj, 2*(iiend-iibeg+1)*(jjend-jjbeg+1)*3)
  CALL POPREAL8ARRAY(sjadj, (iiend-iibeg+1)*2*(jjend-jjbeg+1)*3)
  CALL POPREAL8ARRAY(skadj, (iiend-iibeg+1)*(jjend-jjbeg+1)*2*3)
  CALL GETSURFACENORMALSADJ_B(xadj, xadjb, siadj, siadjb, sjadj, sjadjb&
&                        , skadj, skadjb, normadj, normadjb, iibeg, &
&                        iiend, jjbeg, jjend, mm, level, nn, sps, &
&                        righthanded)
  CALL SETFLOWINFINITYSTATEFORCESADJ_B(veldirfreestreamadj, &
&                                 veldirfreestreamadjb, liftdirectionadj&
&                                 , dragdirectionadj, machadj, &
&                                 machcoefadj, uinfadj, uinfadjb, &
&                                 winfadj, winfadjb, prefadj, rhorefadj&
&                                 , pinfdimadj, rhoinfdimadj, rhoinfadj&
&                                 , pinfadj, murefadj, timerefadj, &
&                                 pinfcorradj, pinfcorradjb)
  CALL POPREAL8(prefadj)
  CALL POPREAL8(rhorefadj)
  CALL POPREAL8(gammainf)
  CALL REFERENCESTATEFORCESADJ_B(machadj, machadjb, machcoefadj, uinfadj&
&                           , uinfadjb, prefadj, rhorefadj, pinfdimadj, &
&                           rhoinfdimadj, rhoinfadj, pinfadj, murefadj, &
&                           timerefadj)
  CALL POPREAL8ARRAY(veldirfreestreamadj, 3)
  CALL POPREAL8ARRAY(liftdirectionadj, 3)
  CALL POPREAL8(machcoefadj)
  CALL CHECKINPUTPARAMFORCESADJ_B(veldirfreestreamadj, &
&                            veldirfreestreamadjb, liftdirectionadj, &
&                            liftdirectionadjb, dragdirectionadj, &
&                            dragdirectionadjb, machadj, machadjb, &
&                            machcoefadj, machcoefadjb)
  CALL ADJUSTINFLOWANGLEFORCESADJ_B(alphaadj, alphaadjb, betaadj, &
&                              betaadjb, veldirfreestreamadj, &
&                              veldirfreestreamadjb, liftdirectionadj, &
&                              liftdirectionadjb, dragdirectionadj, &
&                              liftindex)
  cdadjb(1:ntimeintervalsspectral) = 0.0
  cladjb(1:ntimeintervalsspectral) = 0.0
  cmzadjb(1:ntimeintervalsspectral) = 0.0
  cmyadjb(1:ntimeintervalsspectral) = 0.0
  cmxadjb(1:ntimeintervalsspectral) = 0.0
END SUBROUTINE COMPUTEFORCESADJ_B
