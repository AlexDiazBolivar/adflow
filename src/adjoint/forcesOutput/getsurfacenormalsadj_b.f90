!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 2.2.4 (r2308) - 03/04/2008 10:03
!  
!  Differentiation of getsurfacenormalsadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: xadj
!   of linear combination of output variables: xadj skadj sjadj
!                siadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          getSurfaceNormalsAdj.f90                        *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi                                    *
!      * Starting date: 12-18-2007                                      *
!      * Last modified: 12-18-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE GETSURFACENORMALSADJ_B(xadj, xadjb, siadj, siadjb, sjadj, &
&  sjadjb, skadj, skadjb, normadj, iibeg, iiend, jjbeg, jjend, mm, level&
&  , nn, sps, righthanded)
  USE blockpointers
  USE bctypes
  USE communication
  IMPLICIT NONE
!
!
!      ******************************************************************
!      *                                                                *
!      * boundarySurfaceNormals computes the outward normals of the     *
!      * boundary subfaces at the given time instance and the given     *
!      * multi grid level.                                              *
!      *                                                                *
!      ******************************************************************
!
! ie,je,ke,il,jl,kl
!
!      Subroutine arguments.
!
  INTEGER(KIND=INTTYPE), INTENT(IN) :: iibeg, iiend, jjbeg, jjend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: level, nn, sps, mm
  REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3) :: xadj
  REAL(KIND=REALTYPE), DIMENSION(0:ie, 0:je, 0:ke, 3) :: xadjb
!       real(kind=realType), dimension(1:2,iiBeg:iiEnd,jjBeg:jjEnd,3), intent(out) :: siAdj
!       real(kind=realType), dimension(iiBeg:iiEnd,1:2,jjBeg:jjEnd,3), intent(out) :: sjAdj
!       real(kind=realType), dimension(iiBeg:iiEnd,jjBeg:jjEnd,1:2,3), intent(out) :: skAdj
!       real(kind=realType), dimension(iiBeg:iiEnd,jjBeg:jjEnd,3), intent(out) :: normAdj
  REAL(KIND=REALTYPE), DIMENSION(2, iibeg:iiend, jjbeg:jjend, 3) :: &
&  siadj
  REAL(KIND=REALTYPE), DIMENSION(2, iibeg:iiend, jjbeg:jjend, 3) :: &
&  siadjb
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, 2, jjbeg:jjend, 3) :: &
&  sjadj
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, 2, jjbeg:jjend, 3) :: &
&  sjadjb
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 2, 3) :: &
&  skadj
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 2, 3) :: &
&  skadjb
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 3) :: normadj
!
!      Local variables.
!
  INTEGER :: ierr
  INTEGER(KIND=INTTYPE) :: i, j, k, ii, jj, kk, l, m, n
  REAL(KIND=REALTYPE) :: mult, xp, yp, zp, fact
  REAL(KIND=REALTYPE), DIMENSION(iibeg:iiend, jjbeg:jjend, 3) :: ss
  REAL(KIND=REALTYPE), DIMENSION(3) :: v1, v2, v12, v22
  REAL(KIND=REALTYPE), DIMENSION(3) :: v1b, v2b
  LOGICAL, INTENT(IN) :: righthanded
  INTEGER :: branch
  REAL(KIND=REALTYPE) :: tempb9
  REAL(KIND=REALTYPE) :: tempb8
  REAL(KIND=REALTYPE) :: tempb7
  REAL(KIND=REALTYPE) :: tempb6
  REAL(KIND=REALTYPE) :: tempb5
  REAL(KIND=REALTYPE) :: tempb4
  REAL(KIND=REALTYPE) :: tempb3
  REAL(KIND=REALTYPE) :: tempb2
  REAL(KIND=REALTYPE) :: tempb1
  REAL(KIND=REALTYPE) :: tempb16
  REAL(KIND=REALTYPE) :: tempb0
  REAL(KIND=REALTYPE) :: tempb15
  REAL(KIND=REALTYPE) :: tempb14
  REAL(KIND=REALTYPE) :: tempb13
  REAL(KIND=REALTYPE) :: tempb12
  REAL(KIND=REALTYPE) :: tempb11
  REAL(KIND=REALTYPE) :: tempb10
  REAL(KIND=REALTYPE) :: tempb
  INTRINSIC SQRT
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
!      **************************************************************
!      *                                                            *
!      * Computation of the face normals in i-, j- and k-direction. *
!      * Formula's are valid for a right handed block; for a left   *
!      * handed block the correct orientation is obtained via fact. *
!      * The normals point in the direction of increasing index.    *
!      * The absolute value of fact is 0.5, because the cross       *
!      * product of the two diagonals is twice the normal vector.   *
!      *                                                            *
!      * Note that also the normals of the first level halo cells   *
!      * are computed. These are needed for the viscous fluxes.     *
!      *                                                            *
!      **************************************************************
!
! Set the factor in the surface normals computation. For a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! The formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
  IF (righthanded) THEN
    fact = half
  ELSE
    fact = -half
  END IF
  SELECT CASE  (bcfaceid(mm)) 
  CASE (imin) 
    DO k=jjbeg,jjend
      CALL PUSHINTEGER4(n)
      n = k - 1
      DO j=iibeg,iiend
        CALL PUSHINTEGER4(m)
        m = j - 1
        DO i=1,1
! to get siAdj(1,:,:,3)
          IF (i .EQ. 1) THEN
            CALL PUSHINTEGER4(ii)
            ii = 1
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
          END IF
          CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
          v1(1) = xadj(i, j, n, 1) - xadj(i, m, k, 1)
          CALL PUSHREAL8(v1(2))
          v1(2) = xadj(i, j, n, 2) - xadj(i, m, k, 2)
          CALL PUSHREAL8(v1(3))
          v1(3) = xadj(i, j, n, 3) - xadj(i, m, k, 3)
          CALL PUSHREAL8(v2(1))
          v2(1) = xadj(i, j, k, 1) - xadj(i, m, n, 1)
          CALL PUSHREAL8(v2(2))
          v2(2) = xadj(i, j, k, 2) - xadj(i, m, n, 2)
          CALL PUSHREAL8(v2(3))
          v2(3) = xadj(i, j, k, 3) - xadj(i, m, n, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        END DO
      END DO
    END DO
    v1b(:) = 0.0
    v2b(:) = 0.0
    DO k=jjend,jjbeg,-1
      DO j=iiend,iibeg,-1
        DO i=1,1,-1
          tempb = fact*siadjb(ii, j, k, 3)
          v1b(1) = v1b(1) + v2(2)*tempb
          v2b(2) = v2b(2) + v1(1)*tempb
          v1b(2) = v1b(2) - v2(1)*tempb
          siadjb(ii, j, k, 3) = 0.0
          tempb0 = fact*siadjb(ii, j, k, 2)
          v2b(1) = v2b(1) + v1(3)*tempb0 - v1(2)*tempb
          v1b(3) = v1b(3) + v2(1)*tempb0
          v1b(1) = v1b(1) - v2(3)*tempb0
          siadjb(ii, j, k, 2) = 0.0
          tempb1 = fact*siadjb(ii, j, k, 1)
          v2b(3) = v2b(3) + v1(2)*tempb1 - v1(1)*tempb0
          v1b(2) = v1b(2) + v2(3)*tempb1
          v1b(3) = v1b(3) - v2(2)*tempb1
          v2b(2) = v2b(2) - v1(3)*tempb1
          siadjb(ii, j, k, 1) = 0.0
          CALL POPREAL8(v2(3))
          xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v2b(3)
          xadjb(i, m, n, 3) = xadjb(i, m, n, 3) - v2b(3)
          v2b(3) = 0.0
          CALL POPREAL8(v2(2))
          xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v2b(2)
          xadjb(i, m, n, 2) = xadjb(i, m, n, 2) - v2b(2)
          v2b(2) = 0.0
          CALL POPREAL8(v2(1))
          xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v2b(1)
          xadjb(i, m, n, 1) = xadjb(i, m, n, 1) - v2b(1)
          v2b(1) = 0.0
          CALL POPREAL8(v1(3))
          xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
          xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v1b(3)
          v1b(3) = 0.0
          CALL POPREAL8(v1(2))
          xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
          xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v1b(2)
          v1b(2) = 0.0
          CALL POPREAL8(v1(1))
          xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
          xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v1b(1)
          v1b(1) = 0.0
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ii)
        END DO
        CALL POPINTEGER4(m)
      END DO
      CALL POPINTEGER4(n)
    END DO
  CASE (imax) 
    DO k=jjbeg,jjend
      CALL PUSHINTEGER4(n)
      n = k - 1
      DO j=iibeg,iiend
        CALL PUSHINTEGER4(m)
        m = j - 1
        DO i=il,il
! to get siAdj(2,:,:,3)
          IF (i .EQ. il) THEN
            CALL PUSHINTEGER4(ii)
            ii = 2
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
          END IF
          CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
          v1(1) = xadj(i, j, n, 1) - xadj(i, m, k, 1)
          CALL PUSHREAL8(v1(2))
          v1(2) = xadj(i, j, n, 2) - xadj(i, m, k, 2)
          CALL PUSHREAL8(v1(3))
          v1(3) = xadj(i, j, n, 3) - xadj(i, m, k, 3)
          CALL PUSHREAL8(v2(1))
          v2(1) = xadj(i, j, k, 1) - xadj(i, m, n, 1)
          CALL PUSHREAL8(v2(2))
          v2(2) = xadj(i, j, k, 2) - xadj(i, m, n, 2)
          CALL PUSHREAL8(v2(3))
          v2(3) = xadj(i, j, k, 3) - xadj(i, m, n, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        END DO
      END DO
    END DO
    v1b(:) = 0.0
    v2b(:) = 0.0
    DO k=jjend,jjbeg,-1
      DO j=iiend,iibeg,-1
        DO i=il,il,-1
          tempb2 = fact*siadjb(ii, j, k, 3)
          v1b(1) = v1b(1) + v2(2)*tempb2
          v2b(2) = v2b(2) + v1(1)*tempb2
          v1b(2) = v1b(2) - v2(1)*tempb2
          siadjb(ii, j, k, 3) = 0.0
          tempb3 = fact*siadjb(ii, j, k, 2)
          v2b(1) = v2b(1) + v1(3)*tempb3 - v1(2)*tempb2
          v1b(3) = v1b(3) + v2(1)*tempb3
          v1b(1) = v1b(1) - v2(3)*tempb3
          siadjb(ii, j, k, 2) = 0.0
          tempb4 = fact*siadjb(ii, j, k, 1)
          v2b(3) = v2b(3) + v1(2)*tempb4 - v1(1)*tempb3
          v1b(2) = v1b(2) + v2(3)*tempb4
          v1b(3) = v1b(3) - v2(2)*tempb4
          v2b(2) = v2b(2) - v1(3)*tempb4
          siadjb(ii, j, k, 1) = 0.0
          CALL POPREAL8(v2(3))
          xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v2b(3)
          xadjb(i, m, n, 3) = xadjb(i, m, n, 3) - v2b(3)
          v2b(3) = 0.0
          CALL POPREAL8(v2(2))
          xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v2b(2)
          xadjb(i, m, n, 2) = xadjb(i, m, n, 2) - v2b(2)
          v2b(2) = 0.0
          CALL POPREAL8(v2(1))
          xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v2b(1)
          xadjb(i, m, n, 1) = xadjb(i, m, n, 1) - v2b(1)
          v2b(1) = 0.0
          CALL POPREAL8(v1(3))
          xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
          xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v1b(3)
          v1b(3) = 0.0
          CALL POPREAL8(v1(2))
          xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
          xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v1b(2)
          v1b(2) = 0.0
          CALL POPREAL8(v1(1))
          xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
          xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v1b(1)
          v1b(1) = 0.0
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ii)
        END DO
        CALL POPINTEGER4(m)
      END DO
      CALL POPINTEGER4(n)
    END DO
  CASE (jmin) 
! Projected areas of cell faces in the j direction.
    DO k=jjbeg,jjend
      CALL PUSHINTEGER4(n)
      n = k - 1
      DO j=1,1
! to get sjAdj(:,1,:,:)
        IF (j .EQ. 1) THEN
          CALL PUSHINTEGER4(jj)
          jj = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        DO i=iibeg,iiend
          CALL PUSHINTEGER4(l)
          l = i - 1
          CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
          v1(1) = xadj(i, j, n, 1) - xadj(l, j, k, 1)
          CALL PUSHREAL8(v1(2))
          v1(2) = xadj(i, j, n, 2) - xadj(l, j, k, 2)
          CALL PUSHREAL8(v1(3))
          v1(3) = xadj(i, j, n, 3) - xadj(l, j, k, 3)
          CALL PUSHREAL8(v2(1))
          v2(1) = xadj(l, j, n, 1) - xadj(i, j, k, 1)
          CALL PUSHREAL8(v2(2))
          v2(2) = xadj(l, j, n, 2) - xadj(i, j, k, 2)
          CALL PUSHREAL8(v2(3))
          v2(3) = xadj(l, j, n, 3) - xadj(i, j, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        END DO
      END DO
    END DO
    v1b(:) = 0.0
    v2b(:) = 0.0
    DO k=jjend,jjbeg,-1
      DO j=1,1,-1
        DO i=iiend,iibeg,-1
          tempb5 = fact*sjadjb(i, jj, k, 3)
          v1b(1) = v1b(1) + v2(2)*tempb5
          v2b(2) = v2b(2) + v1(1)*tempb5
          v1b(2) = v1b(2) - v2(1)*tempb5
          sjadjb(i, jj, k, 3) = 0.0
          tempb6 = fact*sjadjb(i, jj, k, 2)
          v2b(1) = v2b(1) + v1(3)*tempb6 - v1(2)*tempb5
          v1b(3) = v1b(3) + v2(1)*tempb6
          v1b(1) = v1b(1) - v2(3)*tempb6
          sjadjb(i, jj, k, 2) = 0.0
          tempb7 = fact*sjadjb(i, jj, k, 1)
          v2b(3) = v2b(3) + v1(2)*tempb7 - v1(1)*tempb6
          v1b(2) = v1b(2) + v2(3)*tempb7
          v1b(3) = v1b(3) - v2(2)*tempb7
          v2b(2) = v2b(2) - v1(3)*tempb7
          sjadjb(i, jj, k, 1) = 0.0
          CALL POPREAL8(v2(3))
          xadjb(l, j, n, 3) = xadjb(l, j, n, 3) + v2b(3)
          xadjb(i, j, k, 3) = xadjb(i, j, k, 3) - v2b(3)
          v2b(3) = 0.0
          CALL POPREAL8(v2(2))
          xadjb(l, j, n, 2) = xadjb(l, j, n, 2) + v2b(2)
          xadjb(i, j, k, 2) = xadjb(i, j, k, 2) - v2b(2)
          v2b(2) = 0.0
          CALL POPREAL8(v2(1))
          xadjb(l, j, n, 1) = xadjb(l, j, n, 1) + v2b(1)
          xadjb(i, j, k, 1) = xadjb(i, j, k, 1) - v2b(1)
          v2b(1) = 0.0
          CALL POPREAL8(v1(3))
          xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
          xadjb(l, j, k, 3) = xadjb(l, j, k, 3) - v1b(3)
          v1b(3) = 0.0
          CALL POPREAL8(v1(2))
          xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
          xadjb(l, j, k, 2) = xadjb(l, j, k, 2) - v1b(2)
          v1b(2) = 0.0
          CALL POPREAL8(v1(1))
          xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
          xadjb(l, j, k, 1) = xadjb(l, j, k, 1) - v1b(1)
          v1b(1) = 0.0
          CALL POPINTEGER4(l)
        END DO
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) CALL POPINTEGER4(jj)
      END DO
      CALL POPINTEGER4(n)
    END DO
  CASE (jmax) 
! Projected areas of cell faces in the j direction.
    DO k=jjbeg,jjend
      CALL PUSHINTEGER4(n)
      n = k - 1
      DO j=jl,jl
! to get sjAdj(:,1:2:,:,3)
        IF (j .EQ. jl) THEN
          CALL PUSHINTEGER4(jj)
          jj = 2
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        DO i=iibeg,iiend
          CALL PUSHINTEGER4(l)
          l = i - 1
          CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
          v1(1) = xadj(i, j, n, 1) - xadj(l, j, k, 1)
          CALL PUSHREAL8(v1(2))
          v1(2) = xadj(i, j, n, 2) - xadj(l, j, k, 2)
          CALL PUSHREAL8(v1(3))
          v1(3) = xadj(i, j, n, 3) - xadj(l, j, k, 3)
          CALL PUSHREAL8(v2(1))
          v2(1) = xadj(l, j, n, 1) - xadj(i, j, k, 1)
          CALL PUSHREAL8(v2(2))
          v2(2) = xadj(l, j, n, 2) - xadj(i, j, k, 2)
          CALL PUSHREAL8(v2(3))
          v2(3) = xadj(l, j, n, 3) - xadj(i, j, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        END DO
      END DO
    END DO
    v1b(:) = 0.0
    v2b(:) = 0.0
    DO k=jjend,jjbeg,-1
      DO j=jl,jl,-1
        DO i=iiend,iibeg,-1
          tempb8 = fact*sjadjb(i, jj, k, 3)
          v1b(1) = v1b(1) + v2(2)*tempb8
          v2b(2) = v2b(2) + v1(1)*tempb8
          v1b(2) = v1b(2) - v2(1)*tempb8
          sjadjb(i, jj, k, 3) = 0.0
          tempb9 = fact*sjadjb(i, jj, k, 2)
          v2b(1) = v2b(1) + v1(3)*tempb9 - v1(2)*tempb8
          v1b(3) = v1b(3) + v2(1)*tempb9
          v1b(1) = v1b(1) - v2(3)*tempb9
          sjadjb(i, jj, k, 2) = 0.0
          tempb10 = fact*sjadjb(i, jj, k, 1)
          v2b(3) = v2b(3) + v1(2)*tempb10 - v1(1)*tempb9
          v1b(2) = v1b(2) + v2(3)*tempb10
          v1b(3) = v1b(3) - v2(2)*tempb10
          v2b(2) = v2b(2) - v1(3)*tempb10
          sjadjb(i, jj, k, 1) = 0.0
          CALL POPREAL8(v2(3))
          xadjb(l, j, n, 3) = xadjb(l, j, n, 3) + v2b(3)
          xadjb(i, j, k, 3) = xadjb(i, j, k, 3) - v2b(3)
          v2b(3) = 0.0
          CALL POPREAL8(v2(2))
          xadjb(l, j, n, 2) = xadjb(l, j, n, 2) + v2b(2)
          xadjb(i, j, k, 2) = xadjb(i, j, k, 2) - v2b(2)
          v2b(2) = 0.0
          CALL POPREAL8(v2(1))
          xadjb(l, j, n, 1) = xadjb(l, j, n, 1) + v2b(1)
          xadjb(i, j, k, 1) = xadjb(i, j, k, 1) - v2b(1)
          v2b(1) = 0.0
          CALL POPREAL8(v1(3))
          xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
          xadjb(l, j, k, 3) = xadjb(l, j, k, 3) - v1b(3)
          v1b(3) = 0.0
          CALL POPREAL8(v1(2))
          xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
          xadjb(l, j, k, 2) = xadjb(l, j, k, 2) - v1b(2)
          v1b(2) = 0.0
          CALL POPREAL8(v1(1))
          xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
          xadjb(l, j, k, 1) = xadjb(l, j, k, 1) - v1b(1)
          v1b(1) = 0.0
          CALL POPINTEGER4(l)
        END DO
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) CALL POPINTEGER4(jj)
      END DO
      CALL POPINTEGER4(n)
    END DO
  CASE (kmin) 
! Projected areas of cell faces in the k direction.
    DO k=1,1
! to get skAdj(:,::,1:2,3)
      IF (k .EQ. 1) THEN
        CALL PUSHINTEGER4(kk)
        kk = 1
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      DO j=jjbeg,jjend
        CALL PUSHINTEGER4(m)
        m = j - 1
        DO i=iibeg,iiend
          CALL PUSHINTEGER4(l)
          l = i - 1
          CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
          v1(1) = xadj(i, j, k, 1) - xadj(l, m, k, 1)
          CALL PUSHREAL8(v1(2))
          v1(2) = xadj(i, j, k, 2) - xadj(l, m, k, 2)
          CALL PUSHREAL8(v1(3))
          v1(3) = xadj(i, j, k, 3) - xadj(l, m, k, 3)
          CALL PUSHREAL8(v2(1))
          v2(1) = xadj(l, j, k, 1) - xadj(i, m, k, 1)
          CALL PUSHREAL8(v2(2))
          v2(2) = xadj(l, j, k, 2) - xadj(i, m, k, 2)
          CALL PUSHREAL8(v2(3))
          v2(3) = xadj(l, j, k, 3) - xadj(i, m, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        END DO
      END DO
    END DO
    v1b(:) = 0.0
    v2b(:) = 0.0
    DO k=1,1,-1
      DO j=jjend,jjbeg,-1
        DO i=iiend,iibeg,-1
          tempb11 = fact*skadjb(i, j, kk, 3)
          v1b(1) = v1b(1) + v2(2)*tempb11
          v2b(2) = v2b(2) + v1(1)*tempb11
          v1b(2) = v1b(2) - v2(1)*tempb11
          skadjb(i, j, kk, 3) = 0.0
          tempb12 = fact*skadjb(i, j, kk, 2)
          v2b(1) = v2b(1) + v1(3)*tempb12 - v1(2)*tempb11
          v1b(3) = v1b(3) + v2(1)*tempb12
          v1b(1) = v1b(1) - v2(3)*tempb12
          skadjb(i, j, kk, 2) = 0.0
          tempb13 = fact*skadjb(i, j, kk, 1)
          v2b(3) = v2b(3) + v1(2)*tempb13 - v1(1)*tempb12
          v1b(2) = v1b(2) + v2(3)*tempb13
          v1b(3) = v1b(3) - v2(2)*tempb13
          v2b(2) = v2b(2) - v1(3)*tempb13
          skadjb(i, j, kk, 1) = 0.0
          CALL POPREAL8(v2(3))
          xadjb(l, j, k, 3) = xadjb(l, j, k, 3) + v2b(3)
          xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v2b(3)
          v2b(3) = 0.0
          CALL POPREAL8(v2(2))
          xadjb(l, j, k, 2) = xadjb(l, j, k, 2) + v2b(2)
          xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v2b(2)
          v2b(2) = 0.0
          CALL POPREAL8(v2(1))
          xadjb(l, j, k, 1) = xadjb(l, j, k, 1) + v2b(1)
          xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v2b(1)
          v2b(1) = 0.0
          CALL POPREAL8(v1(3))
          xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v1b(3)
          xadjb(l, m, k, 3) = xadjb(l, m, k, 3) - v1b(3)
          v1b(3) = 0.0
          CALL POPREAL8(v1(2))
          xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v1b(2)
          xadjb(l, m, k, 2) = xadjb(l, m, k, 2) - v1b(2)
          v1b(2) = 0.0
          CALL POPREAL8(v1(1))
          xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v1b(1)
          xadjb(l, m, k, 1) = xadjb(l, m, k, 1) - v1b(1)
          v1b(1) = 0.0
          CALL POPINTEGER4(l)
        END DO
        CALL POPINTEGER4(m)
      END DO
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPINTEGER4(kk)
    END DO
  CASE (kmax) 
! Projected areas of cell faces in the k direction.
    DO k=kl,kl
! to get skAdj(:,::,1:2,3)
      IF (k .EQ. kl) THEN
        CALL PUSHINTEGER4(kk)
        kk = 2
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      DO j=jjbeg,jjend
        CALL PUSHINTEGER4(m)
        m = j - 1
        DO i=iibeg,iiend
          CALL PUSHINTEGER4(l)
          l = i - 1
          CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
          v1(1) = xadj(i, j, k, 1) - xadj(l, m, k, 1)
          CALL PUSHREAL8(v1(2))
          v1(2) = xadj(i, j, k, 2) - xadj(l, m, k, 2)
          CALL PUSHREAL8(v1(3))
          v1(3) = xadj(i, j, k, 3) - xadj(l, m, k, 3)
          CALL PUSHREAL8(v2(1))
          v2(1) = xadj(l, j, k, 1) - xadj(i, m, k, 1)
          CALL PUSHREAL8(v2(2))
          v2(2) = xadj(l, j, k, 2) - xadj(i, m, k, 2)
          CALL PUSHREAL8(v2(3))
          v2(3) = xadj(l, j, k, 3) - xadj(i, m, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        END DO
      END DO
    END DO
    v1b(:) = 0.0
    v2b(:) = 0.0
    DO k=kl,kl,-1
      DO j=jjend,jjbeg,-1
        DO i=iiend,iibeg,-1
          tempb14 = fact*skadjb(i, j, kk, 3)
          v1b(1) = v1b(1) + v2(2)*tempb14
          v2b(2) = v2b(2) + v1(1)*tempb14
          v1b(2) = v1b(2) - v2(1)*tempb14
          skadjb(i, j, kk, 3) = 0.0
          tempb15 = fact*skadjb(i, j, kk, 2)
          v2b(1) = v2b(1) + v1(3)*tempb15 - v1(2)*tempb14
          v1b(3) = v1b(3) + v2(1)*tempb15
          v1b(1) = v1b(1) - v2(3)*tempb15
          skadjb(i, j, kk, 2) = 0.0
          tempb16 = fact*skadjb(i, j, kk, 1)
          v2b(3) = v2b(3) + v1(2)*tempb16 - v1(1)*tempb15
          v1b(2) = v1b(2) + v2(3)*tempb16
          v1b(3) = v1b(3) - v2(2)*tempb16
          v2b(2) = v2b(2) - v1(3)*tempb16
          skadjb(i, j, kk, 1) = 0.0
          CALL POPREAL8(v2(3))
          xadjb(l, j, k, 3) = xadjb(l, j, k, 3) + v2b(3)
          xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v2b(3)
          v2b(3) = 0.0
          CALL POPREAL8(v2(2))
          xadjb(l, j, k, 2) = xadjb(l, j, k, 2) + v2b(2)
          xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v2b(2)
          v2b(2) = 0.0
          CALL POPREAL8(v2(1))
          xadjb(l, j, k, 1) = xadjb(l, j, k, 1) + v2b(1)
          xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v2b(1)
          v2b(1) = 0.0
          CALL POPREAL8(v1(3))
          xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v1b(3)
          xadjb(l, m, k, 3) = xadjb(l, m, k, 3) - v1b(3)
          v1b(3) = 0.0
          CALL POPREAL8(v1(2))
          xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v1b(2)
          xadjb(l, m, k, 2) = xadjb(l, m, k, 2) - v1b(2)
          v1b(2) = 0.0
          CALL POPREAL8(v1(1))
          xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v1b(1)
          xadjb(l, m, k, 1) = xadjb(l, m, k, 1) - v1b(1)
          v1b(1) = 0.0
          CALL POPINTEGER4(l)
        END DO
        CALL POPINTEGER4(m)
      END DO
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) CALL POPINTEGER4(kk)
    END DO
  END SELECT
END SUBROUTINE GETSURFACENORMALSADJ_B
