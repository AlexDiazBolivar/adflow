!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 2.2.4 (r2308) - 03/04/2008 10:03
!  
!
!      ******************************************************************
!      *                                                                *
!      * File:          block.f90                                       *
!      * Author:        Edwin van der Weide, Steve Repsher,             *
!      *                Seonghyeon Hahn                                 *
!      * Starting date: 12-19-2002                                      *
!      * Last modified: 11-21-2007                                      *
!      *                                                                *
!      ******************************************************************
!
MODULE BLOCK_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * This module contains the definition of the derived data type   *
!      * for block, which is the basic building block for this code.    *
!      *                                                                *
!      * Apart from the derived data type for block, this module also   *
!      * contains the actual array for storing the blocks and the       *
!      * number of blocks stored on this processor.                     *
!      *                                                                *
!      ******************************************************************
!
  SAVE 
! Parameters used for coarsening definition.
  INTEGER(KIND=PORTYPE), PARAMETER :: leftstarted=-1_porType
  INTEGER(KIND=PORTYPE), PARAMETER :: regular=0_porType
  INTEGER(KIND=PORTYPE), PARAMETER :: rightstarted=1_porType
! Parameters used for subsonic inlet bc treatment.
  INTEGER(KIND=INTTYPE), PARAMETER :: nosubinlet=0_intType
  INTEGER(KIND=INTTYPE), PARAMETER :: totalconditions=1_intType
  INTEGER(KIND=INTTYPE), PARAMETER :: massflow=2_intType
! tau(:,:,6): The 6 components of the viscous stress tensor.
!             The first 2 dimensions of these arrays are equal
!             to the dimenions of the cell subface without any
!             halo cell. Consequently the starting index is
!             arbitrary, such that no offset computation is
!             needed when the arrays are accessed.
! q(:,:,3):   Same story for the heat flux vector.
! uTau(:,:):  And for the friction velocity.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type visc_subface_type,     *
!      * which stores the viscous stress tensor and heat flux vector.   *
!      * In this way it is avoided that these quantities must be        *
!      * recomputed for the viscous forces and postprocessing. This     *
!      * saves both time and a considerable amount of code.             *
!      *                                                                *
!      ******************************************************************
!
  TYPE VISCSUBFACETYPE
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: tau, q
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: utau
  END TYPE VISCSUBFACETYPE
! inBeg, inEnd: Node range in the first direction of the subface
! jnBeg, jnEnd: Idem in the second direction.
! icBeg, icEnd: Cell range in the first direction of the subface
! jcBeg, jcEnd: Idem in the second direction.
! norm(:,:,3):  The unit normal; it points out of the domain.
! rface(:,:):   Velocity of the face in the direction of the
!               outward pointing normal. only allocated for
!               the boundary conditions that need this info.
! subsonicInletTreatment: which boundary condition treatment
!                         to use for subsonic inlets; either
!                         totalConditions or massFlow.
! uSlip(:,:,3):  the 3 components of the velocity vector on
!                a viscous wall. 
! TNS_Wall(:,:): Wall temperature for isothermal walls.
! ptInlet(:,:):       Total pressure at subsonic inlets.
! ttInlet(:,:):       Total temperature at subsonic inlets.
! htInlet(:,:):       Total enthalpy at subsonic inlets.
! flowXDirInlet(:,:): X-direction of the flow for subsonic
!                     inlets.
! flowYDirInlet(:,:): Idem in y-direction.
! flowZDirInlet(:,:): Idem in z-direction.
! turbInlet(:,:,nt1:nt2): Turbulence variables at inlets,
!                         either subsonic or supersonic.
! rho(:,:):  density; used for multiple bc's.
! velX(:,:): x-velocity; used for multiple bc's.
! velY(:,:): y-velocity; used for multiple bc's.
! velZ(:,:): z-velocity; used for multiple bc's.
! ps(:,:):   static pressure; used for multiple bc's.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type BCDataType, which      *
!      * stores the prescribed data of boundary faces as well as unit   *
!      * normals. For all the arrays the first two dimensions equal the *
!      * dimensions of the subface, possibly extended with halo cells.  *
!      * Consequently the starting index is arbitrary, such that no     *
!      * offset computation is needed when the array is accessed.       *
!      *                                                                *
!      ******************************************************************
!
  TYPE BCDATATYPE
      INTEGER(KIND=INTTYPE) :: inbeg, inend, jnbeg, jnend
      INTEGER(KIND=INTTYPE) :: icbeg, icend, jcbeg, jcend
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: norm
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: rface
      INTEGER(KIND=INTTYPE) :: subsonicinlettreatment
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: uslip
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: tns_wall
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: ptinlet
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: ttinlet
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: htinlet
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: flowxdirinlet
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: flowydirinlet
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: flowzdirinlet
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: turbinlet
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: rho
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: velx
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: vely
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: velz
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: ps
  END TYPE BCDATATYPE
!
!        ****************************************************************
!        *                                                              *
!        * Block dimensions and orientation.                            *
!        *                                                              *
!        ****************************************************************
!
!  nx, ny, nz - Block integer dimensions for no halo cell based
!               quantities.
!  il, jl, kl - Block integer dimensions for no halo node based
!               quantities.
!  ie, je, ke - Block integer dimensions for single halo
!               cell-centered quantities.
!  ib, jb, kb - Block integer dimensions for double halo
!               cell-centered quantities.
! rightHanded - Whether or not the block is a right handed.
!               If not right handed it is left handed of course.
!
!        ****************************************************************
!        *                                                              *
!        * Block boundary conditions.                                   *
!        *                                                              *
!        ****************************************************************
!
!  nSubface             - Number of subfaces on this block.
!  n1to1                - Number of 1 to 1 block boundaries.
!  nBocos               - Number of physical boundary subfaces.
!  nViscBocos           - Number of viscous boundary subfaces.
!  BCType(:)            - Boundary condition type for each
!                         subface. See the module BCTypes for
!                         the possibilities.
!  BCFaceID(:)          - Block face location of each subface.
!                         possible values are: iMin, iMax, jMin,
!                         jMax, kMin, kMax. see also module
!                         BCTypes.
!  cgnsSubface(:)       - The subface in the corresponding cgns
!                         block. As cgns distinguishes between
!                         boundary and internal boundaries, the
!                         BCType of the subface is needed to
!                         know which one to take.
!  inBeg(:), inEnd(:)   - Lower and upper limits for the nodes
!  jnBeg(:), jnEnd(:)     in each of the index directions on a
!  knBeg(:), knEnd(:)     given subface. Note that one of these
!                         indices will not change since we will
!                         be moving on a face.
!  dinBeg(:), dinEnd(:) - Lower and upper limits for the nodes
!  djnBeg(:), djnEnd(:)   in the each of the index directions
!  dknBeg(:), dknEnd(:)   of the donor subface for this
!                         particular subface. Note that one of
!                         these indices will not change since we
!                         will be moving on a face.
!  icBeg(:), icEnd(:)   - Lower and upper limits for the cells
!  jcBeg(:), jcEnd(:)     in each of the index directions for
!  kcBeg(:), kcEnd(:)     the subface. The cells indicated by
!                         this range are halo cells (the 
!                         constant index) adjacent to the face.
!                         a possible overlap outside the block
!                         is stored.
!  neighBlock(:)        - Local block number to which this
!                         subface connects. This value is set to
!                         zero if this subface is not connected
!                         to another block.
!  neighProc(:)         - Processor number where the neighbor
!                         block is stored. This value is set to
!                         -1 if this subface is not connected
!                         to another block.
!  l1(:), l2(:),        - Short hand for the transformation
!  l3(:)                  matrix between this subface and the
!                         neighbor block. These values are set
!                         to zero if this subface is not
!                         connected to another block.
!  groupNum(:)          - Group number to which this subface
!                         belongs. If this subface does not
!                         belong to any group, the corresponding
!                         entry in this array is zeroed out. If
!                         the subface belongs to a sliding mesh
!                         interface the absolute value of 
!                         groupNum contains the number of the
!                         sliding mesh interface. One side of
!                         the interface gets a positive number,
!                         the other side a negative one.
!
!        ****************************************************************
!        *                                                              *
!        * Overset boundary (fringe) cells and blanked cells.           *
!        *                                                              *
!        ****************************************************************
!
!  iblank(0:Ib,0:jb,0:kb) - stores an integer for every cell of
!                           this block, including halos. The
!                           following convention is used:
!                           + field = 1
!                           + hole = 0
!                           + fringe >= 9 preprocessing
!                                     = 0 solver
!                           + oversetOuterBound boco = -1
!                           + any other boco halos = 2
!  nHoles                 - number of owned hole cells.
!  nCellsOverset          - number of owned overset cells with
!                           donors.
!  nCellsOversetAll       - total number of overset cells
!                           including fringe from 1-to-1 halos
!                           and orphans.
!  nOrphans               - number of orphans (boundary cells
!                           without donors).
!  ibndry(3,..)           - indices for each overset cell.
!  idonor(3,..)           - donor indices for each overset cell.
!  overint(3,..)          - interpolants for the donor stencil.
!  neighBlockOver(..)     - local block number to which donor
!                           cell belongs.
!  neighProcOver(..)      - processor number where the neighbor
!                           block is stored.
!
!        ****************************************************************
!        *                                                              *
!        * Boundary data for the boundary subfaces.                     *
!        *                                                              *
!        ****************************************************************
!
! BCData(nBocos): The boundary data for each of the boundary
!                 subfaces.
!
!        ****************************************************************
!        *                                                              *
!        * The stress tensor and heat flux vector at viscous wall faces *
!        * as well as the face pointers to these viscous wall faces.    *
!        *                                                              *
!        ****************************************************************
!
! viscSubface(nViscBocos):    Storage for the viscous stress
!                             tensor and heat flux vector for
!                             the viscous subfaces.
! viscIMinPointer(2:jl,2:kl): Pointer to viscous subface for 
!                             the iMin block face. If the face
!                             is not part of a viscous subface
!                             this value is set to 0.
! viscIMaxPointer(2:jl,2:kl): Idem for iMax block face.
! viscJMinPointer(2:il,2:kl): Idem for jMin block face.
! viscJMaxPointer(2:il,2:kl): Idem for jmax block face.
! viscKMinPointer(2:il,2:jl): Idem for kMin block face.
! viscKMaxPointer(2:il,2:jl): Idem for kMax block face.
!
!        ****************************************************************
!        *                                                              *
!        * Mesh related variables.                                      *
!        *                                                              *
!        ****************************************************************
!
!  x(0:ie,0:je,0:ke,3)  - xyz locations of grid points in block.
!  xOld(nOld,:,:,:,:)   - Coordinates on older time levels;
!                         only needed for unsteady problems on
!                         deforming grids. Only allocated on
!                         the finest grid level. The blank
!                         dimensions are equal to the dimensions
!                         of x.
!  sI(0:ie,1:je,1:ke,3) - Projected areas in the i-coordinate
!                         direction. Normals point in the
!                         direction of increasing i.
!  sJ(1:ie,0:je,1:ke,3) - Projected areas in the j-coordinate
!                         direction. Normals point in the
!                         direction of increasing j.
!  sK(1:ie,1:je,0:ke,3) - Projected areas in the k-coordinate
!                         direction. Normals point in the
!                         direction of increasing k.
!  vol(0:ib,0:jb,0:kb)  - Cell volumes. The second level halo
!                         is present for a multigrid option.
!  volOld(nold,2:il,..) - Volumes on older time levels; only
!                         needed for unsteady problems on
!                         deforming grids. Only allocated on
!                         the finest grid level.
!  porI(1:il,2:jl,2:kl) - Porosity in the i direction.
!  porJ(2:il,1:jl,2:kl) - Porosity in the j direction.
!  porK(2:il,2:jl,1:kl) - Porosity in the k direction.
!
!  indFamilyI(:,:,:)  - Index of the i-face in the arrays
!                       to compute the local mass flow
!                       for a family or sliding mesh interface.
!                       Dimension is (1:il,2:jl,2:kl).
!  indFamilyJ(:,:,:)  - Idem for the j-faces.
!                       Dimension is (2:il,1:jl,2:kl).
!  indFamilyK(:,:,:)  - Idem for the k-faces.
!                       Dimension is (2:il,2:jl,1:kl)
!  factFamilyI(:,:,:) - Corresponding factor to make sure
!                       that the massflow is defined positive
!                       when it enters the block and to define
!                       the mass flow of the entire wheel
!                       instead of a sector. Hence the possible
!                       values or -nSlices and nSlices, where
!                       nSlices or the number of sections to
!                       obtain the full wheel.
!  factFamilyJ(:,:,:) - Idem for the j-faces.
!  factFamilyK(:,:,:) - Idem for the k-faces.
!
!  rotMatrixI(:,:,:,:,:) - Rotation matrix of the i-faces to
!                          transform the velocity components
!                          from Cartesian to local cylindrical.
!                          This is needed only for problems with
!                          rotational periodicity in combination
!                          with an upwind scheme.
!                          Dimension is (1:il,2:jl,2:kl,3,3).
!  rotMatrixJ(:,:,:,:,:) - Idem for the j-faces.
!                          Dimension is (2:il,1:jl,2:kl,3,3).
!  rotMatrixK(:,:,:,:,:) - Idem for the k-faces.
!                          Dimension is (2:il,2:jl,1:kl,3,3).
!
!  blockIsMoving      - Whether or not the block is moving.
!  addGridVelocities  - Whether or not the face velocities
!                       are allocated and set.
!  sFaceI(0:ie,je,ke) - Dot product of the face velocity and
!                       the normal in i-direction.
!  sFaceJ(ie,0:je,ke) - Idem in j-direction.
!  sFaceK(ie,je,0:ke) - Idem in k-direction.
!
!        ****************************************************************
!        *                                                              *
!        * Flow variables.                                              *
!        *                                                              *
!        ****************************************************************
!
! w(0:ib,0:jb,0:kb,1:nw)       - The set of independent variables
!                                w(i,j,k,1:nwf) flow field
!                                variables, which are rho, u, 
!                                v, w and rhoE. In other words
!                                the velocities  are stored and
!                                not the momentum!!!!
!                                w(i,j,k,nt1:nt2) turbulent 
!                                variables; also the primitive
!                                variables are stored.
! wOld(nOld,2:il,2:jl,2:kl,nw) - Solution on older time levels,
!                                needed for the time integration
!                                for unsteady problems. In
!                                constrast to w, the conservative
!                                variables are stored in wOld for
!                                the flow variables; the turbulent
!                                variables are always the
!                                primitive ones.
!                                Only allocated on the finest
!                                mesh.
! p(0:ib,0:jb,0:kb)            - Static pressure.
! gamma(0:ib,0:jb,0:kb)        - Specific heat ratio; only
!                                allocated on the finest grid.
! rlv(0:ib,0:jb,0:kb)          - Laminar viscosity; only
!                                allocated on the finest mesh
!                                and only for viscous problems.
! rev(0:ib,0:jb,0:kb)          - Eddy viscosity; only
!                                allocated rans problems with
!                                eddy viscosity models.
! s(1:ie,1:je,1:ke,3)          - Mesh velocities of the cell
!                                centers; only for moving mesh
!                                problems.
!
!        ****************************************************************
!        *                                                              *
!        * Residual and multigrid variables.                            *
!        *                                                              *
!        ****************************************************************
!
! dw(0:ib,0:jb,0:kb,1:nw)   - Values of convective and combined
!                             flow residuals. Only allocated on
!                             the finest mesh.
! fw(0:ib,0:jb,0:kb,1:nwf)  - values of artificial dissipation
!                             and viscous residuals.
!                             Only allocated on the finest mesh.
! dwOldRK(:,2:il,2:jl,2:kl,nw) - Old residuals for the time
!                                accurate Runge-Kutta schemes.
!                                The first dimension is
!                                nRKStagesUnsteady - 1.Only
!                                allocated on the finest level
!                                and only in unsteady mode for
!                                Runge-Kutta schemes.
! w1(1:ie,1:je,1:ke,1:nMGVar) - Values of the mg variables
!                               upon first entry to a coarser
!                               mesh; only allocated on the
!                               coarser grids. The variables
!                               used to compute the multigrid
!                               corrections are rho, u, v, w
!                               and p; the rhoE value is used
!                               for unsteady problems only.
! p1(1:ie,1:je,1:ke)          - Value of the pressure upon
!                               first entry to a coarser grid;
!                               only allocated on the coarser
!                               grids.
! wr(2:il,2:jl,2:kl,1:nMGVar) - Multigrid forcing terms; only 
!                               allocated on the coarser grids.
!                               The forcing term of course
!                               contains conservative residuals,
!                               at least for the flow variables.
! mgIFine(2:il,2) - The two fine grid i-cells used for the
!                   restriction of the solution and residual to
!                   the coarse grid. Only on the coarser grids.
! mgJFine(2:jl,2) - Idem for j-cells.
! mgKFine(2:kl,2) - Idem for k-cells.
! mgIWeight(2:il) - Weight for the residual restriction in
!                   in i-direction. Value is either 0.5 or 1.0,
!                   depending whether mgIFine(,1) is equal to
!                   or differs from mgIFine(,2).
! mgJWeight(2:jl) - Idem for weights in j-direction.
! mgKWeight(2:kl) - Idem for weights in k-direction.
! mgICoarse(2:il,2) - The two coarse grid i-cells used for the
!                     interpolation of the correction to the
!                     fine grid. Not on the coarsest grid.
! mgJCoarse(2:jl,2) - Idem for j-cells.
! mgKCoarse(2:kl,2) - Idem for k-cells.
! iCoarsened - How this block was coarsened in i-direction.
! jCoarsened - How this block was coarsened in j-direction.
! kCoarsened - How this block was coarsened in k-direction.
! iCo: Indicates whether or not i grid lines are present on the
!      coarse grid; not allocated for the coarsest grid.
! jCo: Idem in j-direction.
! kCo: Idem in k-direction.
!
!        ****************************************************************
!        *                                                              *
!        * Time-stepping and spectral radii variables.                  *
!        * only allocated on the finest grid.                           *
!        *                                                              *
!        ****************************************************************
!
! wn(2:il,2:jl,2:kl,1:nMGVar) - Values of the update variables
!                               at the beginning of the RungeKutta
!                               iteration. Only allocated for
!                               RungeKutta smoother.
! pn(2:il,2:jl,2:kl)          - The pressure for the RungeKutta
!                               smoother.
! dtl(1:ie,1:je,1:ke)         - Time step
! radI(1:ie,1:je,1:ke)        - Spectral radius in i-direction.
! radJ(1:ie,1:je,1:ke)        - Spectral radius in j-direction.
! radK(1:ie,1:je,1:ke)        - Spectral radius in k-direction.
!
!        ****************************************************************
!        *                                                              *
!        * Turbulence model variables.                                  *
!        *                                                              *
!        ****************************************************************
!
! d2Wall(2:il,2:jl,2:kl) - Distance from the center of the cell
!                          to the nearest viscous wall.
! bmti1(je,ke,nt1:nt2,nt1:nt2): Matrix used for the implicit
!                               boundary condition treatment of
!                               the turbulence equations at the
!                               iMin boundary. Only allocated on
!                               the finest level and for the 1st
!                               spectral solution.
! bmti2(je,ke,nt1:nt2,nt1:nt2): Idem for the iMax boundary.
! bmtj1(ie,ke,nt1:nt2,nt1:nt2): Idem for the jMin boundary.
! bmtj2(ie,ke,nt1:nt2,nt1:nt2): Idem for the jMax boundary.
! bmtk1(ie,je,nt1:nt2,nt1:nt2): Idem for the kMin boundary.
! bmtk2(ie,je,nt1:nt2,nt1:nt2): Idem for the kMax boundary.
! bvti1(je,ke,nt1:nt2): RHS vector used for the implicit
!                       boundary condition treatment of the
!                       turbulence equations at the iMin
!                       boundary. Only allocated on the finest
!                       level and for the 1st spectral solution.
! bvti2(je,ke,nt1:nt2): Idem for the iMax boundary.
! bvtj1(ie,ke,nt1:nt2): Idem for the jMin boundary.
! bvtj2(ie,ke,nt1:nt2): Idem for the jMax boundary.
! bvti2(je,ke,nt1:nt2): Idem for the iMax boundary.
! bvtk1(ie,ke,nt1:nt2): Idem for the kMin boundary.
! bvtk2(ie,ke,nt1:nt2): idem for the kMax boundary.
!
!        ****************************************************************
!        *                                                              *
!        * Relation to the original cgns grid.                          *
!        *                                                              *
!        ****************************************************************
!
! sectionID      - The section of the grid this block belongs to.
! cgnsBlockID    - Block/zone number of the cgns grid to which
!                  this block is related.
! iBegOr, iEndOr - Range of points of this block in the
! jBegOr, jEndOr   corresponding cgns block, i.e. for this block
! kBegOr, kEndOr   iBegOr <= i <= iEndOr, jBegOr <= j <= jEndOr, 
!                  kBegOr <= k <= kEndOr.
!                  It is of course possible that the entire
!                  block is stored.
!
!        ****************************************************************
!        *                                                              *
!        * Adjoint solver variables.                                    *
!        *                                                              *
!        ****************************************************************
!
! globalNode(ib:ie,jb:je,kb:ke):  Global node numbering.
! globalCell(0:ib,0:jb,0:kb):     Global cell numbering.
! psiAdj(ib:ie,jb:je,kb:ke,1:nw): The adjoint variables.
!                                 Correspond to the flow field
!                                 variables w(i,j,k,1:nw).
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type block_type, which      *
!      * stores dimensions, coordinates, solution, etc.                 *
!      *                                                                *
!      ******************************************************************
!
  TYPE BLOCKTYPE
      INTEGER(KIND=INTTYPE) :: nx, ny, nz
      INTEGER(KIND=INTTYPE) :: il, jl, kl
      INTEGER(KIND=INTTYPE) :: ie, je, ke
      INTEGER(KIND=INTTYPE) :: ib, jb, kb
      LOGICAL :: righthanded
      INTEGER(KIND=INTTYPE) :: nsubface, n1to1, nbocos, nviscbocos
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: bctype
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: bcfaceid
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: cgnssubface
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: inbeg, inend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: jnbeg, jnend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: knbeg, knend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: dinbeg, dinend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: djnbeg, djnend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: dknbeg, dknend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: icbeg, icend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: jcbeg, jcend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: kcbeg, kcend
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: neighblock
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: neighproc
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: l1, l2, l3
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: groupnum
      INTEGER(KIND=INTTYPE) :: ncellsoverset, ncellsoversetall
      INTEGER(KIND=INTTYPE) :: nholes, norphans
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: iblank
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: ibndry
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: idonor
      REAL(KIND=REALTYPE), DIMENSION(:, :), POINTER :: overint
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: neighblockover
      INTEGER(KIND=INTTYPE), DIMENSION(:), POINTER :: neighprocover
      TYPE(BCDATATYPE), DIMENSION(:), POINTER :: bcdata
      TYPE(VISCSUBFACETYPE), DIMENSION(:), POINTER :: viscsubface
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: visciminpointer
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: viscimaxpointer
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: viscjminpointer
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: viscjmaxpointer
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: visckminpointer
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: visckmaxpointer
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: x
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :, :), POINTER :: xold
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: si, sj, sk
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: vol
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: volold
      INTEGER(KIND=PORTYPE), DIMENSION(:, :, :), POINTER :: pori
      INTEGER(KIND=PORTYPE), DIMENSION(:, :, :), POINTER :: porj
      INTEGER(KIND=PORTYPE), DIMENSION(:, :, :), POINTER :: pork
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: indfamilyi
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: indfamilyj
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: indfamilyk
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: factfamilyi
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: factfamilyj
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: factfamilyk
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :, :), POINTER :: &
&      rotmatrixi
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :, :), POINTER :: &
&      rotmatrixj
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :, :), POINTER :: &
&      rotmatrixk
      LOGICAL :: blockismoving, addgridvelocities
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: sfacei
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: sfacej
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: sfacek
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: w
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :, :), POINTER :: wold
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: p, gamma
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: rlv, rev
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: s
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: p1
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: dw, fw
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :, :), POINTER :: dwoldrk
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: w1, wr
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: mgifine
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: mgjfine
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: mgkfine
      REAL(KIND=REALTYPE), DIMENSION(:), POINTER :: mgiweight
      REAL(KIND=REALTYPE), DIMENSION(:), POINTER :: mgjweight
      REAL(KIND=REALTYPE), DIMENSION(:), POINTER :: mgkweight
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: mgicoarse
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: mgjcoarse
      INTEGER(KIND=INTTYPE), DIMENSION(:, :), POINTER :: mgkcoarse
      INTEGER(KIND=PORTYPE) :: icoarsened, jcoarsened, kcoarsened
      LOGICAL, DIMENSION(:), POINTER :: ico, jco, kco
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: wn
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: pn
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: dtl
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: radi
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: radj
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: radk
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: d2wall
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: bmti1
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: bmti2
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: bmtj1
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: bmtj2
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: bmtk1
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: bmtk2
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: bvti1, bvti2
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: bvtj1, bvtj2
      REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: bvtk1, bvtk2
      INTEGER(KIND=INTTYPE) :: cgnsblockid, sectionid
      INTEGER(KIND=INTTYPE) :: ibegor, iendor, jbegor, jendor
      INTEGER(KIND=INTTYPE) :: kbegor, kendor
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: globalnode
      INTEGER(KIND=INTTYPE), DIMENSION(:, :, :), POINTER :: globalcell
      REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: psiadj
  END TYPE BLOCKTYPE
!
!      ******************************************************************
!      *                                                                *
!      * Array of all blocks at all multigrid levels and spectral sols. *
!      *                                                                *
!      ******************************************************************
!
! nDom:            total number of computational blocks.
! flowDoms(:,:,:): array of blocks. Dimensions are
!                  (nDom,nLevels,nTimeIntervalsSpectral)
  INTEGER(KIND=INTTYPE) :: ndom
  TYPE(BLOCKTYPE), DIMENSION(:, :, :), ALLOCATABLE :: flowdoms
!
!      ******************************************************************
!      *                                                                *
!      * Additional info needed in the flow solver.                     *
!      *                                                                *
!      ******************************************************************
!
! nCellGlobal(nLev) - Global number of cells on every mg level.
  INTEGER(KIND=INTTYPE), DIMENSION(:), ALLOCATABLE :: ncellglobal
END MODULE BLOCK_D
